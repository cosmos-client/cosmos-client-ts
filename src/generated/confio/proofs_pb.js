/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.ics23.BatchEntry', null, global);
goog.exportSymbol('proto.ics23.BatchProof', null, global);
goog.exportSymbol('proto.ics23.CommitmentProof', null, global);
goog.exportSymbol('proto.ics23.CompressedBatchEntry', null, global);
goog.exportSymbol('proto.ics23.CompressedBatchProof', null, global);
goog.exportSymbol('proto.ics23.CompressedExistenceProof', null, global);
goog.exportSymbol('proto.ics23.CompressedNonExistenceProof', null, global);
goog.exportSymbol('proto.ics23.ExistenceProof', null, global);
goog.exportSymbol('proto.ics23.HashOp', null, global);
goog.exportSymbol('proto.ics23.InnerOp', null, global);
goog.exportSymbol('proto.ics23.InnerSpec', null, global);
goog.exportSymbol('proto.ics23.LeafOp', null, global);
goog.exportSymbol('proto.ics23.LengthOp', null, global);
goog.exportSymbol('proto.ics23.NonExistenceProof', null, global);
goog.exportSymbol('proto.ics23.ProofSpec', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.ExistenceProof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ics23.ExistenceProof.repeatedFields_, null);
};
goog.inherits(proto.ics23.ExistenceProof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.ExistenceProof.displayName = 'proto.ics23.ExistenceProof';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ics23.ExistenceProof.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.ExistenceProof.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.ExistenceProof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.ExistenceProof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.ExistenceProof.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: msg.getKey_asB64(),
    value: msg.getValue_asB64(),
    leaf: (f = msg.getLeaf()) && proto.ics23.LeafOp.toObject(includeInstance, f),
    pathList: jspb.Message.toObjectList(msg.getPathList(),
    proto.ics23.InnerOp.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.ExistenceProof}
 */
proto.ics23.ExistenceProof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.ExistenceProof;
  return proto.ics23.ExistenceProof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.ExistenceProof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.ExistenceProof}
 */
proto.ics23.ExistenceProof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setKey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    case 3:
      var value = new proto.ics23.LeafOp;
      reader.readMessage(value,proto.ics23.LeafOp.deserializeBinaryFromReader);
      msg.setLeaf(value);
      break;
    case 4:
      var value = new proto.ics23.InnerOp;
      reader.readMessage(value,proto.ics23.InnerOp.deserializeBinaryFromReader);
      msg.addPath(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.ExistenceProof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.ExistenceProof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.ExistenceProof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.ExistenceProof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getLeaf();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ics23.LeafOp.serializeBinaryToWriter
    );
  }
  f = message.getPathList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.ics23.InnerOp.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes key = 1;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.ExistenceProof.prototype.getKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes key = 1;
 * This is a type-conversion wrapper around `getKey()`
 * @return {string}
 */
proto.ics23.ExistenceProof.prototype.getKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getKey()));
};


/**
 * optional bytes key = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getKey()`
 * @return {!Uint8Array}
 */
proto.ics23.ExistenceProof.prototype.getKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.ExistenceProof.prototype.setKey = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes value = 2;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.ExistenceProof.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes value = 2;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.ics23.ExistenceProof.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.ics23.ExistenceProof.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.ExistenceProof.prototype.setValue = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional LeafOp leaf = 3;
 * @return {?proto.ics23.LeafOp}
 */
proto.ics23.ExistenceProof.prototype.getLeaf = function() {
  return /** @type{?proto.ics23.LeafOp} */ (
    jspb.Message.getWrapperField(this, proto.ics23.LeafOp, 3));
};


/** @param {?proto.ics23.LeafOp|undefined} value */
proto.ics23.ExistenceProof.prototype.setLeaf = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.ics23.ExistenceProof.prototype.clearLeaf = function() {
  this.setLeaf(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.ExistenceProof.prototype.hasLeaf = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated InnerOp path = 4;
 * @return {!Array<!proto.ics23.InnerOp>}
 */
proto.ics23.ExistenceProof.prototype.getPathList = function() {
  return /** @type{!Array<!proto.ics23.InnerOp>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ics23.InnerOp, 4));
};


/** @param {!Array<!proto.ics23.InnerOp>} value */
proto.ics23.ExistenceProof.prototype.setPathList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.ics23.InnerOp=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ics23.InnerOp}
 */
proto.ics23.ExistenceProof.prototype.addPath = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.ics23.InnerOp, opt_index);
};


proto.ics23.ExistenceProof.prototype.clearPathList = function() {
  this.setPathList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.NonExistenceProof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ics23.NonExistenceProof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.NonExistenceProof.displayName = 'proto.ics23.NonExistenceProof';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.NonExistenceProof.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.NonExistenceProof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.NonExistenceProof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.NonExistenceProof.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: msg.getKey_asB64(),
    left: (f = msg.getLeft()) && proto.ics23.ExistenceProof.toObject(includeInstance, f),
    right: (f = msg.getRight()) && proto.ics23.ExistenceProof.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.NonExistenceProof}
 */
proto.ics23.NonExistenceProof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.NonExistenceProof;
  return proto.ics23.NonExistenceProof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.NonExistenceProof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.NonExistenceProof}
 */
proto.ics23.NonExistenceProof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setKey(value);
      break;
    case 2:
      var value = new proto.ics23.ExistenceProof;
      reader.readMessage(value,proto.ics23.ExistenceProof.deserializeBinaryFromReader);
      msg.setLeft(value);
      break;
    case 3:
      var value = new proto.ics23.ExistenceProof;
      reader.readMessage(value,proto.ics23.ExistenceProof.deserializeBinaryFromReader);
      msg.setRight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.NonExistenceProof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.NonExistenceProof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.NonExistenceProof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.NonExistenceProof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getLeft();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ics23.ExistenceProof.serializeBinaryToWriter
    );
  }
  f = message.getRight();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ics23.ExistenceProof.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes key = 1;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.NonExistenceProof.prototype.getKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes key = 1;
 * This is a type-conversion wrapper around `getKey()`
 * @return {string}
 */
proto.ics23.NonExistenceProof.prototype.getKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getKey()));
};


/**
 * optional bytes key = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getKey()`
 * @return {!Uint8Array}
 */
proto.ics23.NonExistenceProof.prototype.getKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.NonExistenceProof.prototype.setKey = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional ExistenceProof left = 2;
 * @return {?proto.ics23.ExistenceProof}
 */
proto.ics23.NonExistenceProof.prototype.getLeft = function() {
  return /** @type{?proto.ics23.ExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.ExistenceProof, 2));
};


/** @param {?proto.ics23.ExistenceProof|undefined} value */
proto.ics23.NonExistenceProof.prototype.setLeft = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.ics23.NonExistenceProof.prototype.clearLeft = function() {
  this.setLeft(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.NonExistenceProof.prototype.hasLeft = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional ExistenceProof right = 3;
 * @return {?proto.ics23.ExistenceProof}
 */
proto.ics23.NonExistenceProof.prototype.getRight = function() {
  return /** @type{?proto.ics23.ExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.ExistenceProof, 3));
};


/** @param {?proto.ics23.ExistenceProof|undefined} value */
proto.ics23.NonExistenceProof.prototype.setRight = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.ics23.NonExistenceProof.prototype.clearRight = function() {
  this.setRight(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.NonExistenceProof.prototype.hasRight = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.CommitmentProof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.ics23.CommitmentProof.oneofGroups_);
};
goog.inherits(proto.ics23.CommitmentProof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.CommitmentProof.displayName = 'proto.ics23.CommitmentProof';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.ics23.CommitmentProof.oneofGroups_ = [[1,2,3,4]];

/**
 * @enum {number}
 */
proto.ics23.CommitmentProof.ProofCase = {
  PROOF_NOT_SET: 0,
  EXIST: 1,
  NONEXIST: 2,
  BATCH: 3,
  COMPRESSED: 4
};

/**
 * @return {proto.ics23.CommitmentProof.ProofCase}
 */
proto.ics23.CommitmentProof.prototype.getProofCase = function() {
  return /** @type {proto.ics23.CommitmentProof.ProofCase} */(jspb.Message.computeOneofCase(this, proto.ics23.CommitmentProof.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.CommitmentProof.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.CommitmentProof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.CommitmentProof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CommitmentProof.toObject = function(includeInstance, msg) {
  var f, obj = {
    exist: (f = msg.getExist()) && proto.ics23.ExistenceProof.toObject(includeInstance, f),
    nonexist: (f = msg.getNonexist()) && proto.ics23.NonExistenceProof.toObject(includeInstance, f),
    batch: (f = msg.getBatch()) && proto.ics23.BatchProof.toObject(includeInstance, f),
    compressed: (f = msg.getCompressed()) && proto.ics23.CompressedBatchProof.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.CommitmentProof}
 */
proto.ics23.CommitmentProof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.CommitmentProof;
  return proto.ics23.CommitmentProof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.CommitmentProof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.CommitmentProof}
 */
proto.ics23.CommitmentProof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ics23.ExistenceProof;
      reader.readMessage(value,proto.ics23.ExistenceProof.deserializeBinaryFromReader);
      msg.setExist(value);
      break;
    case 2:
      var value = new proto.ics23.NonExistenceProof;
      reader.readMessage(value,proto.ics23.NonExistenceProof.deserializeBinaryFromReader);
      msg.setNonexist(value);
      break;
    case 3:
      var value = new proto.ics23.BatchProof;
      reader.readMessage(value,proto.ics23.BatchProof.deserializeBinaryFromReader);
      msg.setBatch(value);
      break;
    case 4:
      var value = new proto.ics23.CompressedBatchProof;
      reader.readMessage(value,proto.ics23.CompressedBatchProof.deserializeBinaryFromReader);
      msg.setCompressed(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.CommitmentProof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.CommitmentProof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.CommitmentProof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CommitmentProof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getExist();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ics23.ExistenceProof.serializeBinaryToWriter
    );
  }
  f = message.getNonexist();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ics23.NonExistenceProof.serializeBinaryToWriter
    );
  }
  f = message.getBatch();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ics23.BatchProof.serializeBinaryToWriter
    );
  }
  f = message.getCompressed();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.ics23.CompressedBatchProof.serializeBinaryToWriter
    );
  }
};


/**
 * optional ExistenceProof exist = 1;
 * @return {?proto.ics23.ExistenceProof}
 */
proto.ics23.CommitmentProof.prototype.getExist = function() {
  return /** @type{?proto.ics23.ExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.ExistenceProof, 1));
};


/** @param {?proto.ics23.ExistenceProof|undefined} value */
proto.ics23.CommitmentProof.prototype.setExist = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.ics23.CommitmentProof.oneofGroups_[0], value);
};


proto.ics23.CommitmentProof.prototype.clearExist = function() {
  this.setExist(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CommitmentProof.prototype.hasExist = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional NonExistenceProof nonexist = 2;
 * @return {?proto.ics23.NonExistenceProof}
 */
proto.ics23.CommitmentProof.prototype.getNonexist = function() {
  return /** @type{?proto.ics23.NonExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.NonExistenceProof, 2));
};


/** @param {?proto.ics23.NonExistenceProof|undefined} value */
proto.ics23.CommitmentProof.prototype.setNonexist = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.ics23.CommitmentProof.oneofGroups_[0], value);
};


proto.ics23.CommitmentProof.prototype.clearNonexist = function() {
  this.setNonexist(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CommitmentProof.prototype.hasNonexist = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional BatchProof batch = 3;
 * @return {?proto.ics23.BatchProof}
 */
proto.ics23.CommitmentProof.prototype.getBatch = function() {
  return /** @type{?proto.ics23.BatchProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.BatchProof, 3));
};


/** @param {?proto.ics23.BatchProof|undefined} value */
proto.ics23.CommitmentProof.prototype.setBatch = function(value) {
  jspb.Message.setOneofWrapperField(this, 3, proto.ics23.CommitmentProof.oneofGroups_[0], value);
};


proto.ics23.CommitmentProof.prototype.clearBatch = function() {
  this.setBatch(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CommitmentProof.prototype.hasBatch = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional CompressedBatchProof compressed = 4;
 * @return {?proto.ics23.CompressedBatchProof}
 */
proto.ics23.CommitmentProof.prototype.getCompressed = function() {
  return /** @type{?proto.ics23.CompressedBatchProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.CompressedBatchProof, 4));
};


/** @param {?proto.ics23.CompressedBatchProof|undefined} value */
proto.ics23.CommitmentProof.prototype.setCompressed = function(value) {
  jspb.Message.setOneofWrapperField(this, 4, proto.ics23.CommitmentProof.oneofGroups_[0], value);
};


proto.ics23.CommitmentProof.prototype.clearCompressed = function() {
  this.setCompressed(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CommitmentProof.prototype.hasCompressed = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.LeafOp = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ics23.LeafOp, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.LeafOp.displayName = 'proto.ics23.LeafOp';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.LeafOp.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.LeafOp.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.LeafOp} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.LeafOp.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: jspb.Message.getFieldWithDefault(msg, 1, 0),
    prehashKey: jspb.Message.getFieldWithDefault(msg, 2, 0),
    prehashValue: jspb.Message.getFieldWithDefault(msg, 3, 0),
    length: jspb.Message.getFieldWithDefault(msg, 4, 0),
    prefix: msg.getPrefix_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.LeafOp}
 */
proto.ics23.LeafOp.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.LeafOp;
  return proto.ics23.LeafOp.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.LeafOp} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.LeafOp}
 */
proto.ics23.LeafOp.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.ics23.HashOp} */ (reader.readEnum());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {!proto.ics23.HashOp} */ (reader.readEnum());
      msg.setPrehashKey(value);
      break;
    case 3:
      var value = /** @type {!proto.ics23.HashOp} */ (reader.readEnum());
      msg.setPrehashValue(value);
      break;
    case 4:
      var value = /** @type {!proto.ics23.LengthOp} */ (reader.readEnum());
      msg.setLength(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrefix(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.LeafOp.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.LeafOp.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.LeafOp} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.LeafOp.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHash();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getPrehashKey();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getPrehashValue();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getLength();
  if (f !== 0.0) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = message.getPrefix_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
};


/**
 * optional HashOp hash = 1;
 * @return {!proto.ics23.HashOp}
 */
proto.ics23.LeafOp.prototype.getHash = function() {
  return /** @type {!proto.ics23.HashOp} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.ics23.HashOp} value */
proto.ics23.LeafOp.prototype.setHash = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional HashOp prehash_key = 2;
 * @return {!proto.ics23.HashOp}
 */
proto.ics23.LeafOp.prototype.getPrehashKey = function() {
  return /** @type {!proto.ics23.HashOp} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.ics23.HashOp} value */
proto.ics23.LeafOp.prototype.setPrehashKey = function(value) {
  jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional HashOp prehash_value = 3;
 * @return {!proto.ics23.HashOp}
 */
proto.ics23.LeafOp.prototype.getPrehashValue = function() {
  return /** @type {!proto.ics23.HashOp} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {!proto.ics23.HashOp} value */
proto.ics23.LeafOp.prototype.setPrehashValue = function(value) {
  jspb.Message.setProto3EnumField(this, 3, value);
};


/**
 * optional LengthOp length = 4;
 * @return {!proto.ics23.LengthOp}
 */
proto.ics23.LeafOp.prototype.getLength = function() {
  return /** @type {!proto.ics23.LengthOp} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {!proto.ics23.LengthOp} value */
proto.ics23.LeafOp.prototype.setLength = function(value) {
  jspb.Message.setProto3EnumField(this, 4, value);
};


/**
 * optional bytes prefix = 5;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.LeafOp.prototype.getPrefix = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes prefix = 5;
 * This is a type-conversion wrapper around `getPrefix()`
 * @return {string}
 */
proto.ics23.LeafOp.prototype.getPrefix_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrefix()));
};


/**
 * optional bytes prefix = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrefix()`
 * @return {!Uint8Array}
 */
proto.ics23.LeafOp.prototype.getPrefix_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrefix()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.LeafOp.prototype.setPrefix = function(value) {
  jspb.Message.setProto3BytesField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.InnerOp = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ics23.InnerOp, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.InnerOp.displayName = 'proto.ics23.InnerOp';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.InnerOp.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.InnerOp.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.InnerOp} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.InnerOp.toObject = function(includeInstance, msg) {
  var f, obj = {
    hash: jspb.Message.getFieldWithDefault(msg, 1, 0),
    prefix: msg.getPrefix_asB64(),
    suffix: msg.getSuffix_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.InnerOp}
 */
proto.ics23.InnerOp.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.InnerOp;
  return proto.ics23.InnerOp.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.InnerOp} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.InnerOp}
 */
proto.ics23.InnerOp.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.ics23.HashOp} */ (reader.readEnum());
      msg.setHash(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrefix(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSuffix(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.InnerOp.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.InnerOp.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.InnerOp} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.InnerOp.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHash();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getPrefix_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getSuffix_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional HashOp hash = 1;
 * @return {!proto.ics23.HashOp}
 */
proto.ics23.InnerOp.prototype.getHash = function() {
  return /** @type {!proto.ics23.HashOp} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.ics23.HashOp} value */
proto.ics23.InnerOp.prototype.setHash = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * optional bytes prefix = 2;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.InnerOp.prototype.getPrefix = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes prefix = 2;
 * This is a type-conversion wrapper around `getPrefix()`
 * @return {string}
 */
proto.ics23.InnerOp.prototype.getPrefix_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrefix()));
};


/**
 * optional bytes prefix = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrefix()`
 * @return {!Uint8Array}
 */
proto.ics23.InnerOp.prototype.getPrefix_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrefix()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.InnerOp.prototype.setPrefix = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional bytes suffix = 3;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.InnerOp.prototype.getSuffix = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes suffix = 3;
 * This is a type-conversion wrapper around `getSuffix()`
 * @return {string}
 */
proto.ics23.InnerOp.prototype.getSuffix_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSuffix()));
};


/**
 * optional bytes suffix = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSuffix()`
 * @return {!Uint8Array}
 */
proto.ics23.InnerOp.prototype.getSuffix_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSuffix()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.InnerOp.prototype.setSuffix = function(value) {
  jspb.Message.setProto3BytesField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.ProofSpec = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ics23.ProofSpec, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.ProofSpec.displayName = 'proto.ics23.ProofSpec';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.ProofSpec.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.ProofSpec.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.ProofSpec} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.ProofSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    leafSpec: (f = msg.getLeafSpec()) && proto.ics23.LeafOp.toObject(includeInstance, f),
    innerSpec: (f = msg.getInnerSpec()) && proto.ics23.InnerSpec.toObject(includeInstance, f),
    maxDepth: jspb.Message.getFieldWithDefault(msg, 3, 0),
    minDepth: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.ProofSpec}
 */
proto.ics23.ProofSpec.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.ProofSpec;
  return proto.ics23.ProofSpec.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.ProofSpec} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.ProofSpec}
 */
proto.ics23.ProofSpec.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ics23.LeafOp;
      reader.readMessage(value,proto.ics23.LeafOp.deserializeBinaryFromReader);
      msg.setLeafSpec(value);
      break;
    case 2:
      var value = new proto.ics23.InnerSpec;
      reader.readMessage(value,proto.ics23.InnerSpec.deserializeBinaryFromReader);
      msg.setInnerSpec(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxDepth(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinDepth(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.ProofSpec.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.ProofSpec.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.ProofSpec} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.ProofSpec.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeafSpec();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ics23.LeafOp.serializeBinaryToWriter
    );
  }
  f = message.getInnerSpec();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ics23.InnerSpec.serializeBinaryToWriter
    );
  }
  f = message.getMaxDepth();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getMinDepth();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
};


/**
 * optional LeafOp leaf_spec = 1;
 * @return {?proto.ics23.LeafOp}
 */
proto.ics23.ProofSpec.prototype.getLeafSpec = function() {
  return /** @type{?proto.ics23.LeafOp} */ (
    jspb.Message.getWrapperField(this, proto.ics23.LeafOp, 1));
};


/** @param {?proto.ics23.LeafOp|undefined} value */
proto.ics23.ProofSpec.prototype.setLeafSpec = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.ics23.ProofSpec.prototype.clearLeafSpec = function() {
  this.setLeafSpec(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.ProofSpec.prototype.hasLeafSpec = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional InnerSpec inner_spec = 2;
 * @return {?proto.ics23.InnerSpec}
 */
proto.ics23.ProofSpec.prototype.getInnerSpec = function() {
  return /** @type{?proto.ics23.InnerSpec} */ (
    jspb.Message.getWrapperField(this, proto.ics23.InnerSpec, 2));
};


/** @param {?proto.ics23.InnerSpec|undefined} value */
proto.ics23.ProofSpec.prototype.setInnerSpec = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.ics23.ProofSpec.prototype.clearInnerSpec = function() {
  this.setInnerSpec(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.ProofSpec.prototype.hasInnerSpec = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int32 max_depth = 3;
 * @return {number}
 */
proto.ics23.ProofSpec.prototype.getMaxDepth = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.ics23.ProofSpec.prototype.setMaxDepth = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int32 min_depth = 4;
 * @return {number}
 */
proto.ics23.ProofSpec.prototype.getMinDepth = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.ics23.ProofSpec.prototype.setMinDepth = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.InnerSpec = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ics23.InnerSpec.repeatedFields_, null);
};
goog.inherits(proto.ics23.InnerSpec, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.InnerSpec.displayName = 'proto.ics23.InnerSpec';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ics23.InnerSpec.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.InnerSpec.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.InnerSpec.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.InnerSpec} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.InnerSpec.toObject = function(includeInstance, msg) {
  var f, obj = {
    childOrderList: jspb.Message.getRepeatedField(msg, 1),
    childSize: jspb.Message.getFieldWithDefault(msg, 2, 0),
    minPrefixLength: jspb.Message.getFieldWithDefault(msg, 3, 0),
    maxPrefixLength: jspb.Message.getFieldWithDefault(msg, 4, 0),
    emptyChild: msg.getEmptyChild_asB64(),
    hash: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.InnerSpec}
 */
proto.ics23.InnerSpec.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.InnerSpec;
  return proto.ics23.InnerSpec.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.InnerSpec} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.InnerSpec}
 */
proto.ics23.InnerSpec.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Array<number>} */ (reader.readPackedInt32());
      msg.setChildOrderList(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setChildSize(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMinPrefixLength(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setMaxPrefixLength(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEmptyChild(value);
      break;
    case 6:
      var value = /** @type {!proto.ics23.HashOp} */ (reader.readEnum());
      msg.setHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.InnerSpec.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.InnerSpec.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.InnerSpec} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.InnerSpec.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getChildOrderList();
  if (f.length > 0) {
    writer.writePackedInt32(
      1,
      f
    );
  }
  f = message.getChildSize();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getMinPrefixLength();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getMaxPrefixLength();
  if (f !== 0) {
    writer.writeInt32(
      4,
      f
    );
  }
  f = message.getEmptyChild_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = message.getHash();
  if (f !== 0.0) {
    writer.writeEnum(
      6,
      f
    );
  }
};


/**
 * repeated int32 child_order = 1;
 * @return {!Array<number>}
 */
proto.ics23.InnerSpec.prototype.getChildOrderList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.ics23.InnerSpec.prototype.setChildOrderList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.ics23.InnerSpec.prototype.addChildOrder = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.ics23.InnerSpec.prototype.clearChildOrderList = function() {
  this.setChildOrderList([]);
};


/**
 * optional int32 child_size = 2;
 * @return {number}
 */
proto.ics23.InnerSpec.prototype.getChildSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.ics23.InnerSpec.prototype.setChildSize = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int32 min_prefix_length = 3;
 * @return {number}
 */
proto.ics23.InnerSpec.prototype.getMinPrefixLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.ics23.InnerSpec.prototype.setMinPrefixLength = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int32 max_prefix_length = 4;
 * @return {number}
 */
proto.ics23.InnerSpec.prototype.getMaxPrefixLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.ics23.InnerSpec.prototype.setMaxPrefixLength = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional bytes empty_child = 5;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.InnerSpec.prototype.getEmptyChild = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes empty_child = 5;
 * This is a type-conversion wrapper around `getEmptyChild()`
 * @return {string}
 */
proto.ics23.InnerSpec.prototype.getEmptyChild_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEmptyChild()));
};


/**
 * optional bytes empty_child = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEmptyChild()`
 * @return {!Uint8Array}
 */
proto.ics23.InnerSpec.prototype.getEmptyChild_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEmptyChild()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.InnerSpec.prototype.setEmptyChild = function(value) {
  jspb.Message.setProto3BytesField(this, 5, value);
};


/**
 * optional HashOp hash = 6;
 * @return {!proto.ics23.HashOp}
 */
proto.ics23.InnerSpec.prototype.getHash = function() {
  return /** @type {!proto.ics23.HashOp} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {!proto.ics23.HashOp} value */
proto.ics23.InnerSpec.prototype.setHash = function(value) {
  jspb.Message.setProto3EnumField(this, 6, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.BatchProof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ics23.BatchProof.repeatedFields_, null);
};
goog.inherits(proto.ics23.BatchProof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.BatchProof.displayName = 'proto.ics23.BatchProof';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ics23.BatchProof.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.BatchProof.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.BatchProof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.BatchProof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.BatchProof.toObject = function(includeInstance, msg) {
  var f, obj = {
    entriesList: jspb.Message.toObjectList(msg.getEntriesList(),
    proto.ics23.BatchEntry.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.BatchProof}
 */
proto.ics23.BatchProof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.BatchProof;
  return proto.ics23.BatchProof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.BatchProof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.BatchProof}
 */
proto.ics23.BatchProof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ics23.BatchEntry;
      reader.readMessage(value,proto.ics23.BatchEntry.deserializeBinaryFromReader);
      msg.addEntries(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.BatchProof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.BatchProof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.BatchProof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.BatchProof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEntriesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.ics23.BatchEntry.serializeBinaryToWriter
    );
  }
};


/**
 * repeated BatchEntry entries = 1;
 * @return {!Array<!proto.ics23.BatchEntry>}
 */
proto.ics23.BatchProof.prototype.getEntriesList = function() {
  return /** @type{!Array<!proto.ics23.BatchEntry>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ics23.BatchEntry, 1));
};


/** @param {!Array<!proto.ics23.BatchEntry>} value */
proto.ics23.BatchProof.prototype.setEntriesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.ics23.BatchEntry=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ics23.BatchEntry}
 */
proto.ics23.BatchProof.prototype.addEntries = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.ics23.BatchEntry, opt_index);
};


proto.ics23.BatchProof.prototype.clearEntriesList = function() {
  this.setEntriesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.BatchEntry = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.ics23.BatchEntry.oneofGroups_);
};
goog.inherits(proto.ics23.BatchEntry, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.BatchEntry.displayName = 'proto.ics23.BatchEntry';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.ics23.BatchEntry.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.ics23.BatchEntry.ProofCase = {
  PROOF_NOT_SET: 0,
  EXIST: 1,
  NONEXIST: 2
};

/**
 * @return {proto.ics23.BatchEntry.ProofCase}
 */
proto.ics23.BatchEntry.prototype.getProofCase = function() {
  return /** @type {proto.ics23.BatchEntry.ProofCase} */(jspb.Message.computeOneofCase(this, proto.ics23.BatchEntry.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.BatchEntry.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.BatchEntry.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.BatchEntry} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.BatchEntry.toObject = function(includeInstance, msg) {
  var f, obj = {
    exist: (f = msg.getExist()) && proto.ics23.ExistenceProof.toObject(includeInstance, f),
    nonexist: (f = msg.getNonexist()) && proto.ics23.NonExistenceProof.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.BatchEntry}
 */
proto.ics23.BatchEntry.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.BatchEntry;
  return proto.ics23.BatchEntry.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.BatchEntry} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.BatchEntry}
 */
proto.ics23.BatchEntry.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ics23.ExistenceProof;
      reader.readMessage(value,proto.ics23.ExistenceProof.deserializeBinaryFromReader);
      msg.setExist(value);
      break;
    case 2:
      var value = new proto.ics23.NonExistenceProof;
      reader.readMessage(value,proto.ics23.NonExistenceProof.deserializeBinaryFromReader);
      msg.setNonexist(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.BatchEntry.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.BatchEntry.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.BatchEntry} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.BatchEntry.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getExist();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ics23.ExistenceProof.serializeBinaryToWriter
    );
  }
  f = message.getNonexist();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ics23.NonExistenceProof.serializeBinaryToWriter
    );
  }
};


/**
 * optional ExistenceProof exist = 1;
 * @return {?proto.ics23.ExistenceProof}
 */
proto.ics23.BatchEntry.prototype.getExist = function() {
  return /** @type{?proto.ics23.ExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.ExistenceProof, 1));
};


/** @param {?proto.ics23.ExistenceProof|undefined} value */
proto.ics23.BatchEntry.prototype.setExist = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.ics23.BatchEntry.oneofGroups_[0], value);
};


proto.ics23.BatchEntry.prototype.clearExist = function() {
  this.setExist(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.BatchEntry.prototype.hasExist = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional NonExistenceProof nonexist = 2;
 * @return {?proto.ics23.NonExistenceProof}
 */
proto.ics23.BatchEntry.prototype.getNonexist = function() {
  return /** @type{?proto.ics23.NonExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.NonExistenceProof, 2));
};


/** @param {?proto.ics23.NonExistenceProof|undefined} value */
proto.ics23.BatchEntry.prototype.setNonexist = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.ics23.BatchEntry.oneofGroups_[0], value);
};


proto.ics23.BatchEntry.prototype.clearNonexist = function() {
  this.setNonexist(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.BatchEntry.prototype.hasNonexist = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.CompressedBatchProof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ics23.CompressedBatchProof.repeatedFields_, null);
};
goog.inherits(proto.ics23.CompressedBatchProof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.CompressedBatchProof.displayName = 'proto.ics23.CompressedBatchProof';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ics23.CompressedBatchProof.repeatedFields_ = [1,2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.CompressedBatchProof.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.CompressedBatchProof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.CompressedBatchProof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedBatchProof.toObject = function(includeInstance, msg) {
  var f, obj = {
    entriesList: jspb.Message.toObjectList(msg.getEntriesList(),
    proto.ics23.CompressedBatchEntry.toObject, includeInstance),
    lookupInnersList: jspb.Message.toObjectList(msg.getLookupInnersList(),
    proto.ics23.InnerOp.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.CompressedBatchProof}
 */
proto.ics23.CompressedBatchProof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.CompressedBatchProof;
  return proto.ics23.CompressedBatchProof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.CompressedBatchProof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.CompressedBatchProof}
 */
proto.ics23.CompressedBatchProof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ics23.CompressedBatchEntry;
      reader.readMessage(value,proto.ics23.CompressedBatchEntry.deserializeBinaryFromReader);
      msg.addEntries(value);
      break;
    case 2:
      var value = new proto.ics23.InnerOp;
      reader.readMessage(value,proto.ics23.InnerOp.deserializeBinaryFromReader);
      msg.addLookupInners(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.CompressedBatchProof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.CompressedBatchProof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.CompressedBatchProof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedBatchProof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEntriesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.ics23.CompressedBatchEntry.serializeBinaryToWriter
    );
  }
  f = message.getLookupInnersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.ics23.InnerOp.serializeBinaryToWriter
    );
  }
};


/**
 * repeated CompressedBatchEntry entries = 1;
 * @return {!Array<!proto.ics23.CompressedBatchEntry>}
 */
proto.ics23.CompressedBatchProof.prototype.getEntriesList = function() {
  return /** @type{!Array<!proto.ics23.CompressedBatchEntry>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ics23.CompressedBatchEntry, 1));
};


/** @param {!Array<!proto.ics23.CompressedBatchEntry>} value */
proto.ics23.CompressedBatchProof.prototype.setEntriesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.ics23.CompressedBatchEntry=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ics23.CompressedBatchEntry}
 */
proto.ics23.CompressedBatchProof.prototype.addEntries = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.ics23.CompressedBatchEntry, opt_index);
};


proto.ics23.CompressedBatchProof.prototype.clearEntriesList = function() {
  this.setEntriesList([]);
};


/**
 * repeated InnerOp lookup_inners = 2;
 * @return {!Array<!proto.ics23.InnerOp>}
 */
proto.ics23.CompressedBatchProof.prototype.getLookupInnersList = function() {
  return /** @type{!Array<!proto.ics23.InnerOp>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.ics23.InnerOp, 2));
};


/** @param {!Array<!proto.ics23.InnerOp>} value */
proto.ics23.CompressedBatchProof.prototype.setLookupInnersList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.ics23.InnerOp=} opt_value
 * @param {number=} opt_index
 * @return {!proto.ics23.InnerOp}
 */
proto.ics23.CompressedBatchProof.prototype.addLookupInners = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.ics23.InnerOp, opt_index);
};


proto.ics23.CompressedBatchProof.prototype.clearLookupInnersList = function() {
  this.setLookupInnersList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.CompressedBatchEntry = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.ics23.CompressedBatchEntry.oneofGroups_);
};
goog.inherits(proto.ics23.CompressedBatchEntry, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.CompressedBatchEntry.displayName = 'proto.ics23.CompressedBatchEntry';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.ics23.CompressedBatchEntry.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.ics23.CompressedBatchEntry.ProofCase = {
  PROOF_NOT_SET: 0,
  EXIST: 1,
  NONEXIST: 2
};

/**
 * @return {proto.ics23.CompressedBatchEntry.ProofCase}
 */
proto.ics23.CompressedBatchEntry.prototype.getProofCase = function() {
  return /** @type {proto.ics23.CompressedBatchEntry.ProofCase} */(jspb.Message.computeOneofCase(this, proto.ics23.CompressedBatchEntry.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.CompressedBatchEntry.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.CompressedBatchEntry.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.CompressedBatchEntry} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedBatchEntry.toObject = function(includeInstance, msg) {
  var f, obj = {
    exist: (f = msg.getExist()) && proto.ics23.CompressedExistenceProof.toObject(includeInstance, f),
    nonexist: (f = msg.getNonexist()) && proto.ics23.CompressedNonExistenceProof.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.CompressedBatchEntry}
 */
proto.ics23.CompressedBatchEntry.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.CompressedBatchEntry;
  return proto.ics23.CompressedBatchEntry.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.CompressedBatchEntry} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.CompressedBatchEntry}
 */
proto.ics23.CompressedBatchEntry.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ics23.CompressedExistenceProof;
      reader.readMessage(value,proto.ics23.CompressedExistenceProof.deserializeBinaryFromReader);
      msg.setExist(value);
      break;
    case 2:
      var value = new proto.ics23.CompressedNonExistenceProof;
      reader.readMessage(value,proto.ics23.CompressedNonExistenceProof.deserializeBinaryFromReader);
      msg.setNonexist(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.CompressedBatchEntry.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.CompressedBatchEntry.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.CompressedBatchEntry} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedBatchEntry.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getExist();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ics23.CompressedExistenceProof.serializeBinaryToWriter
    );
  }
  f = message.getNonexist();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ics23.CompressedNonExistenceProof.serializeBinaryToWriter
    );
  }
};


/**
 * optional CompressedExistenceProof exist = 1;
 * @return {?proto.ics23.CompressedExistenceProof}
 */
proto.ics23.CompressedBatchEntry.prototype.getExist = function() {
  return /** @type{?proto.ics23.CompressedExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.CompressedExistenceProof, 1));
};


/** @param {?proto.ics23.CompressedExistenceProof|undefined} value */
proto.ics23.CompressedBatchEntry.prototype.setExist = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.ics23.CompressedBatchEntry.oneofGroups_[0], value);
};


proto.ics23.CompressedBatchEntry.prototype.clearExist = function() {
  this.setExist(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CompressedBatchEntry.prototype.hasExist = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional CompressedNonExistenceProof nonexist = 2;
 * @return {?proto.ics23.CompressedNonExistenceProof}
 */
proto.ics23.CompressedBatchEntry.prototype.getNonexist = function() {
  return /** @type{?proto.ics23.CompressedNonExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.CompressedNonExistenceProof, 2));
};


/** @param {?proto.ics23.CompressedNonExistenceProof|undefined} value */
proto.ics23.CompressedBatchEntry.prototype.setNonexist = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.ics23.CompressedBatchEntry.oneofGroups_[0], value);
};


proto.ics23.CompressedBatchEntry.prototype.clearNonexist = function() {
  this.setNonexist(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CompressedBatchEntry.prototype.hasNonexist = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.CompressedExistenceProof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ics23.CompressedExistenceProof.repeatedFields_, null);
};
goog.inherits(proto.ics23.CompressedExistenceProof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.CompressedExistenceProof.displayName = 'proto.ics23.CompressedExistenceProof';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ics23.CompressedExistenceProof.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.CompressedExistenceProof.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.CompressedExistenceProof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.CompressedExistenceProof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedExistenceProof.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: msg.getKey_asB64(),
    value: msg.getValue_asB64(),
    leaf: (f = msg.getLeaf()) && proto.ics23.LeafOp.toObject(includeInstance, f),
    pathList: jspb.Message.getRepeatedField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.CompressedExistenceProof}
 */
proto.ics23.CompressedExistenceProof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.CompressedExistenceProof;
  return proto.ics23.CompressedExistenceProof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.CompressedExistenceProof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.CompressedExistenceProof}
 */
proto.ics23.CompressedExistenceProof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setKey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    case 3:
      var value = new proto.ics23.LeafOp;
      reader.readMessage(value,proto.ics23.LeafOp.deserializeBinaryFromReader);
      msg.setLeaf(value);
      break;
    case 4:
      var value = /** @type {!Array<number>} */ (reader.readPackedInt32());
      msg.setPathList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.CompressedExistenceProof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.CompressedExistenceProof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.CompressedExistenceProof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedExistenceProof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getValue_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getLeaf();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ics23.LeafOp.serializeBinaryToWriter
    );
  }
  f = message.getPathList();
  if (f.length > 0) {
    writer.writePackedInt32(
      4,
      f
    );
  }
};


/**
 * optional bytes key = 1;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.CompressedExistenceProof.prototype.getKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes key = 1;
 * This is a type-conversion wrapper around `getKey()`
 * @return {string}
 */
proto.ics23.CompressedExistenceProof.prototype.getKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getKey()));
};


/**
 * optional bytes key = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getKey()`
 * @return {!Uint8Array}
 */
proto.ics23.CompressedExistenceProof.prototype.getKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.CompressedExistenceProof.prototype.setKey = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes value = 2;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.CompressedExistenceProof.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes value = 2;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.ics23.CompressedExistenceProof.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.ics23.CompressedExistenceProof.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.CompressedExistenceProof.prototype.setValue = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional LeafOp leaf = 3;
 * @return {?proto.ics23.LeafOp}
 */
proto.ics23.CompressedExistenceProof.prototype.getLeaf = function() {
  return /** @type{?proto.ics23.LeafOp} */ (
    jspb.Message.getWrapperField(this, proto.ics23.LeafOp, 3));
};


/** @param {?proto.ics23.LeafOp|undefined} value */
proto.ics23.CompressedExistenceProof.prototype.setLeaf = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.ics23.CompressedExistenceProof.prototype.clearLeaf = function() {
  this.setLeaf(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CompressedExistenceProof.prototype.hasLeaf = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated int32 path = 4;
 * @return {!Array<number>}
 */
proto.ics23.CompressedExistenceProof.prototype.getPathList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 4));
};


/** @param {!Array<number>} value */
proto.ics23.CompressedExistenceProof.prototype.setPathList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.ics23.CompressedExistenceProof.prototype.addPath = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


proto.ics23.CompressedExistenceProof.prototype.clearPathList = function() {
  this.setPathList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ics23.CompressedNonExistenceProof = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ics23.CompressedNonExistenceProof, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ics23.CompressedNonExistenceProof.displayName = 'proto.ics23.CompressedNonExistenceProof';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ics23.CompressedNonExistenceProof.prototype.toObject = function(opt_includeInstance) {
  return proto.ics23.CompressedNonExistenceProof.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ics23.CompressedNonExistenceProof} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedNonExistenceProof.toObject = function(includeInstance, msg) {
  var f, obj = {
    key: msg.getKey_asB64(),
    left: (f = msg.getLeft()) && proto.ics23.CompressedExistenceProof.toObject(includeInstance, f),
    right: (f = msg.getRight()) && proto.ics23.CompressedExistenceProof.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ics23.CompressedNonExistenceProof}
 */
proto.ics23.CompressedNonExistenceProof.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ics23.CompressedNonExistenceProof;
  return proto.ics23.CompressedNonExistenceProof.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ics23.CompressedNonExistenceProof} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ics23.CompressedNonExistenceProof}
 */
proto.ics23.CompressedNonExistenceProof.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setKey(value);
      break;
    case 2:
      var value = new proto.ics23.CompressedExistenceProof;
      reader.readMessage(value,proto.ics23.CompressedExistenceProof.deserializeBinaryFromReader);
      msg.setLeft(value);
      break;
    case 3:
      var value = new proto.ics23.CompressedExistenceProof;
      reader.readMessage(value,proto.ics23.CompressedExistenceProof.deserializeBinaryFromReader);
      msg.setRight(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ics23.CompressedNonExistenceProof.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ics23.CompressedNonExistenceProof.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ics23.CompressedNonExistenceProof} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ics23.CompressedNonExistenceProof.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getKey_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getLeft();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ics23.CompressedExistenceProof.serializeBinaryToWriter
    );
  }
  f = message.getRight();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.ics23.CompressedExistenceProof.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes key = 1;
 * @return {!(string|Uint8Array)}
 */
proto.ics23.CompressedNonExistenceProof.prototype.getKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes key = 1;
 * This is a type-conversion wrapper around `getKey()`
 * @return {string}
 */
proto.ics23.CompressedNonExistenceProof.prototype.getKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getKey()));
};


/**
 * optional bytes key = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getKey()`
 * @return {!Uint8Array}
 */
proto.ics23.CompressedNonExistenceProof.prototype.getKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.ics23.CompressedNonExistenceProof.prototype.setKey = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional CompressedExistenceProof left = 2;
 * @return {?proto.ics23.CompressedExistenceProof}
 */
proto.ics23.CompressedNonExistenceProof.prototype.getLeft = function() {
  return /** @type{?proto.ics23.CompressedExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.CompressedExistenceProof, 2));
};


/** @param {?proto.ics23.CompressedExistenceProof|undefined} value */
proto.ics23.CompressedNonExistenceProof.prototype.setLeft = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.ics23.CompressedNonExistenceProof.prototype.clearLeft = function() {
  this.setLeft(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CompressedNonExistenceProof.prototype.hasLeft = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional CompressedExistenceProof right = 3;
 * @return {?proto.ics23.CompressedExistenceProof}
 */
proto.ics23.CompressedNonExistenceProof.prototype.getRight = function() {
  return /** @type{?proto.ics23.CompressedExistenceProof} */ (
    jspb.Message.getWrapperField(this, proto.ics23.CompressedExistenceProof, 3));
};


/** @param {?proto.ics23.CompressedExistenceProof|undefined} value */
proto.ics23.CompressedNonExistenceProof.prototype.setRight = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.ics23.CompressedNonExistenceProof.prototype.clearRight = function() {
  this.setRight(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ics23.CompressedNonExistenceProof.prototype.hasRight = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * @enum {number}
 */
proto.ics23.HashOp = {
  NO_HASH: 0,
  SHA256: 1,
  SHA512: 2,
  KECCAK: 3,
  RIPEMD160: 4,
  BITCOIN: 5
};

/**
 * @enum {number}
 */
proto.ics23.LengthOp = {
  NO_PREFIX: 0,
  VAR_PROTO: 1,
  VAR_RLP: 2,
  FIXED32_BIG: 3,
  FIXED32_LITTLE: 4,
  FIXED64_BIG: 5,
  FIXED64_LITTLE: 6,
  REQUIRE_32_BYTES: 7,
  REQUIRE_64_BYTES: 8
};

goog.object.extend(exports, proto.ics23);
