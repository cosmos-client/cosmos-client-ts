/* tslint:disable */
/* eslint-disable */
/**
 * Cosmos SDK - gRPC Gateway docs
 * A REST interface for state queries
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.  Note: This type is a duplicate of the ResponseQuery proto type defined in Tendermint.
 * @export
 * @interface ABCIQuery200Response
 */
export interface ABCIQuery200Response {
    /**
     * 
     * @type {number}
     * @memberof ABCIQuery200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200Response
     */
    'log'?: string;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200Response
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200Response
     */
    'index'?: string;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200Response
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200Response
     */
    'value'?: string;
    /**
     * 
     * @type {ABCIQuery200ResponseProofOps}
     * @memberof ABCIQuery200Response
     */
    'proof_ops'?: ABCIQuery200ResponseProofOps;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200Response
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200Response
     */
    'codespace'?: string;
}
/**
 * ProofOps is Merkle proof defined by the list of ProofOps.  Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
 * @export
 * @interface ABCIQuery200ResponseProofOps
 */
export interface ABCIQuery200ResponseProofOps {
    /**
     * 
     * @type {Array<ABCIQuery200ResponseProofOpsOpsInner>}
     * @memberof ABCIQuery200ResponseProofOps
     */
    'ops'?: Array<ABCIQuery200ResponseProofOpsOpsInner>;
}
/**
 * ProofOp defines an operation used for calculating Merkle root. The data could be arbitrary format, providing nessecary data for example neighbouring node hash.  Note: This type is a duplicate of the ProofOp proto type defined in Tendermint.
 * @export
 * @interface ABCIQuery200ResponseProofOpsOpsInner
 */
export interface ABCIQuery200ResponseProofOpsOpsInner {
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200ResponseProofOpsOpsInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200ResponseProofOpsOpsInner
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ABCIQuery200ResponseProofOpsOpsInner
     */
    'data'?: string;
}
/**
 * QueryAccountResponse is the response type for the Query/Account RPC method.
 * @export
 * @interface Account200Response
 */
export interface Account200Response {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof Account200Response
     */
    'account'?: AccountsAreTheExistingAccountsInner;
}
/**
 * QueryAccountsResponse is the response type for the Query/Accounts RPC method.  Since: cosmos-sdk 0.43
 * @export
 * @interface Accounts200Response
 */
export interface Accounts200Response {
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof Accounts200Response
     */
    'accounts'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof Accounts200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * pagination defines the pagination in the response.
 * @export
 * @interface Accounts200ResponsePagination
 */
export interface Accounts200ResponsePagination {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof Accounts200ResponsePagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Accounts200ResponsePagination
     */
    'total'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface AccountsAreTheExistingAccountsInner
 */
export interface AccountsAreTheExistingAccountsInner {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof AccountsAreTheExistingAccountsInner
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof AccountsAreTheExistingAccountsInner
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface AccountsDefaultResponse
 */
export interface AccountsDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountsDefaultResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountsDefaultResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountsDefaultResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof AccountsDefaultResponse
     */
    'details'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * AddressBytesToStringResponse is the response type for AddressString rpc method.  Since: cosmos-sdk 0.46
 * @export
 * @interface AddressBytesToString200Response
 */
export interface AddressBytesToString200Response {
    /**
     * 
     * @type {string}
     * @memberof AddressBytesToString200Response
     */
    'address_string'?: string;
}
/**
 * AddressStringToBytesResponse is the response type for AddressBytes rpc method.  Since: cosmos-sdk 0.46
 * @export
 * @interface AddressStringToBytes200Response
 */
export interface AddressStringToBytes200Response {
    /**
     * 
     * @type {string}
     * @memberof AddressStringToBytes200Response
     */
    'address_bytes'?: string;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC method.
 * @export
 * @interface AllBalances200Response
 */
export interface AllBalances200Response {
    /**
     * balances is the balances of all the coins.
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof AllBalances200Response
     */
    'balances'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof AllBalances200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface AllBalances200ResponseBalancesInner
 */
export interface AllBalances200ResponseBalancesInner {
    /**
     * 
     * @type {string}
     * @memberof AllBalances200ResponseBalancesInner
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllBalances200ResponseBalancesInner
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface AllBalancesDefaultResponse
 */
export interface AllBalancesDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof AllBalancesDefaultResponse
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof AllBalancesDefaultResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof AllBalancesDefaultResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<AllBalancesDefaultResponseDetailsInner>}
     * @memberof AllBalancesDefaultResponse
     */
    'details'?: Array<AllBalancesDefaultResponseDetailsInner>;
}
/**
 * 
 * @export
 * @interface AllBalancesDefaultResponseDetailsInner
 */
export interface AllBalancesDefaultResponseDetailsInner {
    /**
     * 
     * @type {string}
     * @memberof AllBalancesDefaultResponseDetailsInner
     */
    'type_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllBalancesDefaultResponseDetailsInner
     */
    'value'?: string;
}
/**
 * QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC method.
 * @export
 * @interface AllEvidence200Response
 */
export interface AllEvidence200Response {
    /**
     * evidence returns all evidences.
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof AllEvidence200Response
     */
    'evidence'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof AllEvidence200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryAllowanceResponse is the response type for the Query/Allowance RPC method.
 * @export
 * @interface Allowance200Response
 */
export interface Allowance200Response {
    /**
     * 
     * @type {GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext}
     * @memberof Allowance200Response
     */
    'allowance'?: GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext;
}
/**
 * QueryAllowancesResponse is the response type for the Query/Allowances RPC method.
 * @export
 * @interface Allowances200Response
 */
export interface Allowances200Response {
    /**
     * allowances are allowance\'s granted for grantee by granter.
     * @type {Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>}
     * @memberof Allowances200Response
     */
    'allowances'?: Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof Allowances200Response
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.  Since: cosmos-sdk 0.46
 * @export
 * @interface AllowancesByGranter200Response
 */
export interface AllowancesByGranter200Response {
    /**
     * allowances that have been issued by the granter.
     * @type {Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>}
     * @memberof AllowancesByGranter200Response
     */
    'allowances'?: Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof AllowancesByGranter200Response
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * QueryAnnualProvisionsResponse is the response type for the Query/AnnualProvisions RPC method.
 * @export
 * @interface AnnualProvisions200Response
 */
export interface AnnualProvisions200Response {
    /**
     * annual_provisions is the current minting annual provisions value.
     * @type {string}
     * @memberof AnnualProvisions200Response
     */
    'annual_provisions'?: string;
}
/**
 * QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC method.
 * @export
 * @interface AppliedPlan200Response
 */
export interface AppliedPlan200Response {
    /**
     * height is the block height at which the plan was applied.
     * @type {string}
     * @memberof AppliedPlan200Response
     */
    'height'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface AuthParams200Response
 */
export interface AuthParams200Response {
    /**
     * 
     * @type {AuthParams200ResponseParams}
     * @memberof AuthParams200Response
     */
    'params'?: AuthParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface AuthParams200ResponseParams
 */
export interface AuthParams200ResponseParams {
    /**
     * 
     * @type {string}
     * @memberof AuthParams200ResponseParams
     */
    'max_memo_characters'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthParams200ResponseParams
     */
    'tx_sig_limit'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthParams200ResponseParams
     */
    'tx_size_cost_per_byte'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthParams200ResponseParams
     */
    'sig_verify_cost_ed25519'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthParams200ResponseParams
     */
    'sig_verify_cost_secp256k1'?: string;
}
/**
 * QueryBalanceResponse is the response type for the Query/Balance RPC method.
 * @export
 * @interface Balance200Response
 */
export interface Balance200Response {
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof Balance200Response
     */
    'balance'?: AllBalances200ResponseBalancesInner;
}
/**
 * QueryParamsResponse defines the response type for querying x/bank parameters.
 * @export
 * @interface BankParams200Response
 */
export interface BankParams200Response {
    /**
     * 
     * @type {BankParams200ResponseParams}
     * @memberof BankParams200Response
     */
    'params'?: BankParams200ResponseParams;
}
/**
 * Params defines the parameters for the bank module.
 * @export
 * @interface BankParams200ResponseParams
 */
export interface BankParams200ResponseParams {
    /**
     * 
     * @type {Array<BankParams200ResponseParamsSendEnabledInner>}
     * @memberof BankParams200ResponseParams
     */
    'send_enabled'?: Array<BankParams200ResponseParamsSendEnabledInner>;
    /**
     * 
     * @type {boolean}
     * @memberof BankParams200ResponseParams
     */
    'default_send_enabled'?: boolean;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable).
 * @export
 * @interface BankParams200ResponseParamsSendEnabledInner
 */
export interface BankParams200ResponseParamsSendEnabledInner {
    /**
     * 
     * @type {string}
     * @memberof BankParams200ResponseParamsSendEnabledInner
     */
    'denom'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BankParams200ResponseParamsSendEnabledInner
     */
    'enabled'?: boolean;
}
/**
 * Consensus captures the consensus rules for processing a block in the blockchain, including all blockchain data structures and the rules of the application\'s state transition machine.
 * @export
 * @interface BasicBlockInfo
 */
export interface BasicBlockInfo {
    /**
     * 
     * @type {string}
     * @memberof BasicBlockInfo
     */
    'block'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlockInfo
     */
    'app'?: string;
}
/**
 * Bech32PrefixResponse is the response type for Bech32Prefix rpc method.  Since: cosmos-sdk 0.46
 * @export
 * @interface Bech32Prefix200Response
 */
export interface Bech32Prefix200Response {
    /**
     * 
     * @type {string}
     * @memberof Bech32Prefix200Response
     */
    'bech32_prefix'?: string;
}
/**
 * CompactBitArray is an implementation of a space efficient bit array. This is used to ensure that the encoded data takes up a minimal amount of space after proto encoding. This is not thread safe, and is not intended for concurrent usage.
 * @export
 * @interface BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning
 */
export interface BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning {
    /**
     * 
     * @type {number}
     * @memberof BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning
     */
    'extra_bits_stored'?: number;
    /**
     * 
     * @type {string}
     * @memberof BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning
     */
    'elems'?: string;
}
/**
 * 
 * @export
 * @interface BlockID
 */
export interface BlockID {
    /**
     * 
     * @type {string}
     * @memberof BlockID
     */
    'hash'?: string;
    /**
     * 
     * @type {PartsetHeader}
     * @memberof BlockID
     */
    'part_set_header'?: PartsetHeader;
}
/**
 * TxBody is the body of a transaction that all signers sign over.
 * @export
 * @interface BodyIsTheProcessableContentOfTheTransaction
 */
export interface BodyIsTheProcessableContentOfTheTransaction {
    /**
     * messages is a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo\'s signer_infos and Tx\'s signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    'messages'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * memo is any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
     * @type {string}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    'timeout_height'?: string;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    'extension_options'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof BodyIsTheProcessableContentOfTheTransaction
     */
    'non_critical_extension_options'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * BroadcastTxResponse is the response type for the Service.BroadcastTx method.
 * @export
 * @interface BroadcastTx200Response
 */
export interface BroadcastTx200Response {
    /**
     * 
     * @type {BroadcastTx200ResponseTxResponse}
     * @memberof BroadcastTx200Response
     */
    'tx_response'?: BroadcastTx200ResponseTxResponse;
}
/**
 * TxResponse defines a structure containing relevant tx data and metadata. The tags are stringified and the log is JSON decoded.
 * @export
 * @interface BroadcastTx200ResponseTxResponse
 */
export interface BroadcastTx200ResponseTxResponse {
    /**
     * 
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'height'?: string;
    /**
     * The transaction hash.
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'txhash'?: string;
    /**
     * 
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'codespace'?: string;
    /**
     * Response code.
     * @type {number}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'code'?: number;
    /**
     * Result bytes, if any.
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'data'?: string;
    /**
     * The output of the application\'s logger (raw string). May be non-deterministic.
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'raw_log'?: string;
    /**
     * The output of the application\'s logger (typed). May be non-deterministic.
     * @type {Array<BroadcastTx200ResponseTxResponseLogsInner>}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'logs'?: Array<BroadcastTx200ResponseTxResponseLogsInner>;
    /**
     * Additional information. May be non-deterministic.
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'info'?: string;
    /**
     * Amount of gas requested for transaction.
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'gas_wanted'?: string;
    /**
     * Amount of gas consumed by transaction.
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'gas_used'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'tx'?: AccountsAreTheExistingAccountsInner;
    /**
     * Time of the previous block. For heights > 1, it\'s the weighted median of the timestamps of the valid votes in the block.LastCommit. For height == 1, it\'s genesis time.
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'timestamp'?: string;
    /**
     * Events defines all the events emitted by processing a transaction. Note, these events include those emitted by processing all the messages and those emitted from the ante. Whereas Logs contains the events, with additional metadata, emitted only by processing the messages.  Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
     * @type {Array<Simulate200ResponseResultEventsInner>}
     * @memberof BroadcastTx200ResponseTxResponse
     */
    'events'?: Array<Simulate200ResponseResultEventsInner>;
}
/**
 * ABCIMessageLog defines a structure containing an indexed tx ABCI message log.
 * @export
 * @interface BroadcastTx200ResponseTxResponseLogsInner
 */
export interface BroadcastTx200ResponseTxResponseLogsInner {
    /**
     * 
     * @type {number}
     * @memberof BroadcastTx200ResponseTxResponseLogsInner
     */
    'msg_index'?: number;
    /**
     * 
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponseLogsInner
     */
    'log'?: string;
    /**
     * Events contains a slice of Event objects that were emitted during some execution.
     * @type {Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInner>}
     * @memberof BroadcastTx200ResponseTxResponseLogsInner
     */
    'events'?: Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInner>;
}
/**
 * StringEvent defines en Event object wrapper where all the attributes contain key/value pairs that are strings instead of raw bytes.
 * @export
 * @interface BroadcastTx200ResponseTxResponseLogsInnerEventsInner
 */
export interface BroadcastTx200ResponseTxResponseLogsInnerEventsInner {
    /**
     * 
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponseLogsInnerEventsInner
     */
    'type'?: string;
    /**
     * 
     * @type {Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner>}
     * @memberof BroadcastTx200ResponseTxResponseLogsInnerEventsInner
     */
    'attributes'?: Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner>;
}
/**
 * Attribute defines an attribute wrapper where the key and value are strings instead of raw bytes.
 * @export
 * @interface BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner
 */
export interface BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner {
    /**
     * 
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner
     */
    'value'?: string;
}
/**
 * BroadcastTxRequest is the request type for the Service.BroadcastTxRequest RPC method.
 * @export
 * @interface BroadcastTxRequest
 */
export interface BroadcastTxRequest {
    /**
     * tx_bytes is the raw transaction.
     * @type {string}
     * @memberof BroadcastTxRequest
     */
    'tx_bytes'?: string;
    /**
     * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
     * @type {string}
     * @memberof BroadcastTxRequest
     */
    'mode'?: BroadcastTxRequestModeEnum;
}

export const BroadcastTxRequestModeEnum = {
    Unspecified: 'BROADCAST_MODE_UNSPECIFIED',
    Block: 'BROADCAST_MODE_BLOCK',
    Sync: 'BROADCAST_MODE_SYNC',
    Async: 'BROADCAST_MODE_ASYNC'
} as const;

export type BroadcastTxRequestModeEnum = typeof BroadcastTxRequestModeEnum[keyof typeof BroadcastTxRequestModeEnum];

/**
 * QueryCommunityPoolResponse is the response type for the Query/CommunityPool RPC method.
 * @export
 * @interface CommunityPool200Response
 */
export interface CommunityPool200Response {
    /**
     * pool defines community pool\'s coins.
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof CommunityPool200Response
     */
    'pool'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * DecCoin defines a token with a denomination and a decimal amount.  NOTE: The amount field is an Dec which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CommunityPool200ResponsePoolInner
 */
export interface CommunityPool200ResponsePoolInner {
    /**
     * 
     * @type {string}
     * @memberof CommunityPool200ResponsePoolInner
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommunityPool200ResponsePoolInner
     */
    'amount'?: string;
}
/**
 * AddressBytesToStringResponse is the response type for AddressString rpc method.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosAuthV1beta1AddressBytesToStringResponse
 */
export interface CosmosAuthV1beta1AddressBytesToStringResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1AddressBytesToStringResponse
     */
    'address_string'?: string;
}
/**
 * AddressStringToBytesResponse is the response type for AddressBytes rpc method.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosAuthV1beta1AddressStringToBytesResponse
 */
export interface CosmosAuthV1beta1AddressStringToBytesResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1AddressStringToBytesResponse
     */
    'address_bytes'?: string;
}
/**
 * Bech32PrefixResponse is the response type for Bech32Prefix rpc method.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosAuthV1beta1Bech32PrefixResponse
 */
export interface CosmosAuthV1beta1Bech32PrefixResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Bech32PrefixResponse
     */
    'bech32_prefix'?: string;
}
/**
 * Params defines the parameters for the auth module.
 * @export
 * @interface CosmosAuthV1beta1Params
 */
export interface CosmosAuthV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    'max_memo_characters'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    'tx_sig_limit'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    'tx_size_cost_per_byte'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    'sig_verify_cost_ed25519'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1Params
     */
    'sig_verify_cost_secp256k1'?: string;
}
/**
 * Since: cosmos-sdk 0.46.2
 * @export
 * @interface CosmosAuthV1beta1QueryAccountAddressByIDResponse
 */
export interface CosmosAuthV1beta1QueryAccountAddressByIDResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthV1beta1QueryAccountAddressByIDResponse
     */
    'account_address'?: string;
}
/**
 * QueryAccountResponse is the response type for the Query/Account RPC method.
 * @export
 * @interface CosmosAuthV1beta1QueryAccountResponse
 */
export interface CosmosAuthV1beta1QueryAccountResponse {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosAuthV1beta1QueryAccountResponse
     */
    'account'?: AccountsAreTheExistingAccountsInner;
}
/**
 * QueryAccountsResponse is the response type for the Query/Accounts RPC method.  Since: cosmos-sdk 0.43
 * @export
 * @interface CosmosAuthV1beta1QueryAccountsResponse
 */
export interface CosmosAuthV1beta1QueryAccountsResponse {
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosAuthV1beta1QueryAccountsResponse
     */
    'accounts'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosAuthV1beta1QueryAccountsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method.
 * @export
 * @interface CosmosAuthV1beta1QueryModuleAccountByNameResponse
 */
export interface CosmosAuthV1beta1QueryModuleAccountByNameResponse {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosAuthV1beta1QueryModuleAccountByNameResponse
     */
    'account'?: AccountsAreTheExistingAccountsInner;
}
/**
 * QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosAuthV1beta1QueryModuleAccountsResponse
 */
export interface CosmosAuthV1beta1QueryModuleAccountsResponse {
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosAuthV1beta1QueryModuleAccountsResponse
     */
    'accounts'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosAuthV1beta1QueryParamsResponse
 */
export interface CosmosAuthV1beta1QueryParamsResponse {
    /**
     * 
     * @type {AuthParams200ResponseParams}
     * @memberof CosmosAuthV1beta1QueryParamsResponse
     */
    'params'?: AuthParams200ResponseParams;
}
/**
 * Grant gives permissions to execute the provide method with expiration time.
 * @export
 * @interface CosmosAuthzV1beta1Grant
 */
export interface CosmosAuthzV1beta1Grant {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosAuthzV1beta1Grant
     */
    'authorization'?: AccountsAreTheExistingAccountsInner;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthzV1beta1Grant
     */
    'expiration'?: string;
}
/**
 * 
 * @export
 * @interface CosmosAuthzV1beta1GrantAuthorization
 */
export interface CosmosAuthzV1beta1GrantAuthorization {
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthzV1beta1GrantAuthorization
     */
    'granter'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthzV1beta1GrantAuthorization
     */
    'grantee'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosAuthzV1beta1GrantAuthorization
     */
    'authorization'?: AccountsAreTheExistingAccountsInner;
    /**
     * 
     * @type {string}
     * @memberof CosmosAuthzV1beta1GrantAuthorization
     */
    'expiration'?: string;
}
/**
 * QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method.
 * @export
 * @interface CosmosAuthzV1beta1QueryGranteeGrantsResponse
 */
export interface CosmosAuthzV1beta1QueryGranteeGrantsResponse {
    /**
     * grants is a list of grants granted to the grantee.
     * @type {Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>}
     * @memberof CosmosAuthzV1beta1QueryGranteeGrantsResponse
     */
    'grants'?: Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof CosmosAuthzV1beta1QueryGranteeGrantsResponse
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method.
 * @export
 * @interface CosmosAuthzV1beta1QueryGranterGrantsResponse
 */
export interface CosmosAuthzV1beta1QueryGranterGrantsResponse {
    /**
     * grants is a list of grants granted by the granter.
     * @type {Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>}
     * @memberof CosmosAuthzV1beta1QueryGranterGrantsResponse
     */
    'grants'?: Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof CosmosAuthzV1beta1QueryGranterGrantsResponse
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * QueryGrantsResponse is the response type for the Query/Authorizations RPC method.
 * @export
 * @interface CosmosAuthzV1beta1QueryGrantsResponse
 */
export interface CosmosAuthzV1beta1QueryGrantsResponse {
    /**
     * authorizations is a list of grants granted for grantee by granter.
     * @type {Array<Grants200ResponseGrantsInner>}
     * @memberof CosmosAuthzV1beta1QueryGrantsResponse
     */
    'grants'?: Array<Grants200ResponseGrantsInner>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof CosmosAuthzV1beta1QueryGrantsResponse
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * DenomOwner defines structure representing an account that owns or holds a particular denominated token. It contains the account address and account balance of the denominated token.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosBankV1beta1DenomOwner
 */
export interface CosmosBankV1beta1DenomOwner {
    /**
     * address defines the address that owns a particular denomination.
     * @type {string}
     * @memberof CosmosBankV1beta1DenomOwner
     */
    'address'?: string;
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof CosmosBankV1beta1DenomOwner
     */
    'balance'?: AllBalances200ResponseBalancesInner;
}
/**
 * DenomUnit represents a struct that describes a given denomination unit of the basic token.
 * @export
 * @interface CosmosBankV1beta1DenomUnit
 */
export interface CosmosBankV1beta1DenomUnit {
    /**
     * denom represents the string name of the given denom unit (e.g uatom).
     * @type {string}
     * @memberof CosmosBankV1beta1DenomUnit
     */
    'denom'?: string;
    /**
     * exponent represents power of 10 exponent that one must raise the base_denom to in order to equal the given DenomUnit\'s denom 1 denom = 10^exponent base_denom (e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with exponent = 6, thus: 1 atom = 10^6 uatom).
     * @type {number}
     * @memberof CosmosBankV1beta1DenomUnit
     */
    'exponent'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CosmosBankV1beta1DenomUnit
     */
    'aliases'?: Array<string>;
}
/**
 * Metadata represents a struct that describes a basic token.
 * @export
 * @interface CosmosBankV1beta1Metadata
 */
export interface CosmosBankV1beta1Metadata {
    /**
     * 
     * @type {string}
     * @memberof CosmosBankV1beta1Metadata
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner>}
     * @memberof CosmosBankV1beta1Metadata
     */
    'denom_units'?: Array<DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner>;
    /**
     * base represents the base denom (should be the DenomUnit with exponent = 0).
     * @type {string}
     * @memberof CosmosBankV1beta1Metadata
     */
    'base'?: string;
    /**
     * display indicates the suggested denom that should be displayed in clients.
     * @type {string}
     * @memberof CosmosBankV1beta1Metadata
     */
    'display'?: string;
    /**
     * Since: cosmos-sdk 0.43
     * @type {string}
     * @memberof CosmosBankV1beta1Metadata
     */
    'name'?: string;
    /**
     * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can be the same as the display.  Since: cosmos-sdk 0.43
     * @type {string}
     * @memberof CosmosBankV1beta1Metadata
     */
    'symbol'?: string;
    /**
     * URI to a document (on or off-chain) that contains additional information. Optional.  Since: cosmos-sdk 0.46
     * @type {string}
     * @memberof CosmosBankV1beta1Metadata
     */
    'uri'?: string;
    /**
     * URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that the document didn\'t change. Optional.  Since: cosmos-sdk 0.46
     * @type {string}
     * @memberof CosmosBankV1beta1Metadata
     */
    'uri_hash'?: string;
}
/**
 * Params defines the parameters for the bank module.
 * @export
 * @interface CosmosBankV1beta1Params
 */
export interface CosmosBankV1beta1Params {
    /**
     * 
     * @type {Array<BankParams200ResponseParamsSendEnabledInner>}
     * @memberof CosmosBankV1beta1Params
     */
    'send_enabled'?: Array<BankParams200ResponseParamsSendEnabledInner>;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosBankV1beta1Params
     */
    'default_send_enabled'?: boolean;
}
/**
 * QueryAllBalancesResponse is the response type for the Query/AllBalances RPC method.
 * @export
 * @interface CosmosBankV1beta1QueryAllBalancesResponse
 */
export interface CosmosBankV1beta1QueryAllBalancesResponse {
    /**
     * balances is the balances of all the coins.
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosBankV1beta1QueryAllBalancesResponse
     */
    'balances'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosBankV1beta1QueryAllBalancesResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryBalanceResponse is the response type for the Query/Balance RPC method.
 * @export
 * @interface CosmosBankV1beta1QueryBalanceResponse
 */
export interface CosmosBankV1beta1QueryBalanceResponse {
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof CosmosBankV1beta1QueryBalanceResponse
     */
    'balance'?: AllBalances200ResponseBalancesInner;
}
/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC method.
 * @export
 * @interface CosmosBankV1beta1QueryDenomMetadataResponse
 */
export interface CosmosBankV1beta1QueryDenomMetadataResponse {
    /**
     * 
     * @type {DenomsMetadata200ResponseMetadatasInner}
     * @memberof CosmosBankV1beta1QueryDenomMetadataResponse
     */
    'metadata'?: DenomsMetadata200ResponseMetadatasInner;
}
/**
 * QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosBankV1beta1QueryDenomOwnersResponse
 */
export interface CosmosBankV1beta1QueryDenomOwnersResponse {
    /**
     * 
     * @type {Array<DenomOwners200ResponseDenomOwnersInner>}
     * @memberof CosmosBankV1beta1QueryDenomOwnersResponse
     */
    'denom_owners'?: Array<DenomOwners200ResponseDenomOwnersInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosBankV1beta1QueryDenomOwnersResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC method.
 * @export
 * @interface CosmosBankV1beta1QueryDenomsMetadataResponse
 */
export interface CosmosBankV1beta1QueryDenomsMetadataResponse {
    /**
     * metadata provides the client information for all the registered tokens.
     * @type {Array<DenomsMetadata200ResponseMetadatasInner>}
     * @memberof CosmosBankV1beta1QueryDenomsMetadataResponse
     */
    'metadatas'?: Array<DenomsMetadata200ResponseMetadatasInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosBankV1beta1QueryDenomsMetadataResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryParamsResponse defines the response type for querying x/bank parameters.
 * @export
 * @interface CosmosBankV1beta1QueryParamsResponse
 */
export interface CosmosBankV1beta1QueryParamsResponse {
    /**
     * 
     * @type {BankParams200ResponseParams}
     * @memberof CosmosBankV1beta1QueryParamsResponse
     */
    'params'?: BankParams200ResponseParams;
}
/**
 * QuerySpendableBalancesResponse defines the gRPC response structure for querying an account\'s spendable balances.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosBankV1beta1QuerySpendableBalancesResponse
 */
export interface CosmosBankV1beta1QuerySpendableBalancesResponse {
    /**
     * balances is the spendable balances of all the coins.
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosBankV1beta1QuerySpendableBalancesResponse
     */
    'balances'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosBankV1beta1QuerySpendableBalancesResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.
 * @export
 * @interface CosmosBankV1beta1QuerySupplyOfResponse
 */
export interface CosmosBankV1beta1QuerySupplyOfResponse {
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof CosmosBankV1beta1QuerySupplyOfResponse
     */
    'amount'?: AllBalances200ResponseBalancesInner;
}
/**
 * 
 * @export
 * @interface CosmosBankV1beta1QueryTotalSupplyResponse
 */
export interface CosmosBankV1beta1QueryTotalSupplyResponse {
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosBankV1beta1QueryTotalSupplyResponse
     */
    'supply'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination}
     * @memberof CosmosBankV1beta1QueryTotalSupplyResponse
     */
    'pagination'?: QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination;
}
/**
 * SendEnabled maps coin denom to a send_enabled status (whether a denom is sendable).
 * @export
 * @interface CosmosBankV1beta1SendEnabled
 */
export interface CosmosBankV1beta1SendEnabled {
    /**
     * 
     * @type {string}
     * @memberof CosmosBankV1beta1SendEnabled
     */
    'denom'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosBankV1beta1SendEnabled
     */
    'enabled'?: boolean;
}
/**
 * ABCIMessageLog defines a structure containing an indexed tx ABCI message log.
 * @export
 * @interface CosmosBaseAbciV1beta1ABCIMessageLog
 */
export interface CosmosBaseAbciV1beta1ABCIMessageLog {
    /**
     * 
     * @type {number}
     * @memberof CosmosBaseAbciV1beta1ABCIMessageLog
     */
    'msg_index'?: number;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1ABCIMessageLog
     */
    'log'?: string;
    /**
     * Events contains a slice of Event objects that were emitted during some execution.
     * @type {Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInner>}
     * @memberof CosmosBaseAbciV1beta1ABCIMessageLog
     */
    'events'?: Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInner>;
}
/**
 * Attribute defines an attribute wrapper where the key and value are strings instead of raw bytes.
 * @export
 * @interface CosmosBaseAbciV1beta1Attribute
 */
export interface CosmosBaseAbciV1beta1Attribute {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Attribute
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Attribute
     */
    'value'?: string;
}
/**
 * GasInfo defines tx execution gas context.
 * @export
 * @interface CosmosBaseAbciV1beta1GasInfo
 */
export interface CosmosBaseAbciV1beta1GasInfo {
    /**
     * GasWanted is the maximum units of work we allow this tx to perform.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1GasInfo
     */
    'gas_wanted'?: string;
    /**
     * GasUsed is the amount of gas actually consumed.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1GasInfo
     */
    'gas_used'?: string;
}
/**
 * Result is the union of ResponseFormat and ResponseCheckTx.
 * @export
 * @interface CosmosBaseAbciV1beta1Result
 */
export interface CosmosBaseAbciV1beta1Result {
    /**
     * Data is any data returned from message or handler execution. It MUST be length prefixed in order to separate data from multiple message executions. Deprecated. This field is still populated, but prefer msg_response instead because it also contains the Msg response typeURL.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Result
     */
    'data'?: string;
    /**
     * Log contains the log information from message or handler execution.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1Result
     */
    'log'?: string;
    /**
     * Events contains a slice of Event objects that were emitted during message or handler execution.
     * @type {Array<Simulate200ResponseResultEventsInner>}
     * @memberof CosmosBaseAbciV1beta1Result
     */
    'events'?: Array<Simulate200ResponseResultEventsInner>;
    /**
     * msg_responses contains the Msg handler responses type packed in Anys.  Since: cosmos-sdk 0.46
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosBaseAbciV1beta1Result
     */
    'msg_responses'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * StringEvent defines en Event object wrapper where all the attributes contain key/value pairs that are strings instead of raw bytes.
 * @export
 * @interface CosmosBaseAbciV1beta1StringEvent
 */
export interface CosmosBaseAbciV1beta1StringEvent {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1StringEvent
     */
    'type'?: string;
    /**
     * 
     * @type {Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner>}
     * @memberof CosmosBaseAbciV1beta1StringEvent
     */
    'attributes'?: Array<BroadcastTx200ResponseTxResponseLogsInnerEventsInnerAttributesInner>;
}
/**
 * TxResponse defines a structure containing relevant tx data and metadata. The tags are stringified and the log is JSON decoded.
 * @export
 * @interface CosmosBaseAbciV1beta1TxResponse
 */
export interface CosmosBaseAbciV1beta1TxResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'height'?: string;
    /**
     * The transaction hash.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'txhash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'codespace'?: string;
    /**
     * Response code.
     * @type {number}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'code'?: number;
    /**
     * Result bytes, if any.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'data'?: string;
    /**
     * The output of the application\'s logger (raw string). May be non-deterministic.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'raw_log'?: string;
    /**
     * The output of the application\'s logger (typed). May be non-deterministic.
     * @type {Array<BroadcastTx200ResponseTxResponseLogsInner>}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'logs'?: Array<BroadcastTx200ResponseTxResponseLogsInner>;
    /**
     * Additional information. May be non-deterministic.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'info'?: string;
    /**
     * Amount of gas requested for transaction.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'gas_wanted'?: string;
    /**
     * Amount of gas consumed by transaction.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'gas_used'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'tx'?: AccountsAreTheExistingAccountsInner;
    /**
     * Time of the previous block. For heights > 1, it\'s the weighted median of the timestamps of the valid votes in the block.LastCommit. For height == 1, it\'s genesis time.
     * @type {string}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'timestamp'?: string;
    /**
     * Events defines all the events emitted by processing a transaction. Note, these events include those emitted by processing all the messages and those emitted from the ante. Whereas Logs contains the events, with additional metadata, emitted only by processing the messages.  Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
     * @type {Array<Simulate200ResponseResultEventsInner>}
     * @memberof CosmosBaseAbciV1beta1TxResponse
     */
    'events'?: Array<Simulate200ResponseResultEventsInner>;
}
/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
    /**
     * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'key'?: string;
    /**
     * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'offset'?: string;
    /**
     * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'limit'?: string;
    /**
     * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'count_total'?: boolean;
    /**
     * reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    'reverse'?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    'total'?: string;
}
/**
 * ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.  Note: This type is a duplicate of the ResponseQuery proto type defined in Tendermint.
 * @export
 * @interface CosmosBaseTendermintV1beta1ABCIQueryResponse
 */
export interface CosmosBaseTendermintV1beta1ABCIQueryResponse {
    /**
     * 
     * @type {number}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'log'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'index'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'value'?: string;
    /**
     * 
     * @type {ABCIQuery200ResponseProofOps}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'proof_ops'?: ABCIQuery200ResponseProofOps;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ABCIQueryResponse
     */
    'codespace'?: string;
}
/**
 * Block is tendermint type Block, with the Header proposer address field converted to bech32 string.
 * @export
 * @interface CosmosBaseTendermintV1beta1Block
 */
export interface CosmosBaseTendermintV1beta1Block {
    /**
     * 
     * @type {SinceCosmosSdk047Header}
     * @memberof CosmosBaseTendermintV1beta1Block
     */
    'header'?: SinceCosmosSdk047Header;
    /**
     * 
     * @type {DataContainsTheSetOfTransactionsIncludedInTheBlock}
     * @memberof CosmosBaseTendermintV1beta1Block
     */
    'data'?: DataContainsTheSetOfTransactionsIncludedInTheBlock;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidence}
     * @memberof CosmosBaseTendermintV1beta1Block
     */
    'evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidence;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof CosmosBaseTendermintV1beta1Block
     */
    'last_commit'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetBlockByHeightResponse
 */
export interface CosmosBaseTendermintV1beta1GetBlockByHeightResponse {
    /**
     * 
     * @type {BlockID}
     * @memberof CosmosBaseTendermintV1beta1GetBlockByHeightResponse
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInstead}
     * @memberof CosmosBaseTendermintV1beta1GetBlockByHeightResponse
     */
    'block'?: DeprecatedPleaseUseSdkBlockInstead;
    /**
     * 
     * @type {SinceCosmosSdk047}
     * @memberof CosmosBaseTendermintV1beta1GetBlockByHeightResponse
     */
    'sdk_block'?: SinceCosmosSdk047;
}
/**
 * GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetLatestBlockResponse
 */
export interface CosmosBaseTendermintV1beta1GetLatestBlockResponse {
    /**
     * 
     * @type {BlockID}
     * @memberof CosmosBaseTendermintV1beta1GetLatestBlockResponse
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInstead}
     * @memberof CosmosBaseTendermintV1beta1GetLatestBlockResponse
     */
    'block'?: DeprecatedPleaseUseSdkBlockInstead;
    /**
     * 
     * @type {SinceCosmosSdk047}
     * @memberof CosmosBaseTendermintV1beta1GetLatestBlockResponse
     */
    'sdk_block'?: SinceCosmosSdk047;
}
/**
 * GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
 */
export interface CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
     */
    'block_height'?: string;
    /**
     * 
     * @type {Array<GetLatestValidatorSet200ResponseValidatorsInner>}
     * @memberof CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
     */
    'validators'?: Array<GetLatestValidatorSet200ResponseValidatorsInner>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof CosmosBaseTendermintV1beta1GetLatestValidatorSetResponse
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetNodeInfoResponse
 */
export interface CosmosBaseTendermintV1beta1GetNodeInfoResponse {
    /**
     * 
     * @type {GetNodeInfo200ResponseDefaultNodeInfo}
     * @memberof CosmosBaseTendermintV1beta1GetNodeInfoResponse
     */
    'default_node_info'?: GetNodeInfo200ResponseDefaultNodeInfo;
    /**
     * 
     * @type {GetNodeInfo200ResponseApplicationVersion}
     * @memberof CosmosBaseTendermintV1beta1GetNodeInfoResponse
     */
    'application_version'?: GetNodeInfo200ResponseApplicationVersion;
}
/**
 * GetSyncingResponse is the response type for the Query/GetSyncing RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetSyncingResponse
 */
export interface CosmosBaseTendermintV1beta1GetSyncingResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CosmosBaseTendermintV1beta1GetSyncingResponse
     */
    'syncing'?: boolean;
}
/**
 * GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
 */
export interface CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
     */
    'block_height'?: string;
    /**
     * 
     * @type {Array<GetLatestValidatorSet200ResponseValidatorsInner>}
     * @memberof CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
     */
    'validators'?: Array<GetLatestValidatorSet200ResponseValidatorsInner>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof CosmosBaseTendermintV1beta1GetValidatorSetByHeightResponse
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * Header defines the structure of a Tendermint block header.
 * @export
 * @interface CosmosBaseTendermintV1beta1Header
 */
export interface CosmosBaseTendermintV1beta1Header {
    /**
     * 
     * @type {BasicBlockInfo}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'version'?: BasicBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'chain_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'time'?: string;
    /**
     * 
     * @type {BlockID}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'last_block_id'?: BlockID;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'last_commit_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'data_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'next_validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'consensus_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'app_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'last_results_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'evidence_hash'?: string;
    /**
     * proposer_address is the original block proposer address, formatted as a Bech32 string. In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string for better UX.
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Header
     */
    'proposer_address'?: string;
}
/**
 * 
 * @export
 * @interface CosmosBaseTendermintV1beta1Module
 */
export interface CosmosBaseTendermintV1beta1Module {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Module
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Module
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Module
     */
    'sum'?: string;
}
/**
 * ProofOp defines an operation used for calculating Merkle root. The data could be arbitrary format, providing nessecary data for example neighbouring node hash.  Note: This type is a duplicate of the ProofOp proto type defined in Tendermint.
 * @export
 * @interface CosmosBaseTendermintV1beta1ProofOp
 */
export interface CosmosBaseTendermintV1beta1ProofOp {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ProofOp
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ProofOp
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1ProofOp
     */
    'data'?: string;
}
/**
 * ProofOps is Merkle proof defined by the list of ProofOps.  Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
 * @export
 * @interface CosmosBaseTendermintV1beta1ProofOps
 */
export interface CosmosBaseTendermintV1beta1ProofOps {
    /**
     * 
     * @type {Array<ABCIQuery200ResponseProofOpsOpsInner>}
     * @memberof CosmosBaseTendermintV1beta1ProofOps
     */
    'ops'?: Array<ABCIQuery200ResponseProofOpsOpsInner>;
}
/**
 * Validator is the type for the validator-set.
 * @export
 * @interface CosmosBaseTendermintV1beta1Validator
 */
export interface CosmosBaseTendermintV1beta1Validator {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    'address'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    'pub_key'?: AccountsAreTheExistingAccountsInner;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    'voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1Validator
     */
    'proposer_priority'?: string;
}
/**
 * VersionInfo is the type for the GetNodeInfoResponse message.
 * @export
 * @interface CosmosBaseTendermintV1beta1VersionInfo
 */
export interface CosmosBaseTendermintV1beta1VersionInfo {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'app_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'git_commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'build_tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'go_version'?: string;
    /**
     * 
     * @type {Array<ModuleIsTheTypeForVersionInfo>}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'build_deps'?: Array<ModuleIsTheTypeForVersionInfo>;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseTendermintV1beta1VersionInfo
     */
    'cosmos_sdk_version'?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    'amount'?: string;
}
/**
 * DecCoin defines a token with a denomination and a decimal amount.  NOTE: The amount field is an Dec which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1DecCoin
 */
export interface CosmosBaseV1beta1DecCoin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1DecCoin
     */
    'denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1DecCoin
     */
    'amount'?: string;
}
/**
 * CompactBitArray is an implementation of a space efficient bit array. This is used to ensure that the encoded data takes up a minimal amount of space after proto encoding. This is not thread safe, and is not intended for concurrent usage.
 * @export
 * @interface CosmosCryptoMultisigV1beta1CompactBitArray
 */
export interface CosmosCryptoMultisigV1beta1CompactBitArray {
    /**
     * 
     * @type {number}
     * @memberof CosmosCryptoMultisigV1beta1CompactBitArray
     */
    'extra_bits_stored'?: number;
    /**
     * 
     * @type {string}
     * @memberof CosmosCryptoMultisigV1beta1CompactBitArray
     */
    'elems'?: string;
}
/**
 * DelegationDelegatorReward represents the properties of a delegator\'s delegation reward.
 * @export
 * @interface CosmosDistributionV1beta1DelegationDelegatorReward
 */
export interface CosmosDistributionV1beta1DelegationDelegatorReward {
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1DelegationDelegatorReward
     */
    'validator_address'?: string;
    /**
     * 
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof CosmosDistributionV1beta1DelegationDelegatorReward
     */
    'reward'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * Params defines the set of params for the distribution module.
 * @export
 * @interface CosmosDistributionV1beta1Params
 */
export interface CosmosDistributionV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1Params
     */
    'community_tax'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1Params
     */
    'base_proposer_reward'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1Params
     */
    'bonus_proposer_reward'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CosmosDistributionV1beta1Params
     */
    'withdraw_addr_enabled'?: boolean;
}
/**
 * QueryCommunityPoolResponse is the response type for the Query/CommunityPool RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryCommunityPoolResponse
 */
export interface CosmosDistributionV1beta1QueryCommunityPoolResponse {
    /**
     * pool defines community pool\'s coins.
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof CosmosDistributionV1beta1QueryCommunityPoolResponse
     */
    'pool'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * QueryDelegationRewardsResponse is the response type for the Query/DelegationRewards RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegationRewardsResponse
 */
export interface CosmosDistributionV1beta1QueryDelegationRewardsResponse {
    /**
     * rewards defines the rewards accrued by a delegation.
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof CosmosDistributionV1beta1QueryDelegationRewardsResponse
     */
    'rewards'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * QueryDelegationTotalRewardsResponse is the response type for the Query/DelegationTotalRewards RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse
 */
export interface CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse {
    /**
     * rewards defines all the rewards accrued by a delegator.
     * @type {Array<DelegationTotalRewards200ResponseRewardsInner>}
     * @memberof CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse
     */
    'rewards'?: Array<DelegationTotalRewards200ResponseRewardsInner>;
    /**
     * total defines the sum of all the rewards.
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof CosmosDistributionV1beta1QueryDelegationTotalRewardsResponse
     */
    'total'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * QueryDelegatorValidatorsResponse is the response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegatorValidatorsResponse
 */
export interface CosmosDistributionV1beta1QueryDelegatorValidatorsResponse {
    /**
     * validators defines the validators a delegator is delegating for.
     * @type {Array<string>}
     * @memberof CosmosDistributionV1beta1QueryDelegatorValidatorsResponse
     */
    'validators'?: Array<string>;
}
/**
 * QueryDelegatorWithdrawAddressResponse is the response type for the Query/DelegatorWithdrawAddress RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryDelegatorWithdrawAddressResponse
 */
export interface CosmosDistributionV1beta1QueryDelegatorWithdrawAddressResponse {
    /**
     * withdraw_address defines the delegator address to query for.
     * @type {string}
     * @memberof CosmosDistributionV1beta1QueryDelegatorWithdrawAddressResponse
     */
    'withdraw_address'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryParamsResponse
 */
export interface CosmosDistributionV1beta1QueryParamsResponse {
    /**
     * 
     * @type {DistributionParams200ResponseParams}
     * @memberof CosmosDistributionV1beta1QueryParamsResponse
     */
    'params'?: DistributionParams200ResponseParams;
}
/**
 * 
 * @export
 * @interface CosmosDistributionV1beta1QueryValidatorCommissionResponse
 */
export interface CosmosDistributionV1beta1QueryValidatorCommissionResponse {
    /**
     * 
     * @type {QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission}
     * @memberof CosmosDistributionV1beta1QueryValidatorCommissionResponse
     */
    'commission'?: QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission;
}
/**
 * QueryValidatorOutstandingRewardsResponse is the response type for the Query/ValidatorOutstandingRewards RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryValidatorOutstandingRewardsResponse
 */
export interface CosmosDistributionV1beta1QueryValidatorOutstandingRewardsResponse {
    /**
     * 
     * @type {ValidatorOutstandingRewards200ResponseRewards}
     * @memberof CosmosDistributionV1beta1QueryValidatorOutstandingRewardsResponse
     */
    'rewards'?: ValidatorOutstandingRewards200ResponseRewards;
}
/**
 * QueryValidatorSlashesResponse is the response type for the Query/ValidatorSlashes RPC method.
 * @export
 * @interface CosmosDistributionV1beta1QueryValidatorSlashesResponse
 */
export interface CosmosDistributionV1beta1QueryValidatorSlashesResponse {
    /**
     * slashes defines the slashes the validator received.
     * @type {Array<ValidatorSlashes200ResponseSlashesInner>}
     * @memberof CosmosDistributionV1beta1QueryValidatorSlashesResponse
     */
    'slashes'?: Array<ValidatorSlashes200ResponseSlashesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosDistributionV1beta1QueryValidatorSlashesResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * ValidatorAccumulatedCommission represents accumulated commission for a validator kept as a running counter, can be withdrawn at any time.
 * @export
 * @interface CosmosDistributionV1beta1ValidatorAccumulatedCommission
 */
export interface CosmosDistributionV1beta1ValidatorAccumulatedCommission {
    /**
     * 
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof CosmosDistributionV1beta1ValidatorAccumulatedCommission
     */
    'commission'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards for a validator inexpensive to track, allows simple sanity checks.
 * @export
 * @interface CosmosDistributionV1beta1ValidatorOutstandingRewards
 */
export interface CosmosDistributionV1beta1ValidatorOutstandingRewards {
    /**
     * 
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof CosmosDistributionV1beta1ValidatorOutstandingRewards
     */
    'rewards'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * ValidatorSlashEvent represents a validator slash event. Height is implicit within the store key. This is needed to calculate appropriate amount of staking tokens for delegations which are withdrawn after a slash has occurred.
 * @export
 * @interface CosmosDistributionV1beta1ValidatorSlashEvent
 */
export interface CosmosDistributionV1beta1ValidatorSlashEvent {
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1ValidatorSlashEvent
     */
    'validator_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosDistributionV1beta1ValidatorSlashEvent
     */
    'fraction'?: string;
}
/**
 * QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC method.
 * @export
 * @interface CosmosEvidenceV1beta1QueryAllEvidenceResponse
 */
export interface CosmosEvidenceV1beta1QueryAllEvidenceResponse {
    /**
     * evidence returns all evidences.
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosEvidenceV1beta1QueryAllEvidenceResponse
     */
    'evidence'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosEvidenceV1beta1QueryAllEvidenceResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryEvidenceResponse is the response type for the Query/Evidence RPC method.
 * @export
 * @interface CosmosEvidenceV1beta1QueryEvidenceResponse
 */
export interface CosmosEvidenceV1beta1QueryEvidenceResponse {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosEvidenceV1beta1QueryEvidenceResponse
     */
    'evidence'?: AccountsAreTheExistingAccountsInner;
}
/**
 * 
 * @export
 * @interface CosmosFeegrantV1beta1Grant
 */
export interface CosmosFeegrantV1beta1Grant {
    /**
     * granter is the address of the user granting an allowance of their funds.
     * @type {string}
     * @memberof CosmosFeegrantV1beta1Grant
     */
    'granter'?: string;
    /**
     * grantee is the address of the user being granted an allowance of another user\'s funds.
     * @type {string}
     * @memberof CosmosFeegrantV1beta1Grant
     */
    'grantee'?: string;
    /**
     * 
     * @type {GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance}
     * @memberof CosmosFeegrantV1beta1Grant
     */
    'allowance'?: GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance;
}
/**
 * QueryAllowanceResponse is the response type for the Query/Allowance RPC method.
 * @export
 * @interface CosmosFeegrantV1beta1QueryAllowanceResponse
 */
export interface CosmosFeegrantV1beta1QueryAllowanceResponse {
    /**
     * 
     * @type {GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext}
     * @memberof CosmosFeegrantV1beta1QueryAllowanceResponse
     */
    'allowance'?: GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext;
}
/**
 * QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosFeegrantV1beta1QueryAllowancesByGranterResponse
 */
export interface CosmosFeegrantV1beta1QueryAllowancesByGranterResponse {
    /**
     * allowances that have been issued by the granter.
     * @type {Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>}
     * @memberof CosmosFeegrantV1beta1QueryAllowancesByGranterResponse
     */
    'allowances'?: Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof CosmosFeegrantV1beta1QueryAllowancesByGranterResponse
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * QueryAllowancesResponse is the response type for the Query/Allowances RPC method.
 * @export
 * @interface CosmosFeegrantV1beta1QueryAllowancesResponse
 */
export interface CosmosFeegrantV1beta1QueryAllowancesResponse {
    /**
     * allowances are allowance\'s granted for grantee by granter.
     * @type {Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>}
     * @memberof CosmosFeegrantV1beta1QueryAllowancesResponse
     */
    'allowances'?: Array<GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof CosmosFeegrantV1beta1QueryAllowancesResponse
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * Deposit defines an amount deposited by an account address to an active proposal.
 * @export
 * @interface CosmosGovV1Deposit
 */
export interface CosmosGovV1Deposit {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Deposit
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Deposit
     */
    'depositor'?: string;
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosGovV1Deposit
     */
    'amount'?: Array<AllBalances200ResponseBalancesInner>;
}
/**
 * DepositParams defines the params for deposits on governance proposals.
 * @export
 * @interface CosmosGovV1DepositParams
 */
export interface CosmosGovV1DepositParams {
    /**
     * Minimum deposit for a proposal to enter voting period.
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosGovV1DepositParams
     */
    'min_deposit'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2  months.
     * @type {string}
     * @memberof CosmosGovV1DepositParams
     */
    'max_deposit_period'?: string;
}
/**
 * Proposal defines the core field members of a governance proposal.
 * @export
 * @interface CosmosGovV1Proposal
 */
export interface CosmosGovV1Proposal {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Proposal
     */
    'id'?: string;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosGovV1Proposal
     */
    'messages'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @type {string}
     * @memberof CosmosGovV1Proposal
     */
    'status'?: CosmosGovV1ProposalStatusEnum;
    /**
     * 
     * @type {GovV1Proposal200ResponseProposalsInnerFinalTallyResult}
     * @memberof CosmosGovV1Proposal
     */
    'final_tally_result'?: GovV1Proposal200ResponseProposalsInnerFinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Proposal
     */
    'submit_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Proposal
     */
    'deposit_end_time'?: string;
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosGovV1Proposal
     */
    'total_deposit'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Proposal
     */
    'voting_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Proposal
     */
    'voting_end_time'?: string;
    /**
     * metadata is any arbitrary metadata attached to the proposal.
     * @type {string}
     * @memberof CosmosGovV1Proposal
     */
    'metadata'?: string;
}

export const CosmosGovV1ProposalStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
} as const;

export type CosmosGovV1ProposalStatusEnum = typeof CosmosGovV1ProposalStatusEnum[keyof typeof CosmosGovV1ProposalStatusEnum];

/**
 * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
 * @export
 * @enum {string}
 */

export const CosmosGovV1ProposalStatus = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
} as const;

export type CosmosGovV1ProposalStatus = typeof CosmosGovV1ProposalStatus[keyof typeof CosmosGovV1ProposalStatus];


/**
 * QueryDepositResponse is the response type for the Query/Deposit RPC method.
 * @export
 * @interface CosmosGovV1QueryDepositResponse
 */
export interface CosmosGovV1QueryDepositResponse {
    /**
     * 
     * @type {Deposits200ResponseDepositsInner}
     * @memberof CosmosGovV1QueryDepositResponse
     */
    'deposit'?: Deposits200ResponseDepositsInner;
}
/**
 * QueryDepositsResponse is the response type for the Query/Deposits RPC method.
 * @export
 * @interface CosmosGovV1QueryDepositsResponse
 */
export interface CosmosGovV1QueryDepositsResponse {
    /**
     * 
     * @type {Array<Deposits200ResponseDepositsInner>}
     * @memberof CosmosGovV1QueryDepositsResponse
     */
    'deposits'?: Array<Deposits200ResponseDepositsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGovV1QueryDepositsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosGovV1QueryParamsResponse
 */
export interface CosmosGovV1QueryParamsResponse {
    /**
     * 
     * @type {GovParams200ResponseVotingParams}
     * @memberof CosmosGovV1QueryParamsResponse
     */
    'voting_params'?: GovParams200ResponseVotingParams;
    /**
     * 
     * @type {GovParams200ResponseDepositParams}
     * @memberof CosmosGovV1QueryParamsResponse
     */
    'deposit_params'?: GovParams200ResponseDepositParams;
    /**
     * 
     * @type {GovV1Params200ResponseTallyParams}
     * @memberof CosmosGovV1QueryParamsResponse
     */
    'tally_params'?: GovV1Params200ResponseTallyParams;
}
/**
 * QueryProposalResponse is the response type for the Query/Proposal RPC method.
 * @export
 * @interface CosmosGovV1QueryProposalResponse
 */
export interface CosmosGovV1QueryProposalResponse {
    /**
     * 
     * @type {GovV1Proposal200ResponseProposalsInner}
     * @memberof CosmosGovV1QueryProposalResponse
     */
    'proposal'?: GovV1Proposal200ResponseProposalsInner;
}
/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC method.
 * @export
 * @interface CosmosGovV1QueryProposalsResponse
 */
export interface CosmosGovV1QueryProposalsResponse {
    /**
     * 
     * @type {Array<GovV1Proposal200ResponseProposalsInner>}
     * @memberof CosmosGovV1QueryProposalsResponse
     */
    'proposals'?: Array<GovV1Proposal200ResponseProposalsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGovV1QueryProposalsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryTallyResultResponse is the response type for the Query/Tally RPC method.
 * @export
 * @interface CosmosGovV1QueryTallyResultResponse
 */
export interface CosmosGovV1QueryTallyResultResponse {
    /**
     * 
     * @type {GovV1TallyResult200ResponseTally}
     * @memberof CosmosGovV1QueryTallyResultResponse
     */
    'tally'?: GovV1TallyResult200ResponseTally;
}
/**
 * QueryVoteResponse is the response type for the Query/Vote RPC method.
 * @export
 * @interface CosmosGovV1QueryVoteResponse
 */
export interface CosmosGovV1QueryVoteResponse {
    /**
     * 
     * @type {GovV1Votes200ResponseVotesInner}
     * @memberof CosmosGovV1QueryVoteResponse
     */
    'vote'?: GovV1Votes200ResponseVotesInner;
}
/**
 * QueryVotesResponse is the response type for the Query/Votes RPC method.
 * @export
 * @interface CosmosGovV1QueryVotesResponse
 */
export interface CosmosGovV1QueryVotesResponse {
    /**
     * votes defined the queried votes.
     * @type {Array<GovV1Votes200ResponseVotesInner>}
     * @memberof CosmosGovV1QueryVotesResponse
     */
    'votes'?: Array<GovV1Votes200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGovV1QueryVotesResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * TallyParams defines the params for tallying votes on governance proposals.
 * @export
 * @interface CosmosGovV1TallyParams
 */
export interface CosmosGovV1TallyParams {
    /**
     * Minimum percentage of total stake needed to vote for a result to be  considered valid.
     * @type {string}
     * @memberof CosmosGovV1TallyParams
     */
    'quorum'?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
     * @type {string}
     * @memberof CosmosGovV1TallyParams
     */
    'threshold'?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be  vetoed. Default value: 1/3.
     * @type {string}
     * @memberof CosmosGovV1TallyParams
     */
    'veto_threshold'?: string;
}
/**
 * TallyResult defines a standard tally for a governance proposal.
 * @export
 * @interface CosmosGovV1TallyResult
 */
export interface CosmosGovV1TallyResult {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1TallyResult
     */
    'yes_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1TallyResult
     */
    'abstain_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1TallyResult
     */
    'no_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1TallyResult
     */
    'no_with_veto_count'?: string;
}
/**
 * Vote defines a vote on a governance proposal. A Vote consists of a proposal ID, the voter, and the vote option.
 * @export
 * @interface CosmosGovV1Vote
 */
export interface CosmosGovV1Vote {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Vote
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1Vote
     */
    'voter'?: string;
    /**
     * 
     * @type {Array<GovV1Votes200ResponseVotesInnerOptionsInner>}
     * @memberof CosmosGovV1Vote
     */
    'options'?: Array<GovV1Votes200ResponseVotesInnerOptionsInner>;
    /**
     * metadata is any  arbitrary metadata to attached to the vote.
     * @type {string}
     * @memberof CosmosGovV1Vote
     */
    'metadata'?: string;
}
/**
 * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @export
 * @enum {string}
 */

export const CosmosGovV1VoteOption = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type CosmosGovV1VoteOption = typeof CosmosGovV1VoteOption[keyof typeof CosmosGovV1VoteOption];


/**
 * VotingParams defines the params for voting on governance proposals.
 * @export
 * @interface CosmosGovV1VotingParams
 */
export interface CosmosGovV1VotingParams {
    /**
     * Length of the voting period.
     * @type {string}
     * @memberof CosmosGovV1VotingParams
     */
    'voting_period'?: string;
}
/**
 * WeightedVoteOption defines a unit of vote for vote split.
 * @export
 * @interface CosmosGovV1WeightedVoteOption
 */
export interface CosmosGovV1WeightedVoteOption {
    /**
     * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @type {string}
     * @memberof CosmosGovV1WeightedVoteOption
     */
    'option'?: CosmosGovV1WeightedVoteOptionOptionEnum;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1WeightedVoteOption
     */
    'weight'?: string;
}

export const CosmosGovV1WeightedVoteOptionOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type CosmosGovV1WeightedVoteOptionOptionEnum = typeof CosmosGovV1WeightedVoteOptionOptionEnum[keyof typeof CosmosGovV1WeightedVoteOptionOptionEnum];

/**
 * Deposit defines an amount deposited by an account address to an active proposal.
 * @export
 * @interface CosmosGovV1beta1Deposit
 */
export interface CosmosGovV1beta1Deposit {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Deposit
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Deposit
     */
    'depositor'?: string;
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosGovV1beta1Deposit
     */
    'amount'?: Array<AllBalances200ResponseBalancesInner>;
}
/**
 * DepositParams defines the params for deposits on governance proposals.
 * @export
 * @interface CosmosGovV1beta1DepositParams
 */
export interface CosmosGovV1beta1DepositParams {
    /**
     * Minimum deposit for a proposal to enter voting period.
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosGovV1beta1DepositParams
     */
    'min_deposit'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2  months.
     * @type {string}
     * @memberof CosmosGovV1beta1DepositParams
     */
    'max_deposit_period'?: string;
}
/**
 * Proposal defines the core field members of a governance proposal.
 * @export
 * @interface CosmosGovV1beta1Proposal
 */
export interface CosmosGovV1beta1Proposal {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosGovV1beta1Proposal
     */
    'content'?: AccountsAreTheExistingAccountsInner;
    /**
     * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    'status'?: CosmosGovV1beta1ProposalStatusEnum;
    /**
     * 
     * @type {Proposals200ResponseProposalsInnerFinalTallyResult}
     * @memberof CosmosGovV1beta1Proposal
     */
    'final_tally_result'?: Proposals200ResponseProposalsInnerFinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    'submit_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    'deposit_end_time'?: string;
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosGovV1beta1Proposal
     */
    'total_deposit'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    'voting_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Proposal
     */
    'voting_end_time'?: string;
}

export const CosmosGovV1beta1ProposalStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
} as const;

export type CosmosGovV1beta1ProposalStatusEnum = typeof CosmosGovV1beta1ProposalStatusEnum[keyof typeof CosmosGovV1beta1ProposalStatusEnum];

/**
 * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
 * @export
 * @enum {string}
 */

export const CosmosGovV1beta1ProposalStatus = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
} as const;

export type CosmosGovV1beta1ProposalStatus = typeof CosmosGovV1beta1ProposalStatus[keyof typeof CosmosGovV1beta1ProposalStatus];


/**
 * QueryDepositResponse is the response type for the Query/Deposit RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryDepositResponse
 */
export interface CosmosGovV1beta1QueryDepositResponse {
    /**
     * 
     * @type {Deposits200ResponseDepositsInner}
     * @memberof CosmosGovV1beta1QueryDepositResponse
     */
    'deposit'?: Deposits200ResponseDepositsInner;
}
/**
 * QueryDepositsResponse is the response type for the Query/Deposits RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryDepositsResponse
 */
export interface CosmosGovV1beta1QueryDepositsResponse {
    /**
     * 
     * @type {Array<Deposits200ResponseDepositsInner>}
     * @memberof CosmosGovV1beta1QueryDepositsResponse
     */
    'deposits'?: Array<Deposits200ResponseDepositsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGovV1beta1QueryDepositsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryParamsResponse
 */
export interface CosmosGovV1beta1QueryParamsResponse {
    /**
     * 
     * @type {GovParams200ResponseVotingParams}
     * @memberof CosmosGovV1beta1QueryParamsResponse
     */
    'voting_params'?: GovParams200ResponseVotingParams;
    /**
     * 
     * @type {GovParams200ResponseDepositParams}
     * @memberof CosmosGovV1beta1QueryParamsResponse
     */
    'deposit_params'?: GovParams200ResponseDepositParams;
    /**
     * 
     * @type {GovParams200ResponseTallyParams}
     * @memberof CosmosGovV1beta1QueryParamsResponse
     */
    'tally_params'?: GovParams200ResponseTallyParams;
}
/**
 * QueryProposalResponse is the response type for the Query/Proposal RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryProposalResponse
 */
export interface CosmosGovV1beta1QueryProposalResponse {
    /**
     * 
     * @type {Proposals200ResponseProposalsInner}
     * @memberof CosmosGovV1beta1QueryProposalResponse
     */
    'proposal'?: Proposals200ResponseProposalsInner;
}
/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryProposalsResponse
 */
export interface CosmosGovV1beta1QueryProposalsResponse {
    /**
     * 
     * @type {Array<Proposals200ResponseProposalsInner>}
     * @memberof CosmosGovV1beta1QueryProposalsResponse
     */
    'proposals'?: Array<Proposals200ResponseProposalsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGovV1beta1QueryProposalsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryTallyResultResponse is the response type for the Query/Tally RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryTallyResultResponse
 */
export interface CosmosGovV1beta1QueryTallyResultResponse {
    /**
     * 
     * @type {TallyResult200ResponseTally}
     * @memberof CosmosGovV1beta1QueryTallyResultResponse
     */
    'tally'?: TallyResult200ResponseTally;
}
/**
 * QueryVoteResponse is the response type for the Query/Vote RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryVoteResponse
 */
export interface CosmosGovV1beta1QueryVoteResponse {
    /**
     * 
     * @type {Votes200ResponseVotesInner}
     * @memberof CosmosGovV1beta1QueryVoteResponse
     */
    'vote'?: Votes200ResponseVotesInner;
}
/**
 * QueryVotesResponse is the response type for the Query/Votes RPC method.
 * @export
 * @interface CosmosGovV1beta1QueryVotesResponse
 */
export interface CosmosGovV1beta1QueryVotesResponse {
    /**
     * votes defined the queried votes.
     * @type {Array<Votes200ResponseVotesInner>}
     * @memberof CosmosGovV1beta1QueryVotesResponse
     */
    'votes'?: Array<Votes200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGovV1beta1QueryVotesResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * TallyParams defines the params for tallying votes on governance proposals.
 * @export
 * @interface CosmosGovV1beta1TallyParams
 */
export interface CosmosGovV1beta1TallyParams {
    /**
     * Minimum percentage of total stake needed to vote for a result to be  considered valid.
     * @type {string}
     * @memberof CosmosGovV1beta1TallyParams
     */
    'quorum'?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
     * @type {string}
     * @memberof CosmosGovV1beta1TallyParams
     */
    'threshold'?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be  vetoed. Default value: 1/3.
     * @type {string}
     * @memberof CosmosGovV1beta1TallyParams
     */
    'veto_threshold'?: string;
}
/**
 * TallyResult defines a standard tally for a governance proposal.
 * @export
 * @interface CosmosGovV1beta1TallyResult
 */
export interface CosmosGovV1beta1TallyResult {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    'yes'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    'abstain'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    'no'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1TallyResult
     */
    'no_with_veto'?: string;
}
/**
 * Vote defines a vote on a governance proposal. A Vote consists of a proposal ID, the voter, and the vote option.
 * @export
 * @interface CosmosGovV1beta1Vote
 */
export interface CosmosGovV1beta1Vote {
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Vote
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1Vote
     */
    'voter'?: string;
    /**
     * Deprecated: Prefer to use `options` instead. This field is set in queries if and only if `len(options) == 1` and that option has weight 1. In all other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
     * @type {string}
     * @memberof CosmosGovV1beta1Vote
     */
    'option'?: CosmosGovV1beta1VoteOptionEnum;
    /**
     * 
     * @type {Array<SinceCosmosSdk043Inner>}
     * @memberof CosmosGovV1beta1Vote
     */
    'options'?: Array<SinceCosmosSdk043Inner>;
}

export const CosmosGovV1beta1VoteOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type CosmosGovV1beta1VoteOptionEnum = typeof CosmosGovV1beta1VoteOptionEnum[keyof typeof CosmosGovV1beta1VoteOptionEnum];

/**
 * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @export
 * @enum {string}
 */

export const CosmosGovV1beta1VoteOption = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type CosmosGovV1beta1VoteOption = typeof CosmosGovV1beta1VoteOption[keyof typeof CosmosGovV1beta1VoteOption];


/**
 * VotingParams defines the params for voting on governance proposals.
 * @export
 * @interface CosmosGovV1beta1VotingParams
 */
export interface CosmosGovV1beta1VotingParams {
    /**
     * Length of the voting period.
     * @type {string}
     * @memberof CosmosGovV1beta1VotingParams
     */
    'voting_period'?: string;
}
/**
 * WeightedVoteOption defines a unit of vote for vote split.  Since: cosmos-sdk 0.43
 * @export
 * @interface CosmosGovV1beta1WeightedVoteOption
 */
export interface CosmosGovV1beta1WeightedVoteOption {
    /**
     * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @type {string}
     * @memberof CosmosGovV1beta1WeightedVoteOption
     */
    'option'?: CosmosGovV1beta1WeightedVoteOptionOptionEnum;
    /**
     * 
     * @type {string}
     * @memberof CosmosGovV1beta1WeightedVoteOption
     */
    'weight'?: string;
}

export const CosmosGovV1beta1WeightedVoteOptionOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type CosmosGovV1beta1WeightedVoteOptionOptionEnum = typeof CosmosGovV1beta1WeightedVoteOptionOptionEnum[keyof typeof CosmosGovV1beta1WeightedVoteOptionOptionEnum];

/**
 * GroupInfo represents the high-level on-chain information for a group.
 * @export
 * @interface CosmosGroupV1GroupInfo
 */
export interface CosmosGroupV1GroupInfo {
    /**
     * id is the unique ID of the group.
     * @type {string}
     * @memberof CosmosGroupV1GroupInfo
     */
    'id'?: string;
    /**
     * admin is the account address of the group\'s admin.
     * @type {string}
     * @memberof CosmosGroupV1GroupInfo
     */
    'admin'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the group.
     * @type {string}
     * @memberof CosmosGroupV1GroupInfo
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosGroupV1GroupInfo
     */
    'version'?: string;
    /**
     * total_weight is the sum of the group members\' weights.
     * @type {string}
     * @memberof CosmosGroupV1GroupInfo
     */
    'total_weight'?: string;
    /**
     * created_at is a timestamp specifying when a group was created.
     * @type {string}
     * @memberof CosmosGroupV1GroupInfo
     */
    'created_at'?: string;
}
/**
 * GroupMember represents the relationship between a group and a member.
 * @export
 * @interface CosmosGroupV1GroupMember
 */
export interface CosmosGroupV1GroupMember {
    /**
     * group_id is the unique ID of the group.
     * @type {string}
     * @memberof CosmosGroupV1GroupMember
     */
    'group_id'?: string;
    /**
     * 
     * @type {GroupMembers200ResponseMembersInnerMember}
     * @memberof CosmosGroupV1GroupMember
     */
    'member'?: GroupMembers200ResponseMembersInnerMember;
}
/**
 * GroupPolicyInfo represents the high-level on-chain information for a group policy.
 * @export
 * @interface CosmosGroupV1GroupPolicyInfo
 */
export interface CosmosGroupV1GroupPolicyInfo {
    /**
     * address is the account address of group policy.
     * @type {string}
     * @memberof CosmosGroupV1GroupPolicyInfo
     */
    'address'?: string;
    /**
     * group_id is the unique ID of the group.
     * @type {string}
     * @memberof CosmosGroupV1GroupPolicyInfo
     */
    'group_id'?: string;
    /**
     * admin is the account address of the group admin.
     * @type {string}
     * @memberof CosmosGroupV1GroupPolicyInfo
     */
    'admin'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the group policy.
     * @type {string}
     * @memberof CosmosGroupV1GroupPolicyInfo
     */
    'metadata'?: string;
    /**
     * version is used to track changes to a group\'s GroupPolicyInfo structure that would create a different result on a running proposal.
     * @type {string}
     * @memberof CosmosGroupV1GroupPolicyInfo
     */
    'version'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosGroupV1GroupPolicyInfo
     */
    'decision_policy'?: AccountsAreTheExistingAccountsInner;
    /**
     * created_at is a timestamp specifying when a group policy was created.
     * @type {string}
     * @memberof CosmosGroupV1GroupPolicyInfo
     */
    'created_at'?: string;
}
/**
 * Member represents a group member with an account address, non-zero weight, metadata and added_at timestamp.
 * @export
 * @interface CosmosGroupV1Member
 */
export interface CosmosGroupV1Member {
    /**
     * address is the member\'s account address.
     * @type {string}
     * @memberof CosmosGroupV1Member
     */
    'address'?: string;
    /**
     * weight is the member\'s voting weight that should be greater than 0.
     * @type {string}
     * @memberof CosmosGroupV1Member
     */
    'weight'?: string;
    /**
     * metadata is any arbitrary metadata attached to the member.
     * @type {string}
     * @memberof CosmosGroupV1Member
     */
    'metadata'?: string;
    /**
     * added_at is a timestamp specifying when a member was added.
     * @type {string}
     * @memberof CosmosGroupV1Member
     */
    'added_at'?: string;
}
/**
 * Proposal defines a group proposal. Any member of a group can submit a proposal for a group policy to decide upon. A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal passes as well as some optional metadata associated with the proposal.
 * @export
 * @interface CosmosGroupV1Proposal
 */
export interface CosmosGroupV1Proposal {
    /**
     * id is the unique id of the proposal.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'id'?: string;
    /**
     * group_policy_address is the account address of group policy.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'group_policy_address'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the proposal.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'metadata'?: string;
    /**
     * proposers are the account addresses of the proposers.
     * @type {Array<string>}
     * @memberof CosmosGroupV1Proposal
     */
    'proposers'?: Array<string>;
    /**
     * submit_time is a timestamp specifying when a proposal was submitted.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'submit_time'?: string;
    /**
     * group_version tracks the version of the group at proposal submission. This field is here for informational purposes only.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'group_version'?: string;
    /**
     * group_policy_version tracks the version of the group policy at proposal submission. When a decision policy is changed, existing proposals from previous policy versions will become invalid with the `ABORTED` status. This field is here for informational purposes only.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'group_policy_version'?: string;
    /**
     * status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'status'?: CosmosGroupV1ProposalStatusEnum;
    /**
     * 
     * @type {GroupProposal200ResponseProposalFinalTallyResult}
     * @memberof CosmosGroupV1Proposal
     */
    'final_tally_result'?: GroupProposal200ResponseProposalFinalTallyResult;
    /**
     * voting_period_end is the timestamp before which voting must be done. Unless a successfull MsgExec is called before (to execute a proposal whose tally is successful before the voting period ends), tallying will be done at this point, and the `final_tally_result`and `status` fields will be accordingly updated.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'voting_period_end'?: string;
    /**
     * executor_result is the final result of the proposal execution. Initial value is NotRun.
     * @type {string}
     * @memberof CosmosGroupV1Proposal
     */
    'executor_result'?: CosmosGroupV1ProposalExecutorResultEnum;
    /**
     * messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosGroupV1Proposal
     */
    'messages'?: Array<AccountsAreTheExistingAccountsInner>;
}

export const CosmosGroupV1ProposalStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    Submitted: 'PROPOSAL_STATUS_SUBMITTED',
    Accepted: 'PROPOSAL_STATUS_ACCEPTED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Aborted: 'PROPOSAL_STATUS_ABORTED',
    Withdrawn: 'PROPOSAL_STATUS_WITHDRAWN'
} as const;

export type CosmosGroupV1ProposalStatusEnum = typeof CosmosGroupV1ProposalStatusEnum[keyof typeof CosmosGroupV1ProposalStatusEnum];
export const CosmosGroupV1ProposalExecutorResultEnum = {
    Unspecified: 'PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED',
    NotRun: 'PROPOSAL_EXECUTOR_RESULT_NOT_RUN',
    Success: 'PROPOSAL_EXECUTOR_RESULT_SUCCESS',
    Failure: 'PROPOSAL_EXECUTOR_RESULT_FAILURE'
} as const;

export type CosmosGroupV1ProposalExecutorResultEnum = typeof CosmosGroupV1ProposalExecutorResultEnum[keyof typeof CosmosGroupV1ProposalExecutorResultEnum];

/**
 * ProposalExecutorResult defines types of proposal executor results.   - PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED: An empty value is not allowed.  - PROPOSAL_EXECUTOR_RESULT_NOT_RUN: We have not yet run the executor.  - PROPOSAL_EXECUTOR_RESULT_SUCCESS: The executor was successful and proposed action updated state.  - PROPOSAL_EXECUTOR_RESULT_FAILURE: The executor returned an error and proposed action didn\'t update state.
 * @export
 * @enum {string}
 */

export const CosmosGroupV1ProposalExecutorResult = {
    Unspecified: 'PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED',
    NotRun: 'PROPOSAL_EXECUTOR_RESULT_NOT_RUN',
    Success: 'PROPOSAL_EXECUTOR_RESULT_SUCCESS',
    Failure: 'PROPOSAL_EXECUTOR_RESULT_FAILURE'
} as const;

export type CosmosGroupV1ProposalExecutorResult = typeof CosmosGroupV1ProposalExecutorResult[keyof typeof CosmosGroupV1ProposalExecutorResult];


/**
 * ProposalStatus defines proposal statuses.   - PROPOSAL_STATUS_UNSPECIFIED: An empty value is invalid and not allowed.  - PROPOSAL_STATUS_SUBMITTED: Initial status of a proposal when submitted.  - PROPOSAL_STATUS_ACCEPTED: Final status of a proposal when the final tally is done and the outcome passes the group policy\'s decision policy.  - PROPOSAL_STATUS_REJECTED: Final status of a proposal when the final tally is done and the outcome is rejected by the group policy\'s decision policy.  - PROPOSAL_STATUS_ABORTED: Final status of a proposal when the group policy is modified before the final tally.  - PROPOSAL_STATUS_WITHDRAWN: A proposal can be withdrawn before the voting start time by the owner. When this happens the final status is Withdrawn.
 * @export
 * @enum {string}
 */

export const CosmosGroupV1ProposalStatus = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    Submitted: 'PROPOSAL_STATUS_SUBMITTED',
    Accepted: 'PROPOSAL_STATUS_ACCEPTED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Aborted: 'PROPOSAL_STATUS_ABORTED',
    Withdrawn: 'PROPOSAL_STATUS_WITHDRAWN'
} as const;

export type CosmosGroupV1ProposalStatus = typeof CosmosGroupV1ProposalStatus[keyof typeof CosmosGroupV1ProposalStatus];


/**
 * QueryGroupInfoResponse is the Query/GroupInfo response type.
 * @export
 * @interface CosmosGroupV1QueryGroupInfoResponse
 */
export interface CosmosGroupV1QueryGroupInfoResponse {
    /**
     * 
     * @type {GroupInfo200ResponseInfo}
     * @memberof CosmosGroupV1QueryGroupInfoResponse
     */
    'info'?: GroupInfo200ResponseInfo;
}
/**
 * QueryGroupMembersResponse is the Query/GroupMembersResponse response type.
 * @export
 * @interface CosmosGroupV1QueryGroupMembersResponse
 */
export interface CosmosGroupV1QueryGroupMembersResponse {
    /**
     * members are the members of the group with given group_id.
     * @type {Array<GroupMembers200ResponseMembersInner>}
     * @memberof CosmosGroupV1QueryGroupMembersResponse
     */
    'members'?: Array<GroupMembers200ResponseMembersInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryGroupMembersResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin response type.
 * @export
 * @interface CosmosGroupV1QueryGroupPoliciesByAdminResponse
 */
export interface CosmosGroupV1QueryGroupPoliciesByAdminResponse {
    /**
     * group_policies are the group policies info with provided admin.
     * @type {Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>}
     * @memberof CosmosGroupV1QueryGroupPoliciesByAdminResponse
     */
    'group_policies'?: Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryGroupPoliciesByAdminResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup response type.
 * @export
 * @interface CosmosGroupV1QueryGroupPoliciesByGroupResponse
 */
export interface CosmosGroupV1QueryGroupPoliciesByGroupResponse {
    /**
     * group_policies are the group policies info associated with the provided group.
     * @type {Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>}
     * @memberof CosmosGroupV1QueryGroupPoliciesByGroupResponse
     */
    'group_policies'?: Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryGroupPoliciesByGroupResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type.
 * @export
 * @interface CosmosGroupV1QueryGroupPolicyInfoResponse
 */
export interface CosmosGroupV1QueryGroupPolicyInfoResponse {
    /**
     * 
     * @type {GroupPoliciesByAdmin200ResponseGroupPoliciesInner}
     * @memberof CosmosGroupV1QueryGroupPolicyInfoResponse
     */
    'info'?: GroupPoliciesByAdmin200ResponseGroupPoliciesInner;
}
/**
 * QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response type.
 * @export
 * @interface CosmosGroupV1QueryGroupsByAdminResponse
 */
export interface CosmosGroupV1QueryGroupsByAdminResponse {
    /**
     * groups are the groups info with the provided admin.
     * @type {Array<GroupsByAdmin200ResponseGroupsInner>}
     * @memberof CosmosGroupV1QueryGroupsByAdminResponse
     */
    'groups'?: Array<GroupsByAdmin200ResponseGroupsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryGroupsByAdminResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryGroupsByMemberResponse is the Query/GroupsByMember response type.
 * @export
 * @interface CosmosGroupV1QueryGroupsByMemberResponse
 */
export interface CosmosGroupV1QueryGroupsByMemberResponse {
    /**
     * groups are the groups info with the provided group member.
     * @type {Array<GroupsByAdmin200ResponseGroupsInner>}
     * @memberof CosmosGroupV1QueryGroupsByMemberResponse
     */
    'groups'?: Array<GroupsByAdmin200ResponseGroupsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryGroupsByMemberResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryProposalResponse is the Query/Proposal response type.
 * @export
 * @interface CosmosGroupV1QueryProposalResponse
 */
export interface CosmosGroupV1QueryProposalResponse {
    /**
     * 
     * @type {GroupProposal200ResponseProposal}
     * @memberof CosmosGroupV1QueryProposalResponse
     */
    'proposal'?: GroupProposal200ResponseProposal;
}
/**
 * QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy response type.
 * @export
 * @interface CosmosGroupV1QueryProposalsByGroupPolicyResponse
 */
export interface CosmosGroupV1QueryProposalsByGroupPolicyResponse {
    /**
     * proposals are the proposals with given group policy.
     * @type {Array<ProposalsByGroupPolicy200ResponseProposalsInner>}
     * @memberof CosmosGroupV1QueryProposalsByGroupPolicyResponse
     */
    'proposals'?: Array<ProposalsByGroupPolicy200ResponseProposalsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryProposalsByGroupPolicyResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryTallyResultResponse is the Query/TallyResult response type.
 * @export
 * @interface CosmosGroupV1QueryTallyResultResponse
 */
export interface CosmosGroupV1QueryTallyResultResponse {
    /**
     * 
     * @type {GroupTallyResult200ResponseTally}
     * @memberof CosmosGroupV1QueryTallyResultResponse
     */
    'tally'?: GroupTallyResult200ResponseTally;
}
/**
 * QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response type.
 * @export
 * @interface CosmosGroupV1QueryVoteByProposalVoterResponse
 */
export interface CosmosGroupV1QueryVoteByProposalVoterResponse {
    /**
     * 
     * @type {VoteByProposalVoter200ResponseVote}
     * @memberof CosmosGroupV1QueryVoteByProposalVoterResponse
     */
    'vote'?: VoteByProposalVoter200ResponseVote;
}
/**
 * QueryVotesByProposalResponse is the Query/VotesByProposal response type.
 * @export
 * @interface CosmosGroupV1QueryVotesByProposalResponse
 */
export interface CosmosGroupV1QueryVotesByProposalResponse {
    /**
     * votes are the list of votes for given proposal_id.
     * @type {Array<VotesByProposal200ResponseVotesInner>}
     * @memberof CosmosGroupV1QueryVotesByProposalResponse
     */
    'votes'?: Array<VotesByProposal200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryVotesByProposalResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryVotesByVoterResponse is the Query/VotesByVoter response type.
 * @export
 * @interface CosmosGroupV1QueryVotesByVoterResponse
 */
export interface CosmosGroupV1QueryVotesByVoterResponse {
    /**
     * votes are the list of votes by given voter.
     * @type {Array<VotesByProposal200ResponseVotesInner>}
     * @memberof CosmosGroupV1QueryVotesByVoterResponse
     */
    'votes'?: Array<VotesByProposal200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosGroupV1QueryVotesByVoterResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * TallyResult represents the sum of weighted votes for each vote option.
 * @export
 * @interface CosmosGroupV1TallyResult
 */
export interface CosmosGroupV1TallyResult {
    /**
     * yes_count is the weighted sum of yes votes.
     * @type {string}
     * @memberof CosmosGroupV1TallyResult
     */
    'yes_count'?: string;
    /**
     * abstain_count is the weighted sum of abstainers.
     * @type {string}
     * @memberof CosmosGroupV1TallyResult
     */
    'abstain_count'?: string;
    /**
     * no_count is the weighted sum of no votes.
     * @type {string}
     * @memberof CosmosGroupV1TallyResult
     */
    'no_count'?: string;
    /**
     * no_with_veto_count is the weighted sum of veto.
     * @type {string}
     * @memberof CosmosGroupV1TallyResult
     */
    'no_with_veto_count'?: string;
}
/**
 * Vote represents a vote for a proposal.
 * @export
 * @interface CosmosGroupV1Vote
 */
export interface CosmosGroupV1Vote {
    /**
     * proposal is the unique ID of the proposal.
     * @type {string}
     * @memberof CosmosGroupV1Vote
     */
    'proposal_id'?: string;
    /**
     * voter is the account address of the voter.
     * @type {string}
     * @memberof CosmosGroupV1Vote
     */
    'voter'?: string;
    /**
     * option is the voter\'s choice on the proposal.
     * @type {string}
     * @memberof CosmosGroupV1Vote
     */
    'option'?: CosmosGroupV1VoteOptionEnum;
    /**
     * metadata is any arbitrary metadata to attached to the vote.
     * @type {string}
     * @memberof CosmosGroupV1Vote
     */
    'metadata'?: string;
    /**
     * submit_time is the timestamp when the vote was submitted.
     * @type {string}
     * @memberof CosmosGroupV1Vote
     */
    'submit_time'?: string;
}

export const CosmosGroupV1VoteOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type CosmosGroupV1VoteOptionEnum = typeof CosmosGroupV1VoteOptionEnum[keyof typeof CosmosGroupV1VoteOptionEnum];

/**
 * VoteOption enumerates the valid vote options for a given proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will return an error.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @export
 * @enum {string}
 */

export const CosmosGroupV1VoteOption = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type CosmosGroupV1VoteOption = typeof CosmosGroupV1VoteOption[keyof typeof CosmosGroupV1VoteOption];


/**
 * Params holds parameters for the mint module.
 * @export
 * @interface CosmosMintV1beta1Params
 */
export interface CosmosMintV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    'mint_denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    'inflation_rate_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    'inflation_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    'inflation_min'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    'goal_bonded'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosMintV1beta1Params
     */
    'blocks_per_year'?: string;
}
/**
 * QueryAnnualProvisionsResponse is the response type for the Query/AnnualProvisions RPC method.
 * @export
 * @interface CosmosMintV1beta1QueryAnnualProvisionsResponse
 */
export interface CosmosMintV1beta1QueryAnnualProvisionsResponse {
    /**
     * annual_provisions is the current minting annual provisions value.
     * @type {string}
     * @memberof CosmosMintV1beta1QueryAnnualProvisionsResponse
     */
    'annual_provisions'?: string;
}
/**
 * QueryInflationResponse is the response type for the Query/Inflation RPC method.
 * @export
 * @interface CosmosMintV1beta1QueryInflationResponse
 */
export interface CosmosMintV1beta1QueryInflationResponse {
    /**
     * inflation is the current minting inflation value.
     * @type {string}
     * @memberof CosmosMintV1beta1QueryInflationResponse
     */
    'inflation'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface CosmosMintV1beta1QueryParamsResponse
 */
export interface CosmosMintV1beta1QueryParamsResponse {
    /**
     * 
     * @type {MintParams200ResponseParams}
     * @memberof CosmosMintV1beta1QueryParamsResponse
     */
    'params'?: MintParams200ResponseParams;
}
/**
 * Class defines the class of the nft type.
 * @export
 * @interface CosmosNftV1beta1Class
 */
export interface CosmosNftV1beta1Class {
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1Class
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1Class
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1Class
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1Class
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1Class
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1Class
     */
    'uri_hash'?: string;
    /**
     * 
     * @type {DataIsTheAppSpecificMetadataOfTheNFTClassOptional}
     * @memberof CosmosNftV1beta1Class
     */
    'data'?: DataIsTheAppSpecificMetadataOfTheNFTClassOptional;
}
/**
 * NFT defines the NFT.
 * @export
 * @interface CosmosNftV1beta1NFT
 */
export interface CosmosNftV1beta1NFT {
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1NFT
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1NFT
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1NFT
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1NFT
     */
    'uri_hash'?: string;
    /**
     * 
     * @type {DataIsAnAppSpecificDataOfTheNFTOptional}
     * @memberof CosmosNftV1beta1NFT
     */
    'data'?: DataIsAnAppSpecificDataOfTheNFTOptional;
}
/**
 * 
 * @export
 * @interface CosmosNftV1beta1QueryBalanceResponse
 */
export interface CosmosNftV1beta1QueryBalanceResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1QueryBalanceResponse
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface CosmosNftV1beta1QueryClassResponse
 */
export interface CosmosNftV1beta1QueryClassResponse {
    /**
     * 
     * @type {QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner}
     * @memberof CosmosNftV1beta1QueryClassResponse
     */
    'class'?: QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner;
}
/**
 * 
 * @export
 * @interface CosmosNftV1beta1QueryClassesResponse
 */
export interface CosmosNftV1beta1QueryClassesResponse {
    /**
     * 
     * @type {Array<QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner>}
     * @memberof CosmosNftV1beta1QueryClassesResponse
     */
    'classes'?: Array<QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof CosmosNftV1beta1QueryClassesResponse
     */
    'pagination'?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * 
 * @export
 * @interface CosmosNftV1beta1QueryNFTResponse
 */
export interface CosmosNftV1beta1QueryNFTResponse {
    /**
     * 
     * @type {QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner}
     * @memberof CosmosNftV1beta1QueryNFTResponse
     */
    'nft'?: QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner;
}
/**
 * 
 * @export
 * @interface CosmosNftV1beta1QueryNFTsResponse
 */
export interface CosmosNftV1beta1QueryNFTsResponse {
    /**
     * 
     * @type {Array<QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner>}
     * @memberof CosmosNftV1beta1QueryNFTsResponse
     */
    'nfts'?: Array<QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof CosmosNftV1beta1QueryNFTsResponse
     */
    'pagination'?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * 
 * @export
 * @interface CosmosNftV1beta1QueryOwnerResponse
 */
export interface CosmosNftV1beta1QueryOwnerResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1QueryOwnerResponse
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface CosmosNftV1beta1QuerySupplyResponse
 */
export interface CosmosNftV1beta1QuerySupplyResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosNftV1beta1QuerySupplyResponse
     */
    'amount'?: string;
}
/**
 * ParamChange defines an individual parameter change, for use in ParameterChangeProposal.
 * @export
 * @interface CosmosParamsV1beta1ParamChange
 */
export interface CosmosParamsV1beta1ParamChange {
    /**
     * 
     * @type {string}
     * @memberof CosmosParamsV1beta1ParamChange
     */
    'subspace'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosParamsV1beta1ParamChange
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosParamsV1beta1ParamChange
     */
    'value'?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface CosmosParamsV1beta1QueryParamsResponse
 */
export interface CosmosParamsV1beta1QueryParamsResponse {
    /**
     * 
     * @type {Params200ResponseParam}
     * @memberof CosmosParamsV1beta1QueryParamsResponse
     */
    'param'?: Params200ResponseParam;
}
/**
 * QuerySubspacesResponse defines the response types for querying for all registered subspaces and all keys for a subspace.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosParamsV1beta1QuerySubspacesResponse
 */
export interface CosmosParamsV1beta1QuerySubspacesResponse {
    /**
     * 
     * @type {Array<Subspaces200ResponseSubspacesInner>}
     * @memberof CosmosParamsV1beta1QuerySubspacesResponse
     */
    'subspaces'?: Array<Subspaces200ResponseSubspacesInner>;
}
/**
 * Subspace defines a parameter subspace name and all the keys that exist for the subspace.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosParamsV1beta1Subspace
 */
export interface CosmosParamsV1beta1Subspace {
    /**
     * 
     * @type {string}
     * @memberof CosmosParamsV1beta1Subspace
     */
    'subspace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CosmosParamsV1beta1Subspace
     */
    'keys'?: Array<string>;
}
/**
 * Params represents the parameters used for by the slashing module.
 * @export
 * @interface CosmosSlashingV1beta1Params
 */
export interface CosmosSlashingV1beta1Params {
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    'signed_blocks_window'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    'min_signed_per_window'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    'downtime_jail_duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    'slash_fraction_double_sign'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1Params
     */
    'slash_fraction_downtime'?: string;
}
/**
 * 
 * @export
 * @interface CosmosSlashingV1beta1QueryParamsResponse
 */
export interface CosmosSlashingV1beta1QueryParamsResponse {
    /**
     * 
     * @type {QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams}
     * @memberof CosmosSlashingV1beta1QueryParamsResponse
     */
    'params'?: QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams;
}
/**
 * 
 * @export
 * @interface CosmosSlashingV1beta1QuerySigningInfoResponse
 */
export interface CosmosSlashingV1beta1QuerySigningInfoResponse {
    /**
     * 
     * @type {ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress}
     * @memberof CosmosSlashingV1beta1QuerySigningInfoResponse
     */
    'val_signing_info'?: ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress;
}
/**
 * 
 * @export
 * @interface CosmosSlashingV1beta1QuerySigningInfosResponse
 */
export interface CosmosSlashingV1beta1QuerySigningInfosResponse {
    /**
     * 
     * @type {Array<InfoIsTheSigningInfoOfAllValidatorsInner>}
     * @memberof CosmosSlashingV1beta1QuerySigningInfosResponse
     */
    'info'?: Array<InfoIsTheSigningInfoOfAllValidatorsInner>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof CosmosSlashingV1beta1QuerySigningInfosResponse
     */
    'pagination'?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * ValidatorSigningInfo defines a validator\'s signing info for monitoring their liveness activity.
 * @export
 * @interface CosmosSlashingV1beta1ValidatorSigningInfo
 */
export interface CosmosSlashingV1beta1ValidatorSigningInfo {
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    'start_height'?: string;
    /**
     * Index which is incremented each time the validator was a bonded in a block and may have signed a precommit or not. This in conjunction with the `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    'index_offset'?: string;
    /**
     * Timestamp until which the validator is jailed due to liveness downtime.
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    'jailed_until'?: string;
    /**
     * Whether or not a validator has been tombstoned (killed out of validator set). It is set once the validator commits an equivocation or for any other configured misbehiavor.
     * @type {boolean}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    'tombstoned'?: boolean;
    /**
     * A counter kept to avoid unnecessary array reads. Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
     * @type {string}
     * @memberof CosmosSlashingV1beta1ValidatorSigningInfo
     */
    'missed_blocks_counter'?: string;
}
/**
 * BondStatus is the status of a validator.   - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
 * @export
 * @enum {string}
 */

export const CosmosStakingV1beta1BondStatus = {
    Unspecified: 'BOND_STATUS_UNSPECIFIED',
    Unbonded: 'BOND_STATUS_UNBONDED',
    Unbonding: 'BOND_STATUS_UNBONDING',
    Bonded: 'BOND_STATUS_BONDED'
} as const;

export type CosmosStakingV1beta1BondStatus = typeof CosmosStakingV1beta1BondStatus[keyof typeof CosmosStakingV1beta1BondStatus];


/**
 * Commission defines commission parameters for a given validator.
 * @export
 * @interface CosmosStakingV1beta1Commission
 */
export interface CosmosStakingV1beta1Commission {
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates}
     * @memberof CosmosStakingV1beta1Commission
     */
    'commission_rates'?: StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates;
    /**
     * update_time is the last time the commission rate was changed.
     * @type {string}
     * @memberof CosmosStakingV1beta1Commission
     */
    'update_time'?: string;
}
/**
 * CommissionRates defines the initial commission rates to be used for creating a validator.
 * @export
 * @interface CosmosStakingV1beta1CommissionRates
 */
export interface CosmosStakingV1beta1CommissionRates {
    /**
     * rate is the commission rate charged to delegators, as a fraction.
     * @type {string}
     * @memberof CosmosStakingV1beta1CommissionRates
     */
    'rate'?: string;
    /**
     * max_rate defines the maximum commission rate which validator can ever charge, as a fraction.
     * @type {string}
     * @memberof CosmosStakingV1beta1CommissionRates
     */
    'max_rate'?: string;
    /**
     * max_change_rate defines the maximum daily increase of the validator commission, as a fraction.
     * @type {string}
     * @memberof CosmosStakingV1beta1CommissionRates
     */
    'max_change_rate'?: string;
}
/**
 * Delegation represents the bond with tokens held by an account. It is owned by one delegator, and is associated with the voting power of one validator.
 * @export
 * @interface CosmosStakingV1beta1Delegation
 */
export interface CosmosStakingV1beta1Delegation {
    /**
     * delegator_address is the bech32-encoded address of the delegator.
     * @type {string}
     * @memberof CosmosStakingV1beta1Delegation
     */
    'delegator_address'?: string;
    /**
     * validator_address is the bech32-encoded address of the validator.
     * @type {string}
     * @memberof CosmosStakingV1beta1Delegation
     */
    'validator_address'?: string;
    /**
     * shares define the delegation shares received.
     * @type {string}
     * @memberof CosmosStakingV1beta1Delegation
     */
    'shares'?: string;
}
/**
 * DelegationResponse is equivalent to Delegation except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface CosmosStakingV1beta1DelegationResponse
 */
export interface CosmosStakingV1beta1DelegationResponse {
    /**
     * 
     * @type {DelegatorDelegations200ResponseDelegationResponsesInnerDelegation}
     * @memberof CosmosStakingV1beta1DelegationResponse
     */
    'delegation'?: DelegatorDelegations200ResponseDelegationResponsesInnerDelegation;
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof CosmosStakingV1beta1DelegationResponse
     */
    'balance'?: AllBalances200ResponseBalancesInner;
}
/**
 * Description defines a validator description.
 * @export
 * @interface CosmosStakingV1beta1Description
 */
export interface CosmosStakingV1beta1Description {
    /**
     * moniker defines a human-readable name for the validator.
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    'moniker'?: string;
    /**
     * identity defines an optional identity signature (ex. UPort or Keybase).
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    'identity'?: string;
    /**
     * website defines an optional website link.
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    'website'?: string;
    /**
     * security_contact defines an optional email for security contact.
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    'security_contact'?: string;
    /**
     * details define other optional details.
     * @type {string}
     * @memberof CosmosStakingV1beta1Description
     */
    'details'?: string;
}
/**
 * HistoricalInfo contains header and validator information for a given block. It is stored as part of staking module\'s state, which persists the `n` most recent HistoricalInfo (`n` is set by the staking module\'s `historical_entries` parameter).
 * @export
 * @interface CosmosStakingV1beta1HistoricalInfo
 */
export interface CosmosStakingV1beta1HistoricalInfo {
    /**
     * 
     * @type {HistoricalInfo200ResponseHistHeader}
     * @memberof CosmosStakingV1beta1HistoricalInfo
     */
    'header'?: HistoricalInfo200ResponseHistHeader;
    /**
     * 
     * @type {Array<StakingDelegatorValidators200ResponseValidatorsInner>}
     * @memberof CosmosStakingV1beta1HistoricalInfo
     */
    'valset'?: Array<StakingDelegatorValidators200ResponseValidatorsInner>;
}
/**
 * Params defines the parameters for the staking module.
 * @export
 * @interface CosmosStakingV1beta1Params
 */
export interface CosmosStakingV1beta1Params {
    /**
     * unbonding_time is the time duration of unbonding.
     * @type {string}
     * @memberof CosmosStakingV1beta1Params
     */
    'unbonding_time'?: string;
    /**
     * max_validators is the maximum number of validators.
     * @type {number}
     * @memberof CosmosStakingV1beta1Params
     */
    'max_validators'?: number;
    /**
     * max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
     * @type {number}
     * @memberof CosmosStakingV1beta1Params
     */
    'max_entries'?: number;
    /**
     * historical_entries is the number of historical entries to persist.
     * @type {number}
     * @memberof CosmosStakingV1beta1Params
     */
    'historical_entries'?: number;
    /**
     * bond_denom defines the bondable coin denomination.
     * @type {string}
     * @memberof CosmosStakingV1beta1Params
     */
    'bond_denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Params
     */
    'min_commission_rate'?: string;
}
/**
 * Pool is used for tracking bonded and not-bonded token supply of the bond denomination.
 * @export
 * @interface CosmosStakingV1beta1Pool
 */
export interface CosmosStakingV1beta1Pool {
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Pool
     */
    'not_bonded_tokens'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1Pool
     */
    'bonded_tokens'?: string;
}
/**
 * QueryDelegationResponse is response type for the Query/Delegation RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegationResponse
 */
export interface CosmosStakingV1beta1QueryDelegationResponse {
    /**
     * 
     * @type {DelegatorDelegations200ResponseDelegationResponsesInner}
     * @memberof CosmosStakingV1beta1QueryDelegationResponse
     */
    'delegation_response'?: DelegatorDelegations200ResponseDelegationResponsesInner;
}
/**
 * QueryDelegatorDelegationsResponse is response type for the Query/DelegatorDelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorDelegationsResponse {
    /**
     * delegation_responses defines all the delegations\' info of a delegator.
     * @type {Array<DelegatorDelegations200ResponseDelegationResponsesInner>}
     * @memberof CosmosStakingV1beta1QueryDelegatorDelegationsResponse
     */
    'delegation_responses'?: Array<DelegatorDelegations200ResponseDelegationResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosStakingV1beta1QueryDelegatorDelegationsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the Query/UnbondingDelegatorDelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse {
    /**
     * 
     * @type {Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>}
     * @memberof CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse
     */
    'unbonding_responses'?: Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosStakingV1beta1QueryDelegatorUnbondingDelegationsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryDelegatorValidatorResponse response type for the Query/DelegatorValidator RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorValidatorResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorValidatorResponse {
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInner}
     * @memberof CosmosStakingV1beta1QueryDelegatorValidatorResponse
     */
    'validator'?: StakingDelegatorValidators200ResponseValidatorsInner;
}
/**
 * QueryDelegatorValidatorsResponse is response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryDelegatorValidatorsResponse
 */
export interface CosmosStakingV1beta1QueryDelegatorValidatorsResponse {
    /**
     * validators defines the validators\' info of a delegator.
     * @type {Array<StakingDelegatorValidators200ResponseValidatorsInner>}
     * @memberof CosmosStakingV1beta1QueryDelegatorValidatorsResponse
     */
    'validators'?: Array<StakingDelegatorValidators200ResponseValidatorsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosStakingV1beta1QueryDelegatorValidatorsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryHistoricalInfoResponse
 */
export interface CosmosStakingV1beta1QueryHistoricalInfoResponse {
    /**
     * 
     * @type {HistoricalInfo200ResponseHist}
     * @memberof CosmosStakingV1beta1QueryHistoricalInfoResponse
     */
    'hist'?: HistoricalInfo200ResponseHist;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryParamsResponse
 */
export interface CosmosStakingV1beta1QueryParamsResponse {
    /**
     * 
     * @type {StakingParams200ResponseParams}
     * @memberof CosmosStakingV1beta1QueryParamsResponse
     */
    'params'?: StakingParams200ResponseParams;
}
/**
 * QueryPoolResponse is response type for the Query/Pool RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryPoolResponse
 */
export interface CosmosStakingV1beta1QueryPoolResponse {
    /**
     * 
     * @type {Pool200ResponsePool}
     * @memberof CosmosStakingV1beta1QueryPoolResponse
     */
    'pool'?: Pool200ResponsePool;
}
/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryRedelegationsResponse
 */
export interface CosmosStakingV1beta1QueryRedelegationsResponse {
    /**
     * 
     * @type {Array<Redelegations200ResponseRedelegationResponsesInner>}
     * @memberof CosmosStakingV1beta1QueryRedelegationsResponse
     */
    'redelegation_responses'?: Array<Redelegations200ResponseRedelegationResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosStakingV1beta1QueryRedelegationsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryDelegationResponse is response type for the Query/UnbondingDelegation RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryUnbondingDelegationResponse
 */
export interface CosmosStakingV1beta1QueryUnbondingDelegationResponse {
    /**
     * 
     * @type {DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner}
     * @memberof CosmosStakingV1beta1QueryUnbondingDelegationResponse
     */
    'unbond'?: DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner;
}
/**
 * 
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryValidatorDelegationsResponse {
    /**
     * 
     * @type {Array<DelegatorDelegations200ResponseDelegationResponsesInner>}
     * @memberof CosmosStakingV1beta1QueryValidatorDelegationsResponse
     */
    'delegation_responses'?: Array<DelegatorDelegations200ResponseDelegationResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosStakingV1beta1QueryValidatorDelegationsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * 
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorResponse
 */
export interface CosmosStakingV1beta1QueryValidatorResponse {
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInner}
     * @memberof CosmosStakingV1beta1QueryValidatorResponse
     */
    'validator'?: StakingDelegatorValidators200ResponseValidatorsInner;
}
/**
 * QueryValidatorUnbondingDelegationsResponse is response type for the Query/ValidatorUnbondingDelegations RPC method.
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse
 */
export interface CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse {
    /**
     * 
     * @type {Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>}
     * @memberof CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse
     */
    'unbonding_responses'?: Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosStakingV1beta1QueryValidatorUnbondingDelegationsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * 
 * @export
 * @interface CosmosStakingV1beta1QueryValidatorsResponse
 */
export interface CosmosStakingV1beta1QueryValidatorsResponse {
    /**
     * validators contains all the queried validators.
     * @type {Array<StakingDelegatorValidators200ResponseValidatorsInner>}
     * @memberof CosmosStakingV1beta1QueryValidatorsResponse
     */
    'validators'?: Array<StakingDelegatorValidators200ResponseValidatorsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof CosmosStakingV1beta1QueryValidatorsResponse
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Redelegation contains the list of a particular delegator\'s redelegating bonds from a particular source validator to a particular destination validator.
 * @export
 * @interface CosmosStakingV1beta1Redelegation
 */
export interface CosmosStakingV1beta1Redelegation {
    /**
     * delegator_address is the bech32-encoded address of the delegator.
     * @type {string}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    'delegator_address'?: string;
    /**
     * validator_src_address is the validator redelegation source operator address.
     * @type {string}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    'validator_src_address'?: string;
    /**
     * validator_dst_address is the validator redelegation destination operator address.
     * @type {string}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    'validator_dst_address'?: string;
    /**
     * entries are the redelegation entries.
     * @type {Array<Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner>}
     * @memberof CosmosStakingV1beta1Redelegation
     */
    'entries'?: Array<Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner>;
}
/**
 * RedelegationEntry defines a redelegation object with relevant metadata.
 * @export
 * @interface CosmosStakingV1beta1RedelegationEntry
 */
export interface CosmosStakingV1beta1RedelegationEntry {
    /**
     * creation_height  defines the height which the redelegation took place.
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    'creation_height'?: string;
    /**
     * completion_time defines the unix time for redelegation completion.
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    'completion_time'?: string;
    /**
     * initial_balance defines the initial balance when redelegation started.
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    'initial_balance'?: string;
    /**
     * shares_dst is the amount of destination-validator shares created by redelegation.
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntry
     */
    'shares_dst'?: string;
}
/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface CosmosStakingV1beta1RedelegationEntryResponse
 */
export interface CosmosStakingV1beta1RedelegationEntryResponse {
    /**
     * 
     * @type {Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner}
     * @memberof CosmosStakingV1beta1RedelegationEntryResponse
     */
    'redelegation_entry'?: Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner;
    /**
     * 
     * @type {string}
     * @memberof CosmosStakingV1beta1RedelegationEntryResponse
     */
    'balance'?: string;
}
/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries contain a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface CosmosStakingV1beta1RedelegationResponse
 */
export interface CosmosStakingV1beta1RedelegationResponse {
    /**
     * 
     * @type {Redelegations200ResponseRedelegationResponsesInnerRedelegation}
     * @memberof CosmosStakingV1beta1RedelegationResponse
     */
    'redelegation'?: Redelegations200ResponseRedelegationResponsesInnerRedelegation;
    /**
     * 
     * @type {Array<Redelegations200ResponseRedelegationResponsesInnerEntriesInner>}
     * @memberof CosmosStakingV1beta1RedelegationResponse
     */
    'entries'?: Array<Redelegations200ResponseRedelegationResponsesInnerEntriesInner>;
}
/**
 * UnbondingDelegation stores all of a single delegator\'s unbonding bonds for a single validator in an time-ordered list.
 * @export
 * @interface CosmosStakingV1beta1UnbondingDelegation
 */
export interface CosmosStakingV1beta1UnbondingDelegation {
    /**
     * delegator_address is the bech32-encoded address of the delegator.
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegation
     */
    'delegator_address'?: string;
    /**
     * validator_address is the bech32-encoded address of the validator.
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegation
     */
    'validator_address'?: string;
    /**
     * entries are the unbonding delegation entries.
     * @type {Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner>}
     * @memberof CosmosStakingV1beta1UnbondingDelegation
     */
    'entries'?: Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner>;
}
/**
 * UnbondingDelegationEntry defines an unbonding object with relevant metadata.
 * @export
 * @interface CosmosStakingV1beta1UnbondingDelegationEntry
 */
export interface CosmosStakingV1beta1UnbondingDelegationEntry {
    /**
     * creation_height is the height which the unbonding took place.
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    'creation_height'?: string;
    /**
     * completion_time is the unix time for unbonding completion.
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    'completion_time'?: string;
    /**
     * initial_balance defines the tokens initially scheduled to receive at completion.
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    'initial_balance'?: string;
    /**
     * balance defines the tokens to receive at completion.
     * @type {string}
     * @memberof CosmosStakingV1beta1UnbondingDelegationEntry
     */
    'balance'?: string;
}
/**
 * Validator defines a validator, together with the total amount of the Validator\'s bond shares and their exchange rate to coins. Slashing results in a decrease in the exchange rate, allowing correct calculation of future undelegations without iterating over delegators. When coins are delegated to this validator, the validator is credited with a delegation whose number of bond shares is based on the amount of coins delegated divided by the current exchange rate. Voting power can be calculated as total bonded shares multiplied by exchange rate.
 * @export
 * @interface CosmosStakingV1beta1Validator
 */
export interface CosmosStakingV1beta1Validator {
    /**
     * operator_address defines the address of the validator\'s operator; bech encoded in JSON.
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    'operator_address'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosStakingV1beta1Validator
     */
    'consensus_pubkey'?: AccountsAreTheExistingAccountsInner;
    /**
     * jailed defined whether the validator has been jailed from bonded status or not.
     * @type {boolean}
     * @memberof CosmosStakingV1beta1Validator
     */
    'jailed'?: boolean;
    /**
     * status is the validator status (bonded/unbonding/unbonded).
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    'status'?: CosmosStakingV1beta1ValidatorStatusEnum;
    /**
     * tokens define the delegated tokens (incl. self-delegation).
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    'tokens'?: string;
    /**
     * delegator_shares defines total shares issued to a validator\'s delegators.
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    'delegator_shares'?: string;
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInnerDescription}
     * @memberof CosmosStakingV1beta1Validator
     */
    'description'?: StakingDelegatorValidators200ResponseValidatorsInnerDescription;
    /**
     * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    'unbonding_height'?: string;
    /**
     * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    'unbonding_time'?: string;
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInnerCommission}
     * @memberof CosmosStakingV1beta1Validator
     */
    'commission'?: StakingDelegatorValidators200ResponseValidatorsInnerCommission;
    /**
     * min_self_delegation is the validator\'s self declared minimum self delegation.  Since: cosmos-sdk 0.46
     * @type {string}
     * @memberof CosmosStakingV1beta1Validator
     */
    'min_self_delegation'?: string;
}

export const CosmosStakingV1beta1ValidatorStatusEnum = {
    Unspecified: 'BOND_STATUS_UNSPECIFIED',
    Unbonded: 'BOND_STATUS_UNBONDED',
    Unbonding: 'BOND_STATUS_UNBONDING',
    Bonded: 'BOND_STATUS_BONDED'
} as const;

export type CosmosStakingV1beta1ValidatorStatusEnum = typeof CosmosStakingV1beta1ValidatorStatusEnum[keyof typeof CosmosStakingV1beta1ValidatorStatusEnum];

/**
 * SignMode represents a signing mode with its own security guarantees.  This enum should be considered a registry of all known sign modes in the Cosmos ecosystem. Apps are not expected to support all known sign modes. Apps that would like to support custom  sign modes are encouraged to open a small PR against this file to add a new case to this SignMode enum describing their sign mode so that different apps have a consistent version of this enum.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected.  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx.  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT. It is currently not supported.  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not require signers signing over other signers\' `signer_info`. It also allows for adding Tips in transactions.  Since: cosmos-sdk 0.46  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future.  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos SDK. Ref: https://eips.ethereum.org/EIPS/eip-191  Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant, but is not implemented on the SDK by default. To enable EIP-191, you need to pass a custom `TxConfig` that has an implementation of `SignModeHandler` for EIP-191. The SDK may decide to fully support EIP-191 in the future.  Since: cosmos-sdk 0.45.2
 * @export
 * @enum {string}
 */

export const CosmosTxSigningV1beta1SignMode = {
    Unspecified: 'SIGN_MODE_UNSPECIFIED',
    Direct: 'SIGN_MODE_DIRECT',
    Textual: 'SIGN_MODE_TEXTUAL',
    DirectAux: 'SIGN_MODE_DIRECT_AUX',
    LegacyAminoJson: 'SIGN_MODE_LEGACY_AMINO_JSON',
    Eip191: 'SIGN_MODE_EIP_191'
} as const;

export type CosmosTxSigningV1beta1SignMode = typeof CosmosTxSigningV1beta1SignMode[keyof typeof CosmosTxSigningV1beta1SignMode];


/**
 * AuthInfo describes the fee and signer modes that are used to sign a transaction.
 * @export
 * @interface CosmosTxV1beta1AuthInfo
 */
export interface CosmosTxV1beta1AuthInfo {
    /**
     * signer_infos defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody\'s messages. The first element is the primary signer and the one which pays the fee.
     * @type {Array<CosmosTxV1beta1SignerInfo>}
     * @memberof CosmosTxV1beta1AuthInfo
     */
    'signer_infos'?: Array<CosmosTxV1beta1SignerInfo>;
    /**
     * 
     * @type {CosmosTxV1beta1AuthInfoFee}
     * @memberof CosmosTxV1beta1AuthInfo
     */
    'fee'?: CosmosTxV1beta1AuthInfoFee;
    /**
     * 
     * @type {CosmosTxV1beta1AuthInfoTip}
     * @memberof CosmosTxV1beta1AuthInfo
     */
    'tip'?: CosmosTxV1beta1AuthInfoTip;
}
/**
 * Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation.
 * @export
 * @interface CosmosTxV1beta1AuthInfoFee
 */
export interface CosmosTxV1beta1AuthInfoFee {
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    'amount'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    'gas_limit'?: string;
    /**
     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    'payer'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1AuthInfoFee
     */
    'granter'?: string;
}
/**
 * Tip is the optional tip used for transactions fees paid in another denom.  This field is ignored if the chain didn\'t enable tips, i.e. didn\'t add the `TipDecorator` in its posthandler.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosTxV1beta1AuthInfoTip
 */
export interface CosmosTxV1beta1AuthInfoTip {
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosTxV1beta1AuthInfoTip
     */
    'amount'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1AuthInfoTip
     */
    'tipper'?: string;
}
/**
 * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
 * @export
 * @enum {string}
 */

export const CosmosTxV1beta1BroadcastMode = {
    Unspecified: 'BROADCAST_MODE_UNSPECIFIED',
    Block: 'BROADCAST_MODE_BLOCK',
    Sync: 'BROADCAST_MODE_SYNC',
    Async: 'BROADCAST_MODE_ASYNC'
} as const;

export type CosmosTxV1beta1BroadcastMode = typeof CosmosTxV1beta1BroadcastMode[keyof typeof CosmosTxV1beta1BroadcastMode];


/**
 * BroadcastTxRequest is the request type for the Service.BroadcastTxRequest RPC method.
 * @export
 * @interface CosmosTxV1beta1BroadcastTxRequest
 */
export interface CosmosTxV1beta1BroadcastTxRequest {
    /**
     * tx_bytes is the raw transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1BroadcastTxRequest
     */
    'tx_bytes'?: string;
    /**
     * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
     * @type {string}
     * @memberof CosmosTxV1beta1BroadcastTxRequest
     */
    'mode'?: CosmosTxV1beta1BroadcastTxRequestModeEnum;
}

export const CosmosTxV1beta1BroadcastTxRequestModeEnum = {
    Unspecified: 'BROADCAST_MODE_UNSPECIFIED',
    Block: 'BROADCAST_MODE_BLOCK',
    Sync: 'BROADCAST_MODE_SYNC',
    Async: 'BROADCAST_MODE_ASYNC'
} as const;

export type CosmosTxV1beta1BroadcastTxRequestModeEnum = typeof CosmosTxV1beta1BroadcastTxRequestModeEnum[keyof typeof CosmosTxV1beta1BroadcastTxRequestModeEnum];

/**
 * BroadcastTxResponse is the response type for the Service.BroadcastTx method.
 * @export
 * @interface CosmosTxV1beta1BroadcastTxResponse
 */
export interface CosmosTxV1beta1BroadcastTxResponse {
    /**
     * 
     * @type {BroadcastTx200ResponseTxResponse}
     * @memberof CosmosTxV1beta1BroadcastTxResponse
     */
    'tx_response'?: BroadcastTx200ResponseTxResponse;
}
/**
 * Fee includes the amount of coins paid in fees and the maximum gas to be used by the transaction. The ratio yields an effective \"gasprice\", which must be above some miminum to be accepted into the mempool.
 * @export
 * @interface CosmosTxV1beta1Fee
 */
export interface CosmosTxV1beta1Fee {
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosTxV1beta1Fee
     */
    'amount'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1Fee
     */
    'gas_limit'?: string;
    /**
     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
     * @type {string}
     * @memberof CosmosTxV1beta1Fee
     */
    'payer'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1Fee
     */
    'granter'?: string;
}
/**
 * GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs method.  Since: cosmos-sdk 0.45.2
 * @export
 * @interface CosmosTxV1beta1GetBlockWithTxsResponse
 */
export interface CosmosTxV1beta1GetBlockWithTxsResponse {
    /**
     * txs are the transactions in the block.
     * @type {Array<CosmosTxV1beta1Tx>}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponse
     */
    'txs'?: Array<CosmosTxV1beta1Tx>;
    /**
     * 
     * @type {BlockID}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponse
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {CosmosTxV1beta1GetBlockWithTxsResponseBlock}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponse
     */
    'block'?: CosmosTxV1beta1GetBlockWithTxsResponseBlock;
    /**
     * 
     * @type {CosmosTxV1beta1GetBlockWithTxsResponsePagination}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponse
     */
    'pagination'?: CosmosTxV1beta1GetBlockWithTxsResponsePagination;
}
/**
 * 
 * @export
 * @interface CosmosTxV1beta1GetBlockWithTxsResponseBlock
 */
export interface CosmosTxV1beta1GetBlockWithTxsResponseBlock {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadHeader}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponseBlock
     */
    'header'?: DeprecatedPleaseUseSdkBlockInsteadHeader;
    /**
     * 
     * @type {DataContainsTheSetOfTransactionsIncludedInTheBlock}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponseBlock
     */
    'data'?: DataContainsTheSetOfTransactionsIncludedInTheBlock;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidence}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponseBlock
     */
    'evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidence;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponseBlock
     */
    'last_commit'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * pagination defines a pagination for the response.
 * @export
 * @interface CosmosTxV1beta1GetBlockWithTxsResponsePagination
 */
export interface CosmosTxV1beta1GetBlockWithTxsResponsePagination {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponsePagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1GetBlockWithTxsResponsePagination
     */
    'total'?: string;
}
/**
 * GetTxResponse is the response type for the Service.GetTx method.
 * @export
 * @interface CosmosTxV1beta1GetTxResponse
 */
export interface CosmosTxV1beta1GetTxResponse {
    /**
     * 
     * @type {CosmosTxV1beta1Tx}
     * @memberof CosmosTxV1beta1GetTxResponse
     */
    'tx'?: CosmosTxV1beta1Tx;
    /**
     * 
     * @type {BroadcastTx200ResponseTxResponse}
     * @memberof CosmosTxV1beta1GetTxResponse
     */
    'tx_response'?: BroadcastTx200ResponseTxResponse;
}
/**
 * GetTxsEventResponse is the response type for the Service.TxsByEvents RPC method.
 * @export
 * @interface CosmosTxV1beta1GetTxsEventResponse
 */
export interface CosmosTxV1beta1GetTxsEventResponse {
    /**
     * txs is the list of queried transactions.
     * @type {Array<CosmosTxV1beta1Tx>}
     * @memberof CosmosTxV1beta1GetTxsEventResponse
     */
    'txs'?: Array<CosmosTxV1beta1Tx>;
    /**
     * tx_responses is the list of queried TxResponses.
     * @type {Array<BroadcastTx200ResponseTxResponse>}
     * @memberof CosmosTxV1beta1GetTxsEventResponse
     */
    'tx_responses'?: Array<BroadcastTx200ResponseTxResponse>;
    /**
     * 
     * @type {CosmosTxV1beta1GetTxsEventResponsePagination}
     * @memberof CosmosTxV1beta1GetTxsEventResponse
     */
    'pagination'?: CosmosTxV1beta1GetTxsEventResponsePagination;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponse
     */
    'total'?: string;
}
/**
 * pagination defines a pagination for the response. Deprecated post v0.46.x: use total instead.
 * @export
 * @interface CosmosTxV1beta1GetTxsEventResponsePagination
 */
export interface CosmosTxV1beta1GetTxsEventResponsePagination {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponsePagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1GetTxsEventResponsePagination
     */
    'total'?: string;
}
/**
 * ModeInfo describes the signing mode of a single or nested multisig signer.
 * @export
 * @interface CosmosTxV1beta1ModeInfo
 */
export interface CosmosTxV1beta1ModeInfo {
    /**
     * 
     * @type {SingleRepresentsASingleSigner}
     * @memberof CosmosTxV1beta1ModeInfo
     */
    'single'?: SingleRepresentsASingleSigner;
    /**
     * 
     * @type {CosmosTxV1beta1ModeInfoMulti}
     * @memberof CosmosTxV1beta1ModeInfo
     */
    'multi'?: CosmosTxV1beta1ModeInfoMulti;
}
/**
 * 
 * @export
 * @interface CosmosTxV1beta1ModeInfoMulti
 */
export interface CosmosTxV1beta1ModeInfoMulti {
    /**
     * 
     * @type {BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning}
     * @memberof CosmosTxV1beta1ModeInfoMulti
     */
    'bitarray'?: BitarraySpecifiesWhichKeysWithinTheMultisigAreSigning;
    /**
     * 
     * @type {Array<CosmosTxV1beta1ModeInfo>}
     * @memberof CosmosTxV1beta1ModeInfoMulti
     */
    'mode_infos'?: Array<CosmosTxV1beta1ModeInfo>;
}
/**
 * 
 * @export
 * @interface CosmosTxV1beta1ModeInfoSingle
 */
export interface CosmosTxV1beta1ModeInfoSingle {
    /**
     * SignMode represents a signing mode with its own security guarantees.  This enum should be considered a registry of all known sign modes in the Cosmos ecosystem. Apps are not expected to support all known sign modes. Apps that would like to support custom  sign modes are encouraged to open a small PR against this file to add a new case to this SignMode enum describing their sign mode so that different apps have a consistent version of this enum.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected.  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx.  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT. It is currently not supported.  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not require signers signing over other signers\' `signer_info`. It also allows for adding Tips in transactions.  Since: cosmos-sdk 0.46  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future.  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos SDK. Ref: https://eips.ethereum.org/EIPS/eip-191  Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant, but is not implemented on the SDK by default. To enable EIP-191, you need to pass a custom `TxConfig` that has an implementation of `SignModeHandler` for EIP-191. The SDK may decide to fully support EIP-191 in the future.  Since: cosmos-sdk 0.45.2
     * @type {string}
     * @memberof CosmosTxV1beta1ModeInfoSingle
     */
    'mode'?: CosmosTxV1beta1ModeInfoSingleModeEnum;
}

export const CosmosTxV1beta1ModeInfoSingleModeEnum = {
    Unspecified: 'SIGN_MODE_UNSPECIFIED',
    Direct: 'SIGN_MODE_DIRECT',
    Textual: 'SIGN_MODE_TEXTUAL',
    DirectAux: 'SIGN_MODE_DIRECT_AUX',
    LegacyAminoJson: 'SIGN_MODE_LEGACY_AMINO_JSON',
    Eip191: 'SIGN_MODE_EIP_191'
} as const;

export type CosmosTxV1beta1ModeInfoSingleModeEnum = typeof CosmosTxV1beta1ModeInfoSingleModeEnum[keyof typeof CosmosTxV1beta1ModeInfoSingleModeEnum];

/**
 * - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
 * @export
 * @enum {string}
 */

export const CosmosTxV1beta1OrderBy = {
    Unspecified: 'ORDER_BY_UNSPECIFIED',
    Asc: 'ORDER_BY_ASC',
    Desc: 'ORDER_BY_DESC'
} as const;

export type CosmosTxV1beta1OrderBy = typeof CosmosTxV1beta1OrderBy[keyof typeof CosmosTxV1beta1OrderBy];


/**
 * SignerInfo describes the public key and signing mode of a single top-level signer.
 * @export
 * @interface CosmosTxV1beta1SignerInfo
 */
export interface CosmosTxV1beta1SignerInfo {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosTxV1beta1SignerInfo
     */
    'public_key'?: AccountsAreTheExistingAccountsInner;
    /**
     * 
     * @type {CosmosTxV1beta1ModeInfo}
     * @memberof CosmosTxV1beta1SignerInfo
     */
    'mode_info'?: CosmosTxV1beta1ModeInfo;
    /**
     * sequence is the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.
     * @type {string}
     * @memberof CosmosTxV1beta1SignerInfo
     */
    'sequence'?: string;
}
/**
 * SimulateRequest is the request type for the Service.Simulate RPC method.
 * @export
 * @interface CosmosTxV1beta1SimulateRequest
 */
export interface CosmosTxV1beta1SimulateRequest {
    /**
     * 
     * @type {CosmosTxV1beta1Tx}
     * @memberof CosmosTxV1beta1SimulateRequest
     */
    'tx'?: CosmosTxV1beta1Tx;
    /**
     * tx_bytes is the raw transaction.  Since: cosmos-sdk 0.43
     * @type {string}
     * @memberof CosmosTxV1beta1SimulateRequest
     */
    'tx_bytes'?: string;
}
/**
 * SimulateResponse is the response type for the Service.SimulateRPC method.
 * @export
 * @interface CosmosTxV1beta1SimulateResponse
 */
export interface CosmosTxV1beta1SimulateResponse {
    /**
     * 
     * @type {Simulate200ResponseGasInfo}
     * @memberof CosmosTxV1beta1SimulateResponse
     */
    'gas_info'?: Simulate200ResponseGasInfo;
    /**
     * 
     * @type {Simulate200ResponseResult}
     * @memberof CosmosTxV1beta1SimulateResponse
     */
    'result'?: Simulate200ResponseResult;
}
/**
 * Tip is the tip used for meta-transactions.  Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosTxV1beta1Tip
 */
export interface CosmosTxV1beta1Tip {
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof CosmosTxV1beta1Tip
     */
    'amount'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1Tip
     */
    'tipper'?: string;
}
/**
 * Tx is the standard type used for broadcasting transactions.
 * @export
 * @interface CosmosTxV1beta1Tx
 */
export interface CosmosTxV1beta1Tx {
    /**
     * 
     * @type {BodyIsTheProcessableContentOfTheTransaction}
     * @memberof CosmosTxV1beta1Tx
     */
    'body'?: BodyIsTheProcessableContentOfTheTransaction;
    /**
     * 
     * @type {CosmosTxV1beta1AuthInfo}
     * @memberof CosmosTxV1beta1Tx
     */
    'auth_info'?: CosmosTxV1beta1AuthInfo;
    /**
     * signatures is a list of signatures that matches the length and order of AuthInfo\'s signer_infos to allow connecting signature meta information like public key and signing mode by position.
     * @type {Array<string>}
     * @memberof CosmosTxV1beta1Tx
     */
    'signatures'?: Array<string>;
}
/**
 * TxBody is the body of a transaction that all signers sign over.
 * @export
 * @interface CosmosTxV1beta1TxBody
 */
export interface CosmosTxV1beta1TxBody {
    /**
     * messages is a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo\'s signer_infos and Tx\'s signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosTxV1beta1TxBody
     */
    'messages'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * memo is any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
     * @type {string}
     * @memberof CosmosTxV1beta1TxBody
     */
    'memo'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosTxV1beta1TxBody
     */
    'timeout_height'?: string;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosTxV1beta1TxBody
     */
    'extension_options'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof CosmosTxV1beta1TxBody
     */
    'non_critical_extension_options'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * ModuleVersion specifies a module and its consensus version.  Since: cosmos-sdk 0.43
 * @export
 * @interface CosmosUpgradeV1beta1ModuleVersion
 */
export interface CosmosUpgradeV1beta1ModuleVersion {
    /**
     * 
     * @type {string}
     * @memberof CosmosUpgradeV1beta1ModuleVersion
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosUpgradeV1beta1ModuleVersion
     */
    'version'?: string;
}
/**
 * Plan specifies information about a planned upgrade and when it should occur.
 * @export
 * @interface CosmosUpgradeV1beta1Plan
 */
export interface CosmosUpgradeV1beta1Plan {
    /**
     * Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    'name'?: string;
    /**
     * Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    'time'?: string;
    /**
     * The height at which the upgrade must be performed. Only used if Time is not set.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    'info'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CosmosUpgradeV1beta1Plan
     */
    'upgraded_client_state'?: AccountsAreTheExistingAccountsInner;
}
/**
 * QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC method.
 * @export
 * @interface CosmosUpgradeV1beta1QueryAppliedPlanResponse
 */
export interface CosmosUpgradeV1beta1QueryAppliedPlanResponse {
    /**
     * height is the block height at which the plan was applied.
     * @type {string}
     * @memberof CosmosUpgradeV1beta1QueryAppliedPlanResponse
     */
    'height'?: string;
}
/**
 * Since: cosmos-sdk 0.46
 * @export
 * @interface CosmosUpgradeV1beta1QueryAuthorityResponse
 */
export interface CosmosUpgradeV1beta1QueryAuthorityResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosUpgradeV1beta1QueryAuthorityResponse
     */
    'address'?: string;
}
/**
 * QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC method.
 * @export
 * @interface CosmosUpgradeV1beta1QueryCurrentPlanResponse
 */
export interface CosmosUpgradeV1beta1QueryCurrentPlanResponse {
    /**
     * 
     * @type {CurrentPlan200ResponsePlan}
     * @memberof CosmosUpgradeV1beta1QueryCurrentPlanResponse
     */
    'plan'?: CurrentPlan200ResponsePlan;
}
/**
 * QueryModuleVersionsResponse is the response type for the Query/ModuleVersions RPC method.  Since: cosmos-sdk 0.43
 * @export
 * @interface CosmosUpgradeV1beta1QueryModuleVersionsResponse
 */
export interface CosmosUpgradeV1beta1QueryModuleVersionsResponse {
    /**
     * module_versions is a list of module names with their consensus versions.
     * @type {Array<ModuleVersions200ResponseModuleVersionsInner>}
     * @memberof CosmosUpgradeV1beta1QueryModuleVersionsResponse
     */
    'module_versions'?: Array<ModuleVersions200ResponseModuleVersionsInner>;
}
/**
 * QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState RPC method.
 * @export
 * @interface CosmosUpgradeV1beta1QueryUpgradedConsensusStateResponse
 */
export interface CosmosUpgradeV1beta1QueryUpgradedConsensusStateResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosUpgradeV1beta1QueryUpgradedConsensusStateResponse
     */
    'upgraded_consensus_state'?: string;
}
/**
 * QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC method.
 * @export
 * @interface CurrentPlan200Response
 */
export interface CurrentPlan200Response {
    /**
     * 
     * @type {CurrentPlan200ResponsePlan}
     * @memberof CurrentPlan200Response
     */
    'plan'?: CurrentPlan200ResponsePlan;
}
/**
 * plan is the current upgrade plan.
 * @export
 * @interface CurrentPlan200ResponsePlan
 */
export interface CurrentPlan200ResponsePlan {
    /**
     * Sets the name for the upgrade. This name will be used by the upgraded version of the software to apply any special \"on-upgrade\" commands during the first BeginBlock method after the upgrade is applied. It is also used to detect whether a software version can handle a given upgrade. If no upgrade handler with this name has been set in the software, it will be assumed that the software is out-of-date when the upgrade Time or Height is reached and the software will exit.
     * @type {string}
     * @memberof CurrentPlan200ResponsePlan
     */
    'name'?: string;
    /**
     * Deprecated: Time based upgrades have been deprecated. Time based upgrade logic has been removed from the SDK. If this field is not empty, an error will be thrown.
     * @type {string}
     * @memberof CurrentPlan200ResponsePlan
     */
    'time'?: string;
    /**
     * The height at which the upgrade must be performed. Only used if Time is not set.
     * @type {string}
     * @memberof CurrentPlan200ResponsePlan
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentPlan200ResponsePlan
     */
    'info'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof CurrentPlan200ResponsePlan
     */
    'upgraded_client_state'?: AccountsAreTheExistingAccountsInner;
}
/**
 * 
 * @export
 * @interface DataContainsTheSetOfTransactionsIncludedInTheBlock
 */
export interface DataContainsTheSetOfTransactionsIncludedInTheBlock {
    /**
     * Txs that will be applied by state @ block.Height+1. NOTE: not all txs here are valid.  We\'re just agreeing on the order first. This means that block.AppHash does not include these txs.
     * @type {Array<string>}
     * @memberof DataContainsTheSetOfTransactionsIncludedInTheBlock
     */
    'txs'?: Array<string>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface DataIsAnAppSpecificDataOfTheNFTOptional
 */
export interface DataIsAnAppSpecificDataOfTheNFTOptional {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof DataIsAnAppSpecificDataOfTheNFTOptional
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof DataIsAnAppSpecificDataOfTheNFTOptional
     */
    'value'?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface DataIsTheAppSpecificMetadataOfTheNFTClassOptional
 */
export interface DataIsTheAppSpecificMetadataOfTheNFTClassOptional {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof DataIsTheAppSpecificMetadataOfTheNFTClassOptional
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof DataIsTheAppSpecificMetadataOfTheNFTClassOptional
     */
    'value'?: string;
}
/**
 * QueryDelegationResponse is response type for the Query/Delegation RPC method.
 * @export
 * @interface Delegation200Response
 */
export interface Delegation200Response {
    /**
     * 
     * @type {DelegatorDelegations200ResponseDelegationResponsesInner}
     * @memberof Delegation200Response
     */
    'delegation_response'?: DelegatorDelegations200ResponseDelegationResponsesInner;
}
/**
 * QueryDelegationRewardsResponse is the response type for the Query/DelegationRewards RPC method.
 * @export
 * @interface DelegationRewards200Response
 */
export interface DelegationRewards200Response {
    /**
     * rewards defines the rewards accrued by a delegation.
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof DelegationRewards200Response
     */
    'rewards'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * QueryDelegationTotalRewardsResponse is the response type for the Query/DelegationTotalRewards RPC method.
 * @export
 * @interface DelegationTotalRewards200Response
 */
export interface DelegationTotalRewards200Response {
    /**
     * rewards defines all the rewards accrued by a delegator.
     * @type {Array<DelegationTotalRewards200ResponseRewardsInner>}
     * @memberof DelegationTotalRewards200Response
     */
    'rewards'?: Array<DelegationTotalRewards200ResponseRewardsInner>;
    /**
     * total defines the sum of all the rewards.
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof DelegationTotalRewards200Response
     */
    'total'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * DelegationDelegatorReward represents the properties of a delegator\'s delegation reward.
 * @export
 * @interface DelegationTotalRewards200ResponseRewardsInner
 */
export interface DelegationTotalRewards200ResponseRewardsInner {
    /**
     * 
     * @type {string}
     * @memberof DelegationTotalRewards200ResponseRewardsInner
     */
    'validator_address'?: string;
    /**
     * 
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof DelegationTotalRewards200ResponseRewardsInner
     */
    'reward'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * QueryDelegatorDelegationsResponse is response type for the Query/DelegatorDelegations RPC method.
 * @export
 * @interface DelegatorDelegations200Response
 */
export interface DelegatorDelegations200Response {
    /**
     * delegation_responses defines all the delegations\' info of a delegator.
     * @type {Array<DelegatorDelegations200ResponseDelegationResponsesInner>}
     * @memberof DelegatorDelegations200Response
     */
    'delegation_responses'?: Array<DelegatorDelegations200ResponseDelegationResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof DelegatorDelegations200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * DelegationResponse is equivalent to Delegation except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface DelegatorDelegations200ResponseDelegationResponsesInner
 */
export interface DelegatorDelegations200ResponseDelegationResponsesInner {
    /**
     * 
     * @type {DelegatorDelegations200ResponseDelegationResponsesInnerDelegation}
     * @memberof DelegatorDelegations200ResponseDelegationResponsesInner
     */
    'delegation'?: DelegatorDelegations200ResponseDelegationResponsesInnerDelegation;
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof DelegatorDelegations200ResponseDelegationResponsesInner
     */
    'balance'?: AllBalances200ResponseBalancesInner;
}
/**
 * Delegation represents the bond with tokens held by an account. It is owned by one delegator, and is associated with the voting power of one validator.
 * @export
 * @interface DelegatorDelegations200ResponseDelegationResponsesInnerDelegation
 */
export interface DelegatorDelegations200ResponseDelegationResponsesInnerDelegation {
    /**
     * delegator_address is the bech32-encoded address of the delegator.
     * @type {string}
     * @memberof DelegatorDelegations200ResponseDelegationResponsesInnerDelegation
     */
    'delegator_address'?: string;
    /**
     * validator_address is the bech32-encoded address of the validator.
     * @type {string}
     * @memberof DelegatorDelegations200ResponseDelegationResponsesInnerDelegation
     */
    'validator_address'?: string;
    /**
     * shares define the delegation shares received.
     * @type {string}
     * @memberof DelegatorDelegations200ResponseDelegationResponsesInnerDelegation
     */
    'shares'?: string;
}
/**
 * QueryUnbondingDelegatorDelegationsResponse is response type for the Query/UnbondingDelegatorDelegations RPC method.
 * @export
 * @interface DelegatorUnbondingDelegations200Response
 */
export interface DelegatorUnbondingDelegations200Response {
    /**
     * 
     * @type {Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>}
     * @memberof DelegatorUnbondingDelegations200Response
     */
    'unbonding_responses'?: Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof DelegatorUnbondingDelegations200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * UnbondingDelegation stores all of a single delegator\'s unbonding bonds for a single validator in an time-ordered list.
 * @export
 * @interface DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner
 */
export interface DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner {
    /**
     * delegator_address is the bech32-encoded address of the delegator.
     * @type {string}
     * @memberof DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner
     */
    'delegator_address'?: string;
    /**
     * validator_address is the bech32-encoded address of the validator.
     * @type {string}
     * @memberof DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner
     */
    'validator_address'?: string;
    /**
     * entries are the unbonding delegation entries.
     * @type {Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner>}
     * @memberof DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner
     */
    'entries'?: Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner>;
}
/**
 * UnbondingDelegationEntry defines an unbonding object with relevant metadata.
 * @export
 * @interface DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner
 */
export interface DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner {
    /**
     * creation_height is the height which the unbonding took place.
     * @type {string}
     * @memberof DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner
     */
    'creation_height'?: string;
    /**
     * completion_time is the unix time for unbonding completion.
     * @type {string}
     * @memberof DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner
     */
    'completion_time'?: string;
    /**
     * initial_balance defines the tokens initially scheduled to receive at completion.
     * @type {string}
     * @memberof DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner
     */
    'initial_balance'?: string;
    /**
     * balance defines the tokens to receive at completion.
     * @type {string}
     * @memberof DelegatorUnbondingDelegations200ResponseUnbondingResponsesInnerEntriesInner
     */
    'balance'?: string;
}
/**
 * QueryDelegatorValidatorResponse response type for the Query/DelegatorValidator RPC method.
 * @export
 * @interface DelegatorValidator200Response
 */
export interface DelegatorValidator200Response {
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInner}
     * @memberof DelegatorValidator200Response
     */
    'validator'?: StakingDelegatorValidators200ResponseValidatorsInner;
}
/**
 * QueryDelegatorValidatorsResponse is the response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface DelegatorValidators200Response
 */
export interface DelegatorValidators200Response {
    /**
     * validators defines the validators a delegator is delegating for.
     * @type {Array<string>}
     * @memberof DelegatorValidators200Response
     */
    'validators'?: Array<string>;
}
/**
 * QueryDelegatorWithdrawAddressResponse is the response type for the Query/DelegatorWithdrawAddress RPC method.
 * @export
 * @interface DelegatorWithdrawAddress200Response
 */
export interface DelegatorWithdrawAddress200Response {
    /**
     * withdraw_address defines the delegator address to query for.
     * @type {string}
     * @memberof DelegatorWithdrawAddress200Response
     */
    'withdraw_address'?: string;
}
/**
 * QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC method.
 * @export
 * @interface DenomMetadata200Response
 */
export interface DenomMetadata200Response {
    /**
     * 
     * @type {DenomsMetadata200ResponseMetadatasInner}
     * @memberof DenomMetadata200Response
     */
    'metadata'?: DenomsMetadata200ResponseMetadatasInner;
}
/**
 * QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.  Since: cosmos-sdk 0.46
 * @export
 * @interface DenomOwners200Response
 */
export interface DenomOwners200Response {
    /**
     * 
     * @type {Array<DenomOwners200ResponseDenomOwnersInner>}
     * @memberof DenomOwners200Response
     */
    'denom_owners'?: Array<DenomOwners200ResponseDenomOwnersInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof DenomOwners200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * DenomOwner defines structure representing an account that owns or holds a particular denominated token. It contains the account address and account balance of the denominated token.  Since: cosmos-sdk 0.46
 * @export
 * @interface DenomOwners200ResponseDenomOwnersInner
 */
export interface DenomOwners200ResponseDenomOwnersInner {
    /**
     * address defines the address that owns a particular denomination.
     * @type {string}
     * @memberof DenomOwners200ResponseDenomOwnersInner
     */
    'address'?: string;
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof DenomOwners200ResponseDenomOwnersInner
     */
    'balance'?: AllBalances200ResponseBalancesInner;
}
/**
 * DenomUnit represents a struct that describes a given denomination unit of the basic token.
 * @export
 * @interface DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner
 */
export interface DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner {
    /**
     * denom represents the string name of the given denom unit (e.g uatom).
     * @type {string}
     * @memberof DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner
     */
    'denom'?: string;
    /**
     * exponent represents power of 10 exponent that one must raise the base_denom to in order to equal the given DenomUnit\'s denom 1 denom = 10^exponent base_denom (e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with exponent = 6, thus: 1 atom = 10^6 uatom).
     * @type {number}
     * @memberof DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner
     */
    'exponent'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner
     */
    'aliases'?: Array<string>;
}
/**
 * QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC method.
 * @export
 * @interface DenomsMetadata200Response
 */
export interface DenomsMetadata200Response {
    /**
     * metadata provides the client information for all the registered tokens.
     * @type {Array<DenomsMetadata200ResponseMetadatasInner>}
     * @memberof DenomsMetadata200Response
     */
    'metadatas'?: Array<DenomsMetadata200ResponseMetadatasInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof DenomsMetadata200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Metadata represents a struct that describes a basic token.
 * @export
 * @interface DenomsMetadata200ResponseMetadatasInner
 */
export interface DenomsMetadata200ResponseMetadatasInner {
    /**
     * 
     * @type {string}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'description'?: string;
    /**
     * 
     * @type {Array<DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner>}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'denom_units'?: Array<DenomUnitsRepresentsTheListOfDenomUnitSForAGivenCoinInner>;
    /**
     * base represents the base denom (should be the DenomUnit with exponent = 0).
     * @type {string}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'base'?: string;
    /**
     * display indicates the suggested denom that should be displayed in clients.
     * @type {string}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'display'?: string;
    /**
     * Since: cosmos-sdk 0.43
     * @type {string}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'name'?: string;
    /**
     * symbol is the token symbol usually shown on exchanges (eg: ATOM). This can be the same as the display.  Since: cosmos-sdk 0.43
     * @type {string}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'symbol'?: string;
    /**
     * URI to a document (on or off-chain) that contains additional information. Optional.  Since: cosmos-sdk 0.46
     * @type {string}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'uri'?: string;
    /**
     * URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that the document didn\'t change. Optional.  Since: cosmos-sdk 0.46
     * @type {string}
     * @memberof DenomsMetadata200ResponseMetadatasInner
     */
    'uri_hash'?: string;
}
/**
 * QueryDepositResponse is the response type for the Query/Deposit RPC method.
 * @export
 * @interface Deposit200Response
 */
export interface Deposit200Response {
    /**
     * 
     * @type {Deposits200ResponseDepositsInner}
     * @memberof Deposit200Response
     */
    'deposit'?: Deposits200ResponseDepositsInner;
}
/**
 * QueryDepositsResponse is the response type for the Query/Deposits RPC method.
 * @export
 * @interface Deposits200Response
 */
export interface Deposits200Response {
    /**
     * 
     * @type {Array<Deposits200ResponseDepositsInner>}
     * @memberof Deposits200Response
     */
    'deposits'?: Array<Deposits200ResponseDepositsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof Deposits200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Deposit defines an amount deposited by an account address to an active proposal.
 * @export
 * @interface Deposits200ResponseDepositsInner
 */
export interface Deposits200ResponseDepositsInner {
    /**
     * 
     * @type {string}
     * @memberof Deposits200ResponseDepositsInner
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Deposits200ResponseDepositsInner
     */
    'depositor'?: string;
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof Deposits200ResponseDepositsInner
     */
    'amount'?: Array<AllBalances200ResponseBalancesInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInstead
 */
export interface DeprecatedPleaseUseSdkBlockInstead {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadHeader}
     * @memberof DeprecatedPleaseUseSdkBlockInstead
     */
    'header'?: DeprecatedPleaseUseSdkBlockInsteadHeader;
    /**
     * 
     * @type {DataContainsTheSetOfTransactionsIncludedInTheBlock}
     * @memberof DeprecatedPleaseUseSdkBlockInstead
     */
    'data'?: DataContainsTheSetOfTransactionsIncludedInTheBlock;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidence}
     * @memberof DeprecatedPleaseUseSdkBlockInstead
     */
    'evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidence;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof DeprecatedPleaseUseSdkBlockInstead
     */
    'last_commit'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * 
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidence
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidence {
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner>}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidence
     */
    'evidence'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner>;
}
/**
 * 
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner
     */
    'duplicate_vote_evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner
     */
    'light_client_attack_evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence;
}
/**
 * DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence
     */
    'vote_a'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence
     */
    'vote_b'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence
     */
    'total_voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence
     */
    'validator_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence
     */
    'timestamp'?: string;
}
/**
 * Vote represents a prevote, precommit, or commit vote from validators for consensus.
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA {
    /**
     * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'type'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteATypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'height'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'round'?: number;
    /**
     * 
     * @type {BlockID}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'validator_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'validator_index'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA
     */
    'signature'?: string;
}

export const DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteATypeEnum = {
    Unknown: 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote: 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit: 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal: 'SIGNED_MSG_TYPE_PROPOSAL'
} as const;

export type DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteATypeEnum = typeof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteATypeEnum[keyof typeof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteATypeEnum];

/**
 * LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence
     */
    'conflicting_block'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence
     */
    'common_height'?: string;
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence
     */
    'byzantine_validators'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence
     */
    'total_voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock
     */
    'signed_header'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock
     */
    'validator_set'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet;
}
/**
 * 
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadHeader}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader
     */
    'header'?: DeprecatedPleaseUseSdkBlockInsteadHeader;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader
     */
    'commit'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * Commit contains the evidence that a block was committed by a set of validators.
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit {
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    'height'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    'round'?: number;
    /**
     * 
     * @type {BlockID}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner>}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
     */
    'signatures'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner>;
}
/**
 * CommitSig is a part of the Vote included in a Commit.
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner {
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner
     */
    'block_id_flag'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInnerBlockIdFlagEnum;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner
     */
    'validator_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner
     */
    'signature'?: string;
}

export const DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInnerBlockIdFlagEnum = {
    Unknown: 'BLOCK_ID_FLAG_UNKNOWN',
    Absent: 'BLOCK_ID_FLAG_ABSENT',
    Commit: 'BLOCK_ID_FLAG_COMMIT',
    Nil: 'BLOCK_ID_FLAG_NIL'
} as const;

export type DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInnerBlockIdFlagEnum = typeof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInnerBlockIdFlagEnum[keyof typeof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInnerBlockIdFlagEnum];

/**
 * 
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet {
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet
     */
    'validators'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet
     */
    'proposer'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet
     */
    'total_voting_power'?: string;
}
/**
 * 
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner
 */
export interface DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner {
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner
     */
    'address'?: string;
    /**
     * 
     * @type {PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner
     */
    'pub_key'?: PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner
     */
    'voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner
     */
    'proposer_priority'?: string;
}
/**
 * Header defines the structure of a Tendermint block header.
 * @export
 * @interface DeprecatedPleaseUseSdkBlockInsteadHeader
 */
export interface DeprecatedPleaseUseSdkBlockInsteadHeader {
    /**
     * 
     * @type {BasicBlockInfo}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'version'?: BasicBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'chain_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'time'?: string;
    /**
     * 
     * @type {BlockID}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'last_block_id'?: BlockID;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'last_commit_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'data_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'next_validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'consensus_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'app_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'last_results_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'evidence_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeprecatedPleaseUseSdkBlockInsteadHeader
     */
    'proposer_address'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface DistributionParams200Response
 */
export interface DistributionParams200Response {
    /**
     * 
     * @type {DistributionParams200ResponseParams}
     * @memberof DistributionParams200Response
     */
    'params'?: DistributionParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface DistributionParams200ResponseParams
 */
export interface DistributionParams200ResponseParams {
    /**
     * 
     * @type {string}
     * @memberof DistributionParams200ResponseParams
     */
    'community_tax'?: string;
    /**
     * 
     * @type {string}
     * @memberof DistributionParams200ResponseParams
     */
    'base_proposer_reward'?: string;
    /**
     * 
     * @type {string}
     * @memberof DistributionParams200ResponseParams
     */
    'bonus_proposer_reward'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DistributionParams200ResponseParams
     */
    'withdraw_addr_enabled'?: boolean;
}
/**
 * QueryEvidenceResponse is the response type for the Query/Evidence RPC method.
 * @export
 * @interface Evidence200Response
 */
export interface Evidence200Response {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof Evidence200Response
     */
    'evidence'?: AccountsAreTheExistingAccountsInner;
}
/**
 * GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.
 * @export
 * @interface GetBlockByHeight200Response
 */
export interface GetBlockByHeight200Response {
    /**
     * 
     * @type {BlockID}
     * @memberof GetBlockByHeight200Response
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInstead}
     * @memberof GetBlockByHeight200Response
     */
    'block'?: DeprecatedPleaseUseSdkBlockInstead;
    /**
     * 
     * @type {SinceCosmosSdk047}
     * @memberof GetBlockByHeight200Response
     */
    'sdk_block'?: SinceCosmosSdk047;
}
/**
 * GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.
 * @export
 * @interface GetLatestBlock200Response
 */
export interface GetLatestBlock200Response {
    /**
     * 
     * @type {BlockID}
     * @memberof GetLatestBlock200Response
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInstead}
     * @memberof GetLatestBlock200Response
     */
    'block'?: DeprecatedPleaseUseSdkBlockInstead;
    /**
     * 
     * @type {SinceCosmosSdk047}
     * @memberof GetLatestBlock200Response
     */
    'sdk_block'?: SinceCosmosSdk047;
}
/**
 * GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface GetLatestValidatorSet200Response
 */
export interface GetLatestValidatorSet200Response {
    /**
     * 
     * @type {string}
     * @memberof GetLatestValidatorSet200Response
     */
    'block_height'?: string;
    /**
     * 
     * @type {Array<GetLatestValidatorSet200ResponseValidatorsInner>}
     * @memberof GetLatestValidatorSet200Response
     */
    'validators'?: Array<GetLatestValidatorSet200ResponseValidatorsInner>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof GetLatestValidatorSet200Response
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * pagination defines an pagination for the response.
 * @export
 * @interface GetLatestValidatorSet200ResponsePagination
 */
export interface GetLatestValidatorSet200ResponsePagination {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof GetLatestValidatorSet200ResponsePagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetLatestValidatorSet200ResponsePagination
     */
    'total'?: string;
}
/**
 * Validator is the type for the validator-set.
 * @export
 * @interface GetLatestValidatorSet200ResponseValidatorsInner
 */
export interface GetLatestValidatorSet200ResponseValidatorsInner {
    /**
     * 
     * @type {string}
     * @memberof GetLatestValidatorSet200ResponseValidatorsInner
     */
    'address'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof GetLatestValidatorSet200ResponseValidatorsInner
     */
    'pub_key'?: AccountsAreTheExistingAccountsInner;
    /**
     * 
     * @type {string}
     * @memberof GetLatestValidatorSet200ResponseValidatorsInner
     */
    'voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetLatestValidatorSet200ResponseValidatorsInner
     */
    'proposer_priority'?: string;
}
/**
 * GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method.
 * @export
 * @interface GetNodeInfo200Response
 */
export interface GetNodeInfo200Response {
    /**
     * 
     * @type {GetNodeInfo200ResponseDefaultNodeInfo}
     * @memberof GetNodeInfo200Response
     */
    'default_node_info'?: GetNodeInfo200ResponseDefaultNodeInfo;
    /**
     * 
     * @type {GetNodeInfo200ResponseApplicationVersion}
     * @memberof GetNodeInfo200Response
     */
    'application_version'?: GetNodeInfo200ResponseApplicationVersion;
}
/**
 * VersionInfo is the type for the GetNodeInfoResponse message.
 * @export
 * @interface GetNodeInfo200ResponseApplicationVersion
 */
export interface GetNodeInfo200ResponseApplicationVersion {
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'app_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'git_commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'build_tags'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'go_version'?: string;
    /**
     * 
     * @type {Array<ModuleIsTheTypeForVersionInfo>}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'build_deps'?: Array<ModuleIsTheTypeForVersionInfo>;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseApplicationVersion
     */
    'cosmos_sdk_version'?: string;
}
/**
 * 
 * @export
 * @interface GetNodeInfo200ResponseDefaultNodeInfo
 */
export interface GetNodeInfo200ResponseDefaultNodeInfo {
    /**
     * 
     * @type {GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'protocol_version'?: GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'default_node_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'listen_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'channels'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'moniker'?: string;
    /**
     * 
     * @type {GetNodeInfo200ResponseDefaultNodeInfoOther}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfo
     */
    'other'?: GetNodeInfo200ResponseDefaultNodeInfoOther;
}
/**
 * 
 * @export
 * @interface GetNodeInfo200ResponseDefaultNodeInfoOther
 */
export interface GetNodeInfo200ResponseDefaultNodeInfoOther {
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfoOther
     */
    'tx_index'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfoOther
     */
    'rpc_address'?: string;
}
/**
 * 
 * @export
 * @interface GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion
 */
export interface GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion {
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion
     */
    'p2p'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion
     */
    'block'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion
     */
    'app'?: string;
}
/**
 * GetSyncingResponse is the response type for the Query/GetSyncing RPC method.
 * @export
 * @interface GetSyncing200Response
 */
export interface GetSyncing200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetSyncing200Response
     */
    'syncing'?: boolean;
}
/**
 * GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.
 * @export
 * @interface GetValidatorSetByHeight200Response
 */
export interface GetValidatorSetByHeight200Response {
    /**
     * 
     * @type {string}
     * @memberof GetValidatorSetByHeight200Response
     */
    'block_height'?: string;
    /**
     * 
     * @type {Array<GetLatestValidatorSet200ResponseValidatorsInner>}
     * @memberof GetValidatorSetByHeight200Response
     */
    'validators'?: Array<GetLatestValidatorSet200ResponseValidatorsInner>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof GetValidatorSetByHeight200Response
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    'value'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface GovParams200Response
 */
export interface GovParams200Response {
    /**
     * 
     * @type {GovParams200ResponseVotingParams}
     * @memberof GovParams200Response
     */
    'voting_params'?: GovParams200ResponseVotingParams;
    /**
     * 
     * @type {GovParams200ResponseDepositParams}
     * @memberof GovParams200Response
     */
    'deposit_params'?: GovParams200ResponseDepositParams;
    /**
     * 
     * @type {GovParams200ResponseTallyParams}
     * @memberof GovParams200Response
     */
    'tally_params'?: GovParams200ResponseTallyParams;
}
/**
 * deposit_params defines the parameters related to deposit.
 * @export
 * @interface GovParams200ResponseDepositParams
 */
export interface GovParams200ResponseDepositParams {
    /**
     * Minimum deposit for a proposal to enter voting period.
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof GovParams200ResponseDepositParams
     */
    'min_deposit'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * Maximum period for Atom holders to deposit on a proposal. Initial value: 2  months.
     * @type {string}
     * @memberof GovParams200ResponseDepositParams
     */
    'max_deposit_period'?: string;
}
/**
 * tally_params defines the parameters related to tally.
 * @export
 * @interface GovParams200ResponseTallyParams
 */
export interface GovParams200ResponseTallyParams {
    /**
     * Minimum percentage of total stake needed to vote for a result to be  considered valid.
     * @type {string}
     * @memberof GovParams200ResponseTallyParams
     */
    'quorum'?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
     * @type {string}
     * @memberof GovParams200ResponseTallyParams
     */
    'threshold'?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be  vetoed. Default value: 1/3.
     * @type {string}
     * @memberof GovParams200ResponseTallyParams
     */
    'veto_threshold'?: string;
}
/**
 * voting_params defines the parameters related to voting.
 * @export
 * @interface GovParams200ResponseVotingParams
 */
export interface GovParams200ResponseVotingParams {
    /**
     * Length of the voting period.
     * @type {string}
     * @memberof GovParams200ResponseVotingParams
     */
    'voting_period'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface GovV1Params200Response
 */
export interface GovV1Params200Response {
    /**
     * 
     * @type {GovParams200ResponseVotingParams}
     * @memberof GovV1Params200Response
     */
    'voting_params'?: GovParams200ResponseVotingParams;
    /**
     * 
     * @type {GovParams200ResponseDepositParams}
     * @memberof GovV1Params200Response
     */
    'deposit_params'?: GovParams200ResponseDepositParams;
    /**
     * 
     * @type {GovV1Params200ResponseTallyParams}
     * @memberof GovV1Params200Response
     */
    'tally_params'?: GovV1Params200ResponseTallyParams;
}
/**
 * tally_params defines the parameters related to tally.
 * @export
 * @interface GovV1Params200ResponseTallyParams
 */
export interface GovV1Params200ResponseTallyParams {
    /**
     * Minimum percentage of total stake needed to vote for a result to be  considered valid.
     * @type {string}
     * @memberof GovV1Params200ResponseTallyParams
     */
    'quorum'?: string;
    /**
     * Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
     * @type {string}
     * @memberof GovV1Params200ResponseTallyParams
     */
    'threshold'?: string;
    /**
     * Minimum value of Veto votes to Total votes ratio for proposal to be  vetoed. Default value: 1/3.
     * @type {string}
     * @memberof GovV1Params200ResponseTallyParams
     */
    'veto_threshold'?: string;
}
/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC method.
 * @export
 * @interface GovV1Proposal200Response
 */
export interface GovV1Proposal200Response {
    /**
     * 
     * @type {Array<GovV1Proposal200ResponseProposalsInner>}
     * @memberof GovV1Proposal200Response
     */
    'proposals'?: Array<GovV1Proposal200ResponseProposalsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof GovV1Proposal200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryProposalResponse is the response type for the Query/Proposal RPC method.
 * @export
 * @interface GovV1Proposal200Response1
 */
export interface GovV1Proposal200Response1 {
    /**
     * 
     * @type {GovV1Proposal200ResponseProposalsInner}
     * @memberof GovV1Proposal200Response1
     */
    'proposal'?: GovV1Proposal200ResponseProposalsInner;
}
/**
 * Proposal defines the core field members of a governance proposal.
 * @export
 * @interface GovV1Proposal200ResponseProposalsInner
 */
export interface GovV1Proposal200ResponseProposalsInner {
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'id'?: string;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'messages'?: Array<AccountsAreTheExistingAccountsInner>;
    /**
     * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'status'?: GovV1Proposal200ResponseProposalsInnerStatusEnum;
    /**
     * 
     * @type {GovV1Proposal200ResponseProposalsInnerFinalTallyResult}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'final_tally_result'?: GovV1Proposal200ResponseProposalsInnerFinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'submit_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'deposit_end_time'?: string;
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'total_deposit'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'voting_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'voting_end_time'?: string;
    /**
     * metadata is any arbitrary metadata attached to the proposal.
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInner
     */
    'metadata'?: string;
}

export const GovV1Proposal200ResponseProposalsInnerStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
} as const;

export type GovV1Proposal200ResponseProposalsInnerStatusEnum = typeof GovV1Proposal200ResponseProposalsInnerStatusEnum[keyof typeof GovV1Proposal200ResponseProposalsInnerStatusEnum];

/**
 * final_tally_result is the final tally result of the proposal. When querying a proposal via gRPC, this field is not populated until the proposal\'s voting period has ended.
 * @export
 * @interface GovV1Proposal200ResponseProposalsInnerFinalTallyResult
 */
export interface GovV1Proposal200ResponseProposalsInnerFinalTallyResult {
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInnerFinalTallyResult
     */
    'yes_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInnerFinalTallyResult
     */
    'abstain_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInnerFinalTallyResult
     */
    'no_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1Proposal200ResponseProposalsInnerFinalTallyResult
     */
    'no_with_veto_count'?: string;
}
/**
 * QueryTallyResultResponse is the response type for the Query/Tally RPC method.
 * @export
 * @interface GovV1TallyResult200Response
 */
export interface GovV1TallyResult200Response {
    /**
     * 
     * @type {GovV1TallyResult200ResponseTally}
     * @memberof GovV1TallyResult200Response
     */
    'tally'?: GovV1TallyResult200ResponseTally;
}
/**
 * tally defines the requested tally.
 * @export
 * @interface GovV1TallyResult200ResponseTally
 */
export interface GovV1TallyResult200ResponseTally {
    /**
     * 
     * @type {string}
     * @memberof GovV1TallyResult200ResponseTally
     */
    'yes_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1TallyResult200ResponseTally
     */
    'abstain_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1TallyResult200ResponseTally
     */
    'no_count'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1TallyResult200ResponseTally
     */
    'no_with_veto_count'?: string;
}
/**
 * QueryVoteResponse is the response type for the Query/Vote RPC method.
 * @export
 * @interface GovV1Vote200Response
 */
export interface GovV1Vote200Response {
    /**
     * 
     * @type {GovV1Votes200ResponseVotesInner}
     * @memberof GovV1Vote200Response
     */
    'vote'?: GovV1Votes200ResponseVotesInner;
}
/**
 * QueryVotesResponse is the response type for the Query/Votes RPC method.
 * @export
 * @interface GovV1Votes200Response
 */
export interface GovV1Votes200Response {
    /**
     * votes defined the queried votes.
     * @type {Array<GovV1Votes200ResponseVotesInner>}
     * @memberof GovV1Votes200Response
     */
    'votes'?: Array<GovV1Votes200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof GovV1Votes200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Vote defines a vote on a governance proposal. A Vote consists of a proposal ID, the voter, and the vote option.
 * @export
 * @interface GovV1Votes200ResponseVotesInner
 */
export interface GovV1Votes200ResponseVotesInner {
    /**
     * 
     * @type {string}
     * @memberof GovV1Votes200ResponseVotesInner
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GovV1Votes200ResponseVotesInner
     */
    'voter'?: string;
    /**
     * 
     * @type {Array<GovV1Votes200ResponseVotesInnerOptionsInner>}
     * @memberof GovV1Votes200ResponseVotesInner
     */
    'options'?: Array<GovV1Votes200ResponseVotesInnerOptionsInner>;
    /**
     * metadata is any  arbitrary metadata to attached to the vote.
     * @type {string}
     * @memberof GovV1Votes200ResponseVotesInner
     */
    'metadata'?: string;
}
/**
 * WeightedVoteOption defines a unit of vote for vote split.
 * @export
 * @interface GovV1Votes200ResponseVotesInnerOptionsInner
 */
export interface GovV1Votes200ResponseVotesInnerOptionsInner {
    /**
     * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @type {string}
     * @memberof GovV1Votes200ResponseVotesInnerOptionsInner
     */
    'option'?: GovV1Votes200ResponseVotesInnerOptionsInnerOptionEnum;
    /**
     * 
     * @type {string}
     * @memberof GovV1Votes200ResponseVotesInnerOptionsInner
     */
    'weight'?: string;
}

export const GovV1Votes200ResponseVotesInnerOptionsInnerOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type GovV1Votes200ResponseVotesInnerOptionsInnerOptionEnum = typeof GovV1Votes200ResponseVotesInnerOptionsInnerOptionEnum[keyof typeof GovV1Votes200ResponseVotesInnerOptionsInnerOptionEnum];

/**
 * 
 * @export
 * @interface GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto
 */
export interface GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto {
    /**
     * 
     * @type {string}
     * @memberof GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto
     */
    'granter'?: string;
    /**
     * 
     * @type {string}
     * @memberof GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto
     */
    'grantee'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto
     */
    'authorization'?: AccountsAreTheExistingAccountsInner;
    /**
     * 
     * @type {string}
     * @memberof GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto
     */
    'expiration'?: string;
}
/**
 * allowance is a allowance granted for grantee by granter.
 * @export
 * @interface GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext
 */
export interface GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext {
    /**
     * granter is the address of the user granting an allowance of their funds.
     * @type {string}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext
     */
    'granter'?: string;
    /**
     * grantee is the address of the user being granted an allowance of another user\'s funds.
     * @type {string}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext
     */
    'grantee'?: string;
    /**
     * 
     * @type {GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext
     */
    'allowance'?: GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance;
}
/**
 * 
 * @export
 * @interface GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1
 */
export interface GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1 {
    /**
     * granter is the address of the user granting an allowance of their funds.
     * @type {string}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1
     */
    'granter'?: string;
    /**
     * grantee is the address of the user being granted an allowance of another user\'s funds.
     * @type {string}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1
     */
    'grantee'?: string;
    /**
     * 
     * @type {GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContext1
     */
    'allowance'?: GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance;
}
/**
 * allowance can be any of basic, periodic, allowed fee allowance.
 * @export
 * @interface GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance
 */
export interface GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance
     */
    'type_url'?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof GrantIsStoredInTheKVStoreToRecordAGrantWithFullContextAllowance
     */
    'value'?: string;
}
/**
 * QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method.
 * @export
 * @interface GranteeGrants200Response
 */
export interface GranteeGrants200Response {
    /**
     * grants is a list of grants granted to the grantee.
     * @type {Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>}
     * @memberof GranteeGrants200Response
     */
    'grants'?: Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof GranteeGrants200Response
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method.
 * @export
 * @interface GranterGrants200Response
 */
export interface GranterGrants200Response {
    /**
     * grants is a list of grants granted by the granter.
     * @type {Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>}
     * @memberof GranterGrants200Response
     */
    'grants'?: Array<GrantAuthorizationExtendsAGrantWithBothTheAddressesOfTheGranteeAndGranterItIsUsedInGenesisProtoAndQueryProto>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof GranterGrants200Response
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * QueryGrantsResponse is the response type for the Query/Authorizations RPC method.
 * @export
 * @interface Grants200Response
 */
export interface Grants200Response {
    /**
     * authorizations is a list of grants granted for grantee by granter.
     * @type {Array<Grants200ResponseGrantsInner>}
     * @memberof Grants200Response
     */
    'grants'?: Array<Grants200ResponseGrantsInner>;
    /**
     * 
     * @type {GetLatestValidatorSet200ResponsePagination}
     * @memberof Grants200Response
     */
    'pagination'?: GetLatestValidatorSet200ResponsePagination;
}
/**
 * Grant gives permissions to execute the provide method with expiration time.
 * @export
 * @interface Grants200ResponseGrantsInner
 */
export interface Grants200ResponseGrantsInner {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof Grants200ResponseGrantsInner
     */
    'authorization'?: AccountsAreTheExistingAccountsInner;
    /**
     * 
     * @type {string}
     * @memberof Grants200ResponseGrantsInner
     */
    'expiration'?: string;
}
/**
 * QueryGroupInfoResponse is the Query/GroupInfo response type.
 * @export
 * @interface GroupInfo200Response
 */
export interface GroupInfo200Response {
    /**
     * 
     * @type {GroupInfo200ResponseInfo}
     * @memberof GroupInfo200Response
     */
    'info'?: GroupInfo200ResponseInfo;
}
/**
 * info is the GroupInfo for the group.
 * @export
 * @interface GroupInfo200ResponseInfo
 */
export interface GroupInfo200ResponseInfo {
    /**
     * id is the unique ID of the group.
     * @type {string}
     * @memberof GroupInfo200ResponseInfo
     */
    'id'?: string;
    /**
     * admin is the account address of the group\'s admin.
     * @type {string}
     * @memberof GroupInfo200ResponseInfo
     */
    'admin'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the group.
     * @type {string}
     * @memberof GroupInfo200ResponseInfo
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupInfo200ResponseInfo
     */
    'version'?: string;
    /**
     * total_weight is the sum of the group members\' weights.
     * @type {string}
     * @memberof GroupInfo200ResponseInfo
     */
    'total_weight'?: string;
    /**
     * created_at is a timestamp specifying when a group was created.
     * @type {string}
     * @memberof GroupInfo200ResponseInfo
     */
    'created_at'?: string;
}
/**
 * QueryGroupMembersResponse is the Query/GroupMembersResponse response type.
 * @export
 * @interface GroupMembers200Response
 */
export interface GroupMembers200Response {
    /**
     * members are the members of the group with given group_id.
     * @type {Array<GroupMembers200ResponseMembersInner>}
     * @memberof GroupMembers200Response
     */
    'members'?: Array<GroupMembers200ResponseMembersInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof GroupMembers200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * GroupMember represents the relationship between a group and a member.
 * @export
 * @interface GroupMembers200ResponseMembersInner
 */
export interface GroupMembers200ResponseMembersInner {
    /**
     * group_id is the unique ID of the group.
     * @type {string}
     * @memberof GroupMembers200ResponseMembersInner
     */
    'group_id'?: string;
    /**
     * 
     * @type {GroupMembers200ResponseMembersInnerMember}
     * @memberof GroupMembers200ResponseMembersInner
     */
    'member'?: GroupMembers200ResponseMembersInnerMember;
}
/**
 * member is the member data.
 * @export
 * @interface GroupMembers200ResponseMembersInnerMember
 */
export interface GroupMembers200ResponseMembersInnerMember {
    /**
     * address is the member\'s account address.
     * @type {string}
     * @memberof GroupMembers200ResponseMembersInnerMember
     */
    'address'?: string;
    /**
     * weight is the member\'s voting weight that should be greater than 0.
     * @type {string}
     * @memberof GroupMembers200ResponseMembersInnerMember
     */
    'weight'?: string;
    /**
     * metadata is any arbitrary metadata attached to the member.
     * @type {string}
     * @memberof GroupMembers200ResponseMembersInnerMember
     */
    'metadata'?: string;
    /**
     * added_at is a timestamp specifying when a member was added.
     * @type {string}
     * @memberof GroupMembers200ResponseMembersInnerMember
     */
    'added_at'?: string;
}
/**
 * QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin response type.
 * @export
 * @interface GroupPoliciesByAdmin200Response
 */
export interface GroupPoliciesByAdmin200Response {
    /**
     * group_policies are the group policies info with provided admin.
     * @type {Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>}
     * @memberof GroupPoliciesByAdmin200Response
     */
    'group_policies'?: Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof GroupPoliciesByAdmin200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * GroupPolicyInfo represents the high-level on-chain information for a group policy.
 * @export
 * @interface GroupPoliciesByAdmin200ResponseGroupPoliciesInner
 */
export interface GroupPoliciesByAdmin200ResponseGroupPoliciesInner {
    /**
     * address is the account address of group policy.
     * @type {string}
     * @memberof GroupPoliciesByAdmin200ResponseGroupPoliciesInner
     */
    'address'?: string;
    /**
     * group_id is the unique ID of the group.
     * @type {string}
     * @memberof GroupPoliciesByAdmin200ResponseGroupPoliciesInner
     */
    'group_id'?: string;
    /**
     * admin is the account address of the group admin.
     * @type {string}
     * @memberof GroupPoliciesByAdmin200ResponseGroupPoliciesInner
     */
    'admin'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the group policy.
     * @type {string}
     * @memberof GroupPoliciesByAdmin200ResponseGroupPoliciesInner
     */
    'metadata'?: string;
    /**
     * version is used to track changes to a group\'s GroupPolicyInfo structure that would create a different result on a running proposal.
     * @type {string}
     * @memberof GroupPoliciesByAdmin200ResponseGroupPoliciesInner
     */
    'version'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof GroupPoliciesByAdmin200ResponseGroupPoliciesInner
     */
    'decision_policy'?: AccountsAreTheExistingAccountsInner;
    /**
     * created_at is a timestamp specifying when a group policy was created.
     * @type {string}
     * @memberof GroupPoliciesByAdmin200ResponseGroupPoliciesInner
     */
    'created_at'?: string;
}
/**
 * QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup response type.
 * @export
 * @interface GroupPoliciesByGroup200Response
 */
export interface GroupPoliciesByGroup200Response {
    /**
     * group_policies are the group policies info associated with the provided group.
     * @type {Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>}
     * @memberof GroupPoliciesByGroup200Response
     */
    'group_policies'?: Array<GroupPoliciesByAdmin200ResponseGroupPoliciesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof GroupPoliciesByGroup200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type.
 * @export
 * @interface GroupPolicyInfo200Response
 */
export interface GroupPolicyInfo200Response {
    /**
     * 
     * @type {GroupPoliciesByAdmin200ResponseGroupPoliciesInner}
     * @memberof GroupPolicyInfo200Response
     */
    'info'?: GroupPoliciesByAdmin200ResponseGroupPoliciesInner;
}
/**
 * QueryProposalResponse is the Query/Proposal response type.
 * @export
 * @interface GroupProposal200Response
 */
export interface GroupProposal200Response {
    /**
     * 
     * @type {GroupProposal200ResponseProposal}
     * @memberof GroupProposal200Response
     */
    'proposal'?: GroupProposal200ResponseProposal;
}
/**
 * proposal is the proposal info.
 * @export
 * @interface GroupProposal200ResponseProposal
 */
export interface GroupProposal200ResponseProposal {
    /**
     * id is the unique id of the proposal.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'id'?: string;
    /**
     * group_policy_address is the account address of group policy.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'group_policy_address'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the proposal.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'metadata'?: string;
    /**
     * proposers are the account addresses of the proposers.
     * @type {Array<string>}
     * @memberof GroupProposal200ResponseProposal
     */
    'proposers'?: Array<string>;
    /**
     * submit_time is a timestamp specifying when a proposal was submitted.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'submit_time'?: string;
    /**
     * group_version tracks the version of the group at proposal submission. This field is here for informational purposes only.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'group_version'?: string;
    /**
     * group_policy_version tracks the version of the group policy at proposal submission. When a decision policy is changed, existing proposals from previous policy versions will become invalid with the `ABORTED` status. This field is here for informational purposes only.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'group_policy_version'?: string;
    /**
     * status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'status'?: GroupProposal200ResponseProposalStatusEnum;
    /**
     * 
     * @type {GroupProposal200ResponseProposalFinalTallyResult}
     * @memberof GroupProposal200ResponseProposal
     */
    'final_tally_result'?: GroupProposal200ResponseProposalFinalTallyResult;
    /**
     * voting_period_end is the timestamp before which voting must be done. Unless a successfull MsgExec is called before (to execute a proposal whose tally is successful before the voting period ends), tallying will be done at this point, and the `final_tally_result`and `status` fields will be accordingly updated.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'voting_period_end'?: string;
    /**
     * executor_result is the final result of the proposal execution. Initial value is NotRun.
     * @type {string}
     * @memberof GroupProposal200ResponseProposal
     */
    'executor_result'?: GroupProposal200ResponseProposalExecutorResultEnum;
    /**
     * messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof GroupProposal200ResponseProposal
     */
    'messages'?: Array<AccountsAreTheExistingAccountsInner>;
}

export const GroupProposal200ResponseProposalStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    Submitted: 'PROPOSAL_STATUS_SUBMITTED',
    Accepted: 'PROPOSAL_STATUS_ACCEPTED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Aborted: 'PROPOSAL_STATUS_ABORTED',
    Withdrawn: 'PROPOSAL_STATUS_WITHDRAWN'
} as const;

export type GroupProposal200ResponseProposalStatusEnum = typeof GroupProposal200ResponseProposalStatusEnum[keyof typeof GroupProposal200ResponseProposalStatusEnum];
export const GroupProposal200ResponseProposalExecutorResultEnum = {
    Unspecified: 'PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED',
    NotRun: 'PROPOSAL_EXECUTOR_RESULT_NOT_RUN',
    Success: 'PROPOSAL_EXECUTOR_RESULT_SUCCESS',
    Failure: 'PROPOSAL_EXECUTOR_RESULT_FAILURE'
} as const;

export type GroupProposal200ResponseProposalExecutorResultEnum = typeof GroupProposal200ResponseProposalExecutorResultEnum[keyof typeof GroupProposal200ResponseProposalExecutorResultEnum];

/**
 * final_tally_result contains the sums of all weighted votes for this proposal for each vote option. It is empty at submission, and only populated after tallying, at voting period end or at proposal execution, whichever happens first.
 * @export
 * @interface GroupProposal200ResponseProposalFinalTallyResult
 */
export interface GroupProposal200ResponseProposalFinalTallyResult {
    /**
     * yes_count is the weighted sum of yes votes.
     * @type {string}
     * @memberof GroupProposal200ResponseProposalFinalTallyResult
     */
    'yes_count'?: string;
    /**
     * abstain_count is the weighted sum of abstainers.
     * @type {string}
     * @memberof GroupProposal200ResponseProposalFinalTallyResult
     */
    'abstain_count'?: string;
    /**
     * no_count is the weighted sum of no votes.
     * @type {string}
     * @memberof GroupProposal200ResponseProposalFinalTallyResult
     */
    'no_count'?: string;
    /**
     * no_with_veto_count is the weighted sum of veto.
     * @type {string}
     * @memberof GroupProposal200ResponseProposalFinalTallyResult
     */
    'no_with_veto_count'?: string;
}
/**
 * QueryTallyResultResponse is the Query/TallyResult response type.
 * @export
 * @interface GroupTallyResult200Response
 */
export interface GroupTallyResult200Response {
    /**
     * 
     * @type {GroupTallyResult200ResponseTally}
     * @memberof GroupTallyResult200Response
     */
    'tally'?: GroupTallyResult200ResponseTally;
}
/**
 * tally defines the requested tally.
 * @export
 * @interface GroupTallyResult200ResponseTally
 */
export interface GroupTallyResult200ResponseTally {
    /**
     * yes_count is the weighted sum of yes votes.
     * @type {string}
     * @memberof GroupTallyResult200ResponseTally
     */
    'yes_count'?: string;
    /**
     * abstain_count is the weighted sum of abstainers.
     * @type {string}
     * @memberof GroupTallyResult200ResponseTally
     */
    'abstain_count'?: string;
    /**
     * no_count is the weighted sum of no votes.
     * @type {string}
     * @memberof GroupTallyResult200ResponseTally
     */
    'no_count'?: string;
    /**
     * no_with_veto_count is the weighted sum of veto.
     * @type {string}
     * @memberof GroupTallyResult200ResponseTally
     */
    'no_with_veto_count'?: string;
}
/**
 * QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response type.
 * @export
 * @interface GroupsByAdmin200Response
 */
export interface GroupsByAdmin200Response {
    /**
     * groups are the groups info with the provided admin.
     * @type {Array<GroupsByAdmin200ResponseGroupsInner>}
     * @memberof GroupsByAdmin200Response
     */
    'groups'?: Array<GroupsByAdmin200ResponseGroupsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof GroupsByAdmin200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * GroupInfo represents the high-level on-chain information for a group.
 * @export
 * @interface GroupsByAdmin200ResponseGroupsInner
 */
export interface GroupsByAdmin200ResponseGroupsInner {
    /**
     * id is the unique ID of the group.
     * @type {string}
     * @memberof GroupsByAdmin200ResponseGroupsInner
     */
    'id'?: string;
    /**
     * admin is the account address of the group\'s admin.
     * @type {string}
     * @memberof GroupsByAdmin200ResponseGroupsInner
     */
    'admin'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the group.
     * @type {string}
     * @memberof GroupsByAdmin200ResponseGroupsInner
     */
    'metadata'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupsByAdmin200ResponseGroupsInner
     */
    'version'?: string;
    /**
     * total_weight is the sum of the group members\' weights.
     * @type {string}
     * @memberof GroupsByAdmin200ResponseGroupsInner
     */
    'total_weight'?: string;
    /**
     * created_at is a timestamp specifying when a group was created.
     * @type {string}
     * @memberof GroupsByAdmin200ResponseGroupsInner
     */
    'created_at'?: string;
}
/**
 * QueryGroupsByMemberResponse is the Query/GroupsByMember response type.
 * @export
 * @interface GroupsByMember200Response
 */
export interface GroupsByMember200Response {
    /**
     * groups are the groups info with the provided group member.
     * @type {Array<GroupsByAdmin200ResponseGroupsInner>}
     * @memberof GroupsByMember200Response
     */
    'groups'?: Array<GroupsByAdmin200ResponseGroupsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof GroupsByMember200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    'message'?: string;
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof GrpcGatewayRuntimeError
     */
    'details'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC method.
 * @export
 * @interface HistoricalInfo200Response
 */
export interface HistoricalInfo200Response {
    /**
     * 
     * @type {HistoricalInfo200ResponseHist}
     * @memberof HistoricalInfo200Response
     */
    'hist'?: HistoricalInfo200ResponseHist;
}
/**
 * hist defines the historical info at the given height.
 * @export
 * @interface HistoricalInfo200ResponseHist
 */
export interface HistoricalInfo200ResponseHist {
    /**
     * 
     * @type {HistoricalInfo200ResponseHistHeader}
     * @memberof HistoricalInfo200ResponseHist
     */
    'header'?: HistoricalInfo200ResponseHistHeader;
    /**
     * 
     * @type {Array<StakingDelegatorValidators200ResponseValidatorsInner>}
     * @memberof HistoricalInfo200ResponseHist
     */
    'valset'?: Array<StakingDelegatorValidators200ResponseValidatorsInner>;
}
/**
 * Header defines the structure of a Tendermint block header.
 * @export
 * @interface HistoricalInfo200ResponseHistHeader
 */
export interface HistoricalInfo200ResponseHistHeader {
    /**
     * 
     * @type {BasicBlockInfo}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'version'?: BasicBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'chain_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'time'?: string;
    /**
     * 
     * @type {PrevBlockInfo}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'last_block_id'?: PrevBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'last_commit_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'data_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'next_validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'consensus_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'app_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'last_results_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'evidence_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalInfo200ResponseHistHeader
     */
    'proposer_address'?: string;
}
/**
 * QueryInflationResponse is the response type for the Query/Inflation RPC method.
 * @export
 * @interface Inflation200Response
 */
export interface Inflation200Response {
    /**
     * inflation is the current minting inflation value.
     * @type {string}
     * @memberof Inflation200Response
     */
    'inflation'?: string;
}
/**
 * ValidatorSigningInfo defines a validator\'s signing info for monitoring their liveness activity.
 * @export
 * @interface InfoIsTheSigningInfoOfAllValidatorsInner
 */
export interface InfoIsTheSigningInfoOfAllValidatorsInner {
    /**
     * 
     * @type {string}
     * @memberof InfoIsTheSigningInfoOfAllValidatorsInner
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoIsTheSigningInfoOfAllValidatorsInner
     */
    'start_height'?: string;
    /**
     * Index which is incremented each time the validator was a bonded in a block and may have signed a precommit or not. This in conjunction with the `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
     * @type {string}
     * @memberof InfoIsTheSigningInfoOfAllValidatorsInner
     */
    'index_offset'?: string;
    /**
     * Timestamp until which the validator is jailed due to liveness downtime.
     * @type {string}
     * @memberof InfoIsTheSigningInfoOfAllValidatorsInner
     */
    'jailed_until'?: string;
    /**
     * Whether or not a validator has been tombstoned (killed out of validator set). It is set once the validator commits an equivocation or for any other configured misbehiavor.
     * @type {boolean}
     * @memberof InfoIsTheSigningInfoOfAllValidatorsInner
     */
    'tombstoned'?: boolean;
    /**
     * A counter kept to avoid unnecessary array reads. Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
     * @type {string}
     * @memberof InfoIsTheSigningInfoOfAllValidatorsInner
     */
    'missed_blocks_counter'?: string;
}
/**
 * QueryParamsResponse is the response type for the Query/Params RPC method.
 * @export
 * @interface MintParams200Response
 */
export interface MintParams200Response {
    /**
     * 
     * @type {MintParams200ResponseParams}
     * @memberof MintParams200Response
     */
    'params'?: MintParams200ResponseParams;
}
/**
 * params defines the parameters of the module.
 * @export
 * @interface MintParams200ResponseParams
 */
export interface MintParams200ResponseParams {
    /**
     * 
     * @type {string}
     * @memberof MintParams200ResponseParams
     */
    'mint_denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof MintParams200ResponseParams
     */
    'inflation_rate_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof MintParams200ResponseParams
     */
    'inflation_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof MintParams200ResponseParams
     */
    'inflation_min'?: string;
    /**
     * 
     * @type {string}
     * @memberof MintParams200ResponseParams
     */
    'goal_bonded'?: string;
    /**
     * 
     * @type {string}
     * @memberof MintParams200ResponseParams
     */
    'blocks_per_year'?: string;
}
/**
 * QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method.
 * @export
 * @interface ModuleAccountByName200Response
 */
export interface ModuleAccountByName200Response {
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof ModuleAccountByName200Response
     */
    'account'?: AccountsAreTheExistingAccountsInner;
}
/**
 * QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.  Since: cosmos-sdk 0.46
 * @export
 * @interface ModuleAccounts200Response
 */
export interface ModuleAccounts200Response {
    /**
     * 
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof ModuleAccounts200Response
     */
    'accounts'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * 
 * @export
 * @interface ModuleIsTheTypeForVersionInfo
 */
export interface ModuleIsTheTypeForVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof ModuleIsTheTypeForVersionInfo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleIsTheTypeForVersionInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleIsTheTypeForVersionInfo
     */
    'sum'?: string;
}
/**
 * QueryModuleVersionsResponse is the response type for the Query/ModuleVersions RPC method.  Since: cosmos-sdk 0.43
 * @export
 * @interface ModuleVersions200Response
 */
export interface ModuleVersions200Response {
    /**
     * module_versions is a list of module names with their consensus versions.
     * @type {Array<ModuleVersions200ResponseModuleVersionsInner>}
     * @memberof ModuleVersions200Response
     */
    'module_versions'?: Array<ModuleVersions200ResponseModuleVersionsInner>;
}
/**
 * ModuleVersion specifies a module and its consensus version.  Since: cosmos-sdk 0.43
 * @export
 * @interface ModuleVersions200ResponseModuleVersionsInner
 */
export interface ModuleVersions200ResponseModuleVersionsInner {
    /**
     * 
     * @type {string}
     * @memberof ModuleVersions200ResponseModuleVersionsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersions200ResponseModuleVersionsInner
     */
    'version'?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface Params200Response
 */
export interface Params200Response {
    /**
     * 
     * @type {Params200ResponseParam}
     * @memberof Params200Response
     */
    'param'?: Params200ResponseParam;
}
/**
 * param defines the queried parameter.
 * @export
 * @interface Params200ResponseParam
 */
export interface Params200ResponseParam {
    /**
     * 
     * @type {string}
     * @memberof Params200ResponseParam
     */
    'subspace'?: string;
    /**
     * 
     * @type {string}
     * @memberof Params200ResponseParam
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Params200ResponseParam
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PartsetHeader
 */
export interface PartsetHeader {
    /**
     * 
     * @type {number}
     * @memberof PartsetHeader
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof PartsetHeader
     */
    'hash'?: string;
}
/**
 * QueryPoolResponse is response type for the Query/Pool RPC method.
 * @export
 * @interface Pool200Response
 */
export interface Pool200Response {
    /**
     * 
     * @type {Pool200ResponsePool}
     * @memberof Pool200Response
     */
    'pool'?: Pool200ResponsePool;
}
/**
 * pool defines the pool info.
 * @export
 * @interface Pool200ResponsePool
 */
export interface Pool200ResponsePool {
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePool
     */
    'not_bonded_tokens'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pool200ResponsePool
     */
    'bonded_tokens'?: string;
}
/**
 * 
 * @export
 * @interface PrevBlockInfo
 */
export interface PrevBlockInfo {
    /**
     * 
     * @type {string}
     * @memberof PrevBlockInfo
     */
    'hash'?: string;
    /**
     * 
     * @type {PartsetHeader}
     * @memberof PrevBlockInfo
     */
    'part_set_header'?: PartsetHeader;
}
/**
 * QueryProposalResponse is the response type for the Query/Proposal RPC method.
 * @export
 * @interface Proposal200Response
 */
export interface Proposal200Response {
    /**
     * 
     * @type {Proposals200ResponseProposalsInner}
     * @memberof Proposal200Response
     */
    'proposal'?: Proposals200ResponseProposalsInner;
}
/**
 * QueryProposalsResponse is the response type for the Query/Proposals RPC method.
 * @export
 * @interface Proposals200Response
 */
export interface Proposals200Response {
    /**
     * 
     * @type {Array<Proposals200ResponseProposalsInner>}
     * @memberof Proposals200Response
     */
    'proposals'?: Array<Proposals200ResponseProposalsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof Proposals200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Proposal defines the core field members of a governance proposal.
 * @export
 * @interface Proposals200ResponseProposalsInner
 */
export interface Proposals200ResponseProposalsInner {
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInner
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof Proposals200ResponseProposalsInner
     */
    'content'?: AccountsAreTheExistingAccountsInner;
    /**
     * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @type {string}
     * @memberof Proposals200ResponseProposalsInner
     */
    'status'?: Proposals200ResponseProposalsInnerStatusEnum;
    /**
     * 
     * @type {Proposals200ResponseProposalsInnerFinalTallyResult}
     * @memberof Proposals200ResponseProposalsInner
     */
    'final_tally_result'?: Proposals200ResponseProposalsInnerFinalTallyResult;
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInner
     */
    'submit_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInner
     */
    'deposit_end_time'?: string;
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof Proposals200ResponseProposalsInner
     */
    'total_deposit'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInner
     */
    'voting_start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInner
     */
    'voting_end_time'?: string;
}

export const Proposals200ResponseProposalsInnerStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
} as const;

export type Proposals200ResponseProposalsInnerStatusEnum = typeof Proposals200ResponseProposalsInnerStatusEnum[keyof typeof Proposals200ResponseProposalsInnerStatusEnum];

/**
 * final_tally_result is the final tally result of the proposal. When querying a proposal via gRPC, this field is not populated until the proposal\'s voting period has ended.
 * @export
 * @interface Proposals200ResponseProposalsInnerFinalTallyResult
 */
export interface Proposals200ResponseProposalsInnerFinalTallyResult {
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInnerFinalTallyResult
     */
    'yes'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInnerFinalTallyResult
     */
    'abstain'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInnerFinalTallyResult
     */
    'no'?: string;
    /**
     * 
     * @type {string}
     * @memberof Proposals200ResponseProposalsInnerFinalTallyResult
     */
    'no_with_veto'?: string;
}
/**
 * QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy response type.
 * @export
 * @interface ProposalsByGroupPolicy200Response
 */
export interface ProposalsByGroupPolicy200Response {
    /**
     * proposals are the proposals with given group policy.
     * @type {Array<ProposalsByGroupPolicy200ResponseProposalsInner>}
     * @memberof ProposalsByGroupPolicy200Response
     */
    'proposals'?: Array<ProposalsByGroupPolicy200ResponseProposalsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof ProposalsByGroupPolicy200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Proposal defines a group proposal. Any member of a group can submit a proposal for a group policy to decide upon. A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal passes as well as some optional metadata associated with the proposal.
 * @export
 * @interface ProposalsByGroupPolicy200ResponseProposalsInner
 */
export interface ProposalsByGroupPolicy200ResponseProposalsInner {
    /**
     * id is the unique id of the proposal.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'id'?: string;
    /**
     * group_policy_address is the account address of group policy.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'group_policy_address'?: string;
    /**
     * metadata is any arbitrary metadata to attached to the proposal.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'metadata'?: string;
    /**
     * proposers are the account addresses of the proposers.
     * @type {Array<string>}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'proposers'?: Array<string>;
    /**
     * submit_time is a timestamp specifying when a proposal was submitted.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'submit_time'?: string;
    /**
     * group_version tracks the version of the group at proposal submission. This field is here for informational purposes only.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'group_version'?: string;
    /**
     * group_policy_version tracks the version of the group policy at proposal submission. When a decision policy is changed, existing proposals from previous policy versions will become invalid with the `ABORTED` status. This field is here for informational purposes only.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'group_policy_version'?: string;
    /**
     * status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'status'?: ProposalsByGroupPolicy200ResponseProposalsInnerStatusEnum;
    /**
     * 
     * @type {GroupProposal200ResponseProposalFinalTallyResult}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'final_tally_result'?: GroupProposal200ResponseProposalFinalTallyResult;
    /**
     * voting_period_end is the timestamp before which voting must be done. Unless a successfull MsgExec is called before (to execute a proposal whose tally is successful before the voting period ends), tallying will be done at this point, and the `final_tally_result`and `status` fields will be accordingly updated.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'voting_period_end'?: string;
    /**
     * executor_result is the final result of the proposal execution. Initial value is NotRun.
     * @type {string}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'executor_result'?: ProposalsByGroupPolicy200ResponseProposalsInnerExecutorResultEnum;
    /**
     * messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof ProposalsByGroupPolicy200ResponseProposalsInner
     */
    'messages'?: Array<AccountsAreTheExistingAccountsInner>;
}

export const ProposalsByGroupPolicy200ResponseProposalsInnerStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    Submitted: 'PROPOSAL_STATUS_SUBMITTED',
    Accepted: 'PROPOSAL_STATUS_ACCEPTED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Aborted: 'PROPOSAL_STATUS_ABORTED',
    Withdrawn: 'PROPOSAL_STATUS_WITHDRAWN'
} as const;

export type ProposalsByGroupPolicy200ResponseProposalsInnerStatusEnum = typeof ProposalsByGroupPolicy200ResponseProposalsInnerStatusEnum[keyof typeof ProposalsByGroupPolicy200ResponseProposalsInnerStatusEnum];
export const ProposalsByGroupPolicy200ResponseProposalsInnerExecutorResultEnum = {
    Unspecified: 'PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED',
    NotRun: 'PROPOSAL_EXECUTOR_RESULT_NOT_RUN',
    Success: 'PROPOSAL_EXECUTOR_RESULT_SUCCESS',
    Failure: 'PROPOSAL_EXECUTOR_RESULT_FAILURE'
} as const;

export type ProposalsByGroupPolicy200ResponseProposalsInnerExecutorResultEnum = typeof ProposalsByGroupPolicy200ResponseProposalsInnerExecutorResultEnum[keyof typeof ProposalsByGroupPolicy200ResponseProposalsInnerExecutorResultEnum];

/**
 * 
 * @export
 * @interface PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators
 */
export interface PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators
     */
    'ed25519'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators
     */
    'secp256k1'?: string;
}
/**
 * Since: cosmos-sdk 0.46.2
 * @export
 * @interface QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod
 */
export interface QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod {
    /**
     * 
     * @type {string}
     * @memberof QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod
     */
    'account_address'?: string;
}
/**
 * Since: cosmos-sdk 0.46
 * @export
 * @interface QueryAuthorityResponseIsTheResponseTypeForQueryAuthority
 */
export interface QueryAuthorityResponseIsTheResponseTypeForQueryAuthority {
    /**
     * 
     * @type {string}
     * @memberof QueryAuthorityResponseIsTheResponseTypeForQueryAuthority
     */
    'address'?: string;
}
/**
 * 
 * @export
 * @interface QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod
 */
export interface QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod {
    /**
     * 
     * @type {string}
     * @memberof QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod
 */
export interface QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod {
    /**
     * 
     * @type {QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner}
     * @memberof QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod
     */
    'class'?: QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner;
}
/**
 * 
 * @export
 * @interface QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod
 */
export interface QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod {
    /**
     * 
     * @type {Array<QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner>}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod
     */
    'classes'?: Array<QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod
     */
    'pagination'?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * Class defines the class of the nft type.
 * @export
 * @interface QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
 */
export interface QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner {
    /**
     * 
     * @type {string}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
     */
    'uri_hash'?: string;
    /**
     * 
     * @type {DataIsTheAppSpecificMetadataOfTheNFTClassOptional}
     * @memberof QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethodClassesInner
     */
    'data'?: DataIsTheAppSpecificMetadataOfTheNFTClassOptional;
}
/**
 * 
 * @export
 * @interface QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod
 */
export interface QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod {
    /**
     * 
     * @type {QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner}
     * @memberof QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod
     */
    'nft'?: QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner;
}
/**
 * 
 * @export
 * @interface QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods
 */
export interface QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods {
    /**
     * 
     * @type {Array<QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner>}
     * @memberof QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods
     */
    'nfts'?: Array<QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods
     */
    'pagination'?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * NFT defines the NFT.
 * @export
 * @interface QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner
 */
export interface QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner {
    /**
     * 
     * @type {string}
     * @memberof QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner
     */
    'class_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner
     */
    'uri_hash'?: string;
    /**
     * 
     * @type {DataIsAnAppSpecificDataOfTheNFTOptional}
     * @memberof QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethodsNftsInner
     */
    'data'?: DataIsAnAppSpecificDataOfTheNFTOptional;
}
/**
 * 
 * @export
 * @interface QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod
 */
export interface QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod {
    /**
     * 
     * @type {string}
     * @memberof QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod
 */
export interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod {
    /**
     * 
     * @type {QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod
     */
    'params'?: QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams;
}
/**
 * Params represents the parameters used for by the slashing module.
 * @export
 * @interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
 */
export interface QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams {
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    'signed_blocks_window'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    'min_signed_per_window'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    'downtime_jail_duration'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    'slash_fraction_double_sign'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethodParams
     */
    'slash_fraction_downtime'?: string;
}
/**
 * 
 * @export
 * @interface QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod
 */
export interface QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod {
    /**
     * 
     * @type {ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress}
     * @memberof QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod
     */
    'val_signing_info'?: ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress;
}
/**
 * 
 * @export
 * @interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod
 */
export interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod {
    /**
     * 
     * @type {Array<InfoIsTheSigningInfoOfAllValidatorsInner>}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod
     */
    'info'?: Array<InfoIsTheSigningInfoOfAllValidatorsInner>;
    /**
     * 
     * @type {QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod
     */
    'pagination'?: QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination
 */
export interface QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethodPagination
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod
 */
export interface QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod {
    /**
     * 
     * @type {string}
     * @memberof QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod
 */
export interface QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod {
    /**
     * 
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod
     */
    'supply'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination}
     * @memberof QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod
     */
    'pagination'?: QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination;
}
/**
 * pagination defines the pagination in the response.  Since: cosmos-sdk 0.43
 * @export
 * @interface QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination
 */
export interface QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination {
    /**
     * next_key is the key to be passed to PageRequest.key to query the next page most efficiently. It will be empty if there are no more results.
     * @type {string}
     * @memberof QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination
     */
    'next_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethodPagination
     */
    'total'?: string;
}
/**
 * 
 * @export
 * @interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod
 */
export interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod {
    /**
     * 
     * @type {QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission}
     * @memberof QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod
     */
    'commission'?: QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission;
}
/**
 * commission defines the commision the validator received.
 * @export
 * @interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission
 */
export interface QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission {
    /**
     * 
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethodCommission
     */
    'commission'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * 
 * @export
 * @interface QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
 */
export interface QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod {
    /**
     * 
     * @type {Array<DelegatorDelegations200ResponseDelegationResponsesInner>}
     * @memberof QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
     */
    'delegation_responses'?: Array<DelegatorDelegations200ResponseDelegationResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * 
 * @export
 * @interface QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod
 */
export interface QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod {
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInner}
     * @memberof QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod
     */
    'validator'?: StakingDelegatorValidators200ResponseValidatorsInner;
}
/**
 * 
 * @export
 * @interface QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
 */
export interface QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod {
    /**
     * validators contains all the queried validators.
     * @type {Array<StakingDelegatorValidators200ResponseValidatorsInner>}
     * @memberof QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
     */
    'validators'?: Array<StakingDelegatorValidators200ResponseValidatorsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryRedelegationsResponse is response type for the Query/Redelegations RPC method.
 * @export
 * @interface Redelegations200Response
 */
export interface Redelegations200Response {
    /**
     * 
     * @type {Array<Redelegations200ResponseRedelegationResponsesInner>}
     * @memberof Redelegations200Response
     */
    'redelegation_responses'?: Array<Redelegations200ResponseRedelegationResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof Redelegations200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * RedelegationResponse is equivalent to a Redelegation except that its entries contain a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface Redelegations200ResponseRedelegationResponsesInner
 */
export interface Redelegations200ResponseRedelegationResponsesInner {
    /**
     * 
     * @type {Redelegations200ResponseRedelegationResponsesInnerRedelegation}
     * @memberof Redelegations200ResponseRedelegationResponsesInner
     */
    'redelegation'?: Redelegations200ResponseRedelegationResponsesInnerRedelegation;
    /**
     * 
     * @type {Array<Redelegations200ResponseRedelegationResponsesInnerEntriesInner>}
     * @memberof Redelegations200ResponseRedelegationResponsesInner
     */
    'entries'?: Array<Redelegations200ResponseRedelegationResponsesInnerEntriesInner>;
}
/**
 * RedelegationEntryResponse is equivalent to a RedelegationEntry except that it contains a balance in addition to shares which is more suitable for client responses.
 * @export
 * @interface Redelegations200ResponseRedelegationResponsesInnerEntriesInner
 */
export interface Redelegations200ResponseRedelegationResponsesInnerEntriesInner {
    /**
     * 
     * @type {Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerEntriesInner
     */
    'redelegation_entry'?: Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner;
    /**
     * 
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerEntriesInner
     */
    'balance'?: string;
}
/**
 * Redelegation contains the list of a particular delegator\'s redelegating bonds from a particular source validator to a particular destination validator.
 * @export
 * @interface Redelegations200ResponseRedelegationResponsesInnerRedelegation
 */
export interface Redelegations200ResponseRedelegationResponsesInnerRedelegation {
    /**
     * delegator_address is the bech32-encoded address of the delegator.
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegation
     */
    'delegator_address'?: string;
    /**
     * validator_src_address is the validator redelegation source operator address.
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegation
     */
    'validator_src_address'?: string;
    /**
     * validator_dst_address is the validator redelegation destination operator address.
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegation
     */
    'validator_dst_address'?: string;
    /**
     * entries are the redelegation entries.
     * @type {Array<Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner>}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegation
     */
    'entries'?: Array<Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner>;
}
/**
 * RedelegationEntry defines a redelegation object with relevant metadata.
 * @export
 * @interface Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner
 */
export interface Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner {
    /**
     * creation_height  defines the height which the redelegation took place.
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner
     */
    'creation_height'?: string;
    /**
     * completion_time defines the unix time for redelegation completion.
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner
     */
    'completion_time'?: string;
    /**
     * initial_balance defines the initial balance when redelegation started.
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner
     */
    'initial_balance'?: string;
    /**
     * shares_dst is the amount of destination-validator shares created by redelegation.
     * @type {string}
     * @memberof Redelegations200ResponseRedelegationResponsesInnerRedelegationEntriesInner
     */
    'shares_dst'?: string;
}
/**
 * SimulateResponse is the response type for the Service.SimulateRPC method.
 * @export
 * @interface Simulate200Response
 */
export interface Simulate200Response {
    /**
     * 
     * @type {Simulate200ResponseGasInfo}
     * @memberof Simulate200Response
     */
    'gas_info'?: Simulate200ResponseGasInfo;
    /**
     * 
     * @type {Simulate200ResponseResult}
     * @memberof Simulate200Response
     */
    'result'?: Simulate200ResponseResult;
}
/**
 * gas_info is the information about gas used in the simulation.
 * @export
 * @interface Simulate200ResponseGasInfo
 */
export interface Simulate200ResponseGasInfo {
    /**
     * GasWanted is the maximum units of work we allow this tx to perform.
     * @type {string}
     * @memberof Simulate200ResponseGasInfo
     */
    'gas_wanted'?: string;
    /**
     * GasUsed is the amount of gas actually consumed.
     * @type {string}
     * @memberof Simulate200ResponseGasInfo
     */
    'gas_used'?: string;
}
/**
 * result is the result of the simulation.
 * @export
 * @interface Simulate200ResponseResult
 */
export interface Simulate200ResponseResult {
    /**
     * Data is any data returned from message or handler execution. It MUST be length prefixed in order to separate data from multiple message executions. Deprecated. This field is still populated, but prefer msg_response instead because it also contains the Msg response typeURL.
     * @type {string}
     * @memberof Simulate200ResponseResult
     */
    'data'?: string;
    /**
     * Log contains the log information from message or handler execution.
     * @type {string}
     * @memberof Simulate200ResponseResult
     */
    'log'?: string;
    /**
     * Events contains a slice of Event objects that were emitted during message or handler execution.
     * @type {Array<Simulate200ResponseResultEventsInner>}
     * @memberof Simulate200ResponseResult
     */
    'events'?: Array<Simulate200ResponseResultEventsInner>;
    /**
     * msg_responses contains the Msg handler responses type packed in Anys.  Since: cosmos-sdk 0.46
     * @type {Array<AccountsAreTheExistingAccountsInner>}
     * @memberof Simulate200ResponseResult
     */
    'msg_responses'?: Array<AccountsAreTheExistingAccountsInner>;
}
/**
 * Event allows application developers to attach additional information to ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx. Later, transactions may be queried using these events.
 * @export
 * @interface Simulate200ResponseResultEventsInner
 */
export interface Simulate200ResponseResultEventsInner {
    /**
     * 
     * @type {string}
     * @memberof Simulate200ResponseResultEventsInner
     */
    'type'?: string;
    /**
     * 
     * @type {Array<Simulate200ResponseResultEventsInnerAttributesInner>}
     * @memberof Simulate200ResponseResultEventsInner
     */
    'attributes'?: Array<Simulate200ResponseResultEventsInnerAttributesInner>;
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 * @export
 * @interface Simulate200ResponseResultEventsInnerAttributesInner
 */
export interface Simulate200ResponseResultEventsInnerAttributesInner {
    /**
     * 
     * @type {string}
     * @memberof Simulate200ResponseResultEventsInnerAttributesInner
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Simulate200ResponseResultEventsInnerAttributesInner
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Simulate200ResponseResultEventsInnerAttributesInner
     */
    'index'?: boolean;
}
/**
 * WeightedVoteOption defines a unit of vote for vote split.  Since: cosmos-sdk 0.43
 * @export
 * @interface SinceCosmosSdk043Inner
 */
export interface SinceCosmosSdk043Inner {
    /**
     * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @type {string}
     * @memberof SinceCosmosSdk043Inner
     */
    'option'?: SinceCosmosSdk043InnerOptionEnum;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk043Inner
     */
    'weight'?: string;
}

export const SinceCosmosSdk043InnerOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type SinceCosmosSdk043InnerOptionEnum = typeof SinceCosmosSdk043InnerOptionEnum[keyof typeof SinceCosmosSdk043InnerOptionEnum];

/**
 * Block is tendermint type Block, with the Header proposer address field converted to bech32 string.
 * @export
 * @interface SinceCosmosSdk047
 */
export interface SinceCosmosSdk047 {
    /**
     * 
     * @type {SinceCosmosSdk047Header}
     * @memberof SinceCosmosSdk047
     */
    'header'?: SinceCosmosSdk047Header;
    /**
     * 
     * @type {DataContainsTheSetOfTransactionsIncludedInTheBlock}
     * @memberof SinceCosmosSdk047
     */
    'data'?: DataContainsTheSetOfTransactionsIncludedInTheBlock;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidence}
     * @memberof SinceCosmosSdk047
     */
    'evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidence;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof SinceCosmosSdk047
     */
    'last_commit'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * Header defines the structure of a Tendermint block header.
 * @export
 * @interface SinceCosmosSdk047Header
 */
export interface SinceCosmosSdk047Header {
    /**
     * 
     * @type {BasicBlockInfo}
     * @memberof SinceCosmosSdk047Header
     */
    'version'?: BasicBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'chain_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'time'?: string;
    /**
     * 
     * @type {BlockID}
     * @memberof SinceCosmosSdk047Header
     */
    'last_block_id'?: BlockID;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'last_commit_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'data_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'next_validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'consensus_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'app_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'last_results_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'evidence_hash'?: string;
    /**
     * proposer_address is the original block proposer address, formatted as a Bech32 string. In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string for better UX.
     * @type {string}
     * @memberof SinceCosmosSdk047Header
     */
    'proposer_address'?: string;
}
/**
 * 
 * @export
 * @interface SingleRepresentsASingleSigner
 */
export interface SingleRepresentsASingleSigner {
    /**
     * SignMode represents a signing mode with its own security guarantees.  This enum should be considered a registry of all known sign modes in the Cosmos ecosystem. Apps are not expected to support all known sign modes. Apps that would like to support custom  sign modes are encouraged to open a small PR against this file to add a new case to this SignMode enum describing their sign mode so that different apps have a consistent version of this enum.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected.  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx.  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT. It is currently not supported.  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not require signers signing over other signers\' `signer_info`. It also allows for adding Tips in transactions.  Since: cosmos-sdk 0.46  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future.  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos SDK. Ref: https://eips.ethereum.org/EIPS/eip-191  Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant, but is not implemented on the SDK by default. To enable EIP-191, you need to pass a custom `TxConfig` that has an implementation of `SignModeHandler` for EIP-191. The SDK may decide to fully support EIP-191 in the future.  Since: cosmos-sdk 0.45.2
     * @type {string}
     * @memberof SingleRepresentsASingleSigner
     */
    'mode'?: SingleRepresentsASingleSignerModeEnum;
}

export const SingleRepresentsASingleSignerModeEnum = {
    Unspecified: 'SIGN_MODE_UNSPECIFIED',
    Direct: 'SIGN_MODE_DIRECT',
    Textual: 'SIGN_MODE_TEXTUAL',
    DirectAux: 'SIGN_MODE_DIRECT_AUX',
    LegacyAminoJson: 'SIGN_MODE_LEGACY_AMINO_JSON',
    Eip191: 'SIGN_MODE_EIP_191'
} as const;

export type SingleRepresentsASingleSignerModeEnum = typeof SingleRepresentsASingleSignerModeEnum[keyof typeof SingleRepresentsASingleSignerModeEnum];

/**
 * QuerySpendableBalancesResponse defines the gRPC response structure for querying an account\'s spendable balances.  Since: cosmos-sdk 0.46
 * @export
 * @interface SpendableBalances200Response
 */
export interface SpendableBalances200Response {
    /**
     * balances is the spendable balances of all the coins.
     * @type {Array<AllBalances200ResponseBalancesInner>}
     * @memberof SpendableBalances200Response
     */
    'balances'?: Array<AllBalances200ResponseBalancesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof SpendableBalances200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryDelegatorValidatorsResponse is response type for the Query/DelegatorValidators RPC method.
 * @export
 * @interface StakingDelegatorValidators200Response
 */
export interface StakingDelegatorValidators200Response {
    /**
     * validators defines the validators\' info of a delegator.
     * @type {Array<StakingDelegatorValidators200ResponseValidatorsInner>}
     * @memberof StakingDelegatorValidators200Response
     */
    'validators'?: Array<StakingDelegatorValidators200ResponseValidatorsInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof StakingDelegatorValidators200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Validator defines a validator, together with the total amount of the Validator\'s bond shares and their exchange rate to coins. Slashing results in a decrease in the exchange rate, allowing correct calculation of future undelegations without iterating over delegators. When coins are delegated to this validator, the validator is credited with a delegation whose number of bond shares is based on the amount of coins delegated divided by the current exchange rate. Voting power can be calculated as total bonded shares multiplied by exchange rate.
 * @export
 * @interface StakingDelegatorValidators200ResponseValidatorsInner
 */
export interface StakingDelegatorValidators200ResponseValidatorsInner {
    /**
     * operator_address defines the address of the validator\'s operator; bech encoded in JSON.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'operator_address'?: string;
    /**
     * 
     * @type {AccountsAreTheExistingAccountsInner}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'consensus_pubkey'?: AccountsAreTheExistingAccountsInner;
    /**
     * jailed defined whether the validator has been jailed from bonded status or not.
     * @type {boolean}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'jailed'?: boolean;
    /**
     * status is the validator status (bonded/unbonding/unbonded).
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'status'?: StakingDelegatorValidators200ResponseValidatorsInnerStatusEnum;
    /**
     * tokens define the delegated tokens (incl. self-delegation).
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'tokens'?: string;
    /**
     * delegator_shares defines total shares issued to a validator\'s delegators.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'delegator_shares'?: string;
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInnerDescription}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'description'?: StakingDelegatorValidators200ResponseValidatorsInnerDescription;
    /**
     * unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'unbonding_height'?: string;
    /**
     * unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'unbonding_time'?: string;
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInnerCommission}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'commission'?: StakingDelegatorValidators200ResponseValidatorsInnerCommission;
    /**
     * min_self_delegation is the validator\'s self declared minimum self delegation.  Since: cosmos-sdk 0.46
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInner
     */
    'min_self_delegation'?: string;
}

export const StakingDelegatorValidators200ResponseValidatorsInnerStatusEnum = {
    Unspecified: 'BOND_STATUS_UNSPECIFIED',
    Unbonded: 'BOND_STATUS_UNBONDED',
    Unbonding: 'BOND_STATUS_UNBONDING',
    Bonded: 'BOND_STATUS_BONDED'
} as const;

export type StakingDelegatorValidators200ResponseValidatorsInnerStatusEnum = typeof StakingDelegatorValidators200ResponseValidatorsInnerStatusEnum[keyof typeof StakingDelegatorValidators200ResponseValidatorsInnerStatusEnum];

/**
 * commission defines the commission parameters.
 * @export
 * @interface StakingDelegatorValidators200ResponseValidatorsInnerCommission
 */
export interface StakingDelegatorValidators200ResponseValidatorsInnerCommission {
    /**
     * 
     * @type {StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerCommission
     */
    'commission_rates'?: StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates;
    /**
     * update_time is the last time the commission rate was changed.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerCommission
     */
    'update_time'?: string;
}
/**
 * commission_rates defines the initial commission rates to be used for creating a validator.
 * @export
 * @interface StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates
 */
export interface StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates {
    /**
     * rate is the commission rate charged to delegators, as a fraction.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates
     */
    'rate'?: string;
    /**
     * max_rate defines the maximum commission rate which validator can ever charge, as a fraction.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates
     */
    'max_rate'?: string;
    /**
     * max_change_rate defines the maximum daily increase of the validator commission, as a fraction.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerCommissionCommissionRates
     */
    'max_change_rate'?: string;
}
/**
 * description defines the description terms for the validator.
 * @export
 * @interface StakingDelegatorValidators200ResponseValidatorsInnerDescription
 */
export interface StakingDelegatorValidators200ResponseValidatorsInnerDescription {
    /**
     * moniker defines a human-readable name for the validator.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerDescription
     */
    'moniker'?: string;
    /**
     * identity defines an optional identity signature (ex. UPort or Keybase).
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerDescription
     */
    'identity'?: string;
    /**
     * website defines an optional website link.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerDescription
     */
    'website'?: string;
    /**
     * security_contact defines an optional email for security contact.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerDescription
     */
    'security_contact'?: string;
    /**
     * details define other optional details.
     * @type {string}
     * @memberof StakingDelegatorValidators200ResponseValidatorsInnerDescription
     */
    'details'?: string;
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 * @export
 * @interface StakingParams200Response
 */
export interface StakingParams200Response {
    /**
     * 
     * @type {StakingParams200ResponseParams}
     * @memberof StakingParams200Response
     */
    'params'?: StakingParams200ResponseParams;
}
/**
 * params holds all the parameters of this module.
 * @export
 * @interface StakingParams200ResponseParams
 */
export interface StakingParams200ResponseParams {
    /**
     * unbonding_time is the time duration of unbonding.
     * @type {string}
     * @memberof StakingParams200ResponseParams
     */
    'unbonding_time'?: string;
    /**
     * max_validators is the maximum number of validators.
     * @type {number}
     * @memberof StakingParams200ResponseParams
     */
    'max_validators'?: number;
    /**
     * max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
     * @type {number}
     * @memberof StakingParams200ResponseParams
     */
    'max_entries'?: number;
    /**
     * historical_entries is the number of historical entries to persist.
     * @type {number}
     * @memberof StakingParams200ResponseParams
     */
    'historical_entries'?: number;
    /**
     * bond_denom defines the bondable coin denomination.
     * @type {string}
     * @memberof StakingParams200ResponseParams
     */
    'bond_denom'?: string;
    /**
     * 
     * @type {string}
     * @memberof StakingParams200ResponseParams
     */
    'min_commission_rate'?: string;
}
/**
 * QuerySubspacesResponse defines the response types for querying for all registered subspaces and all keys for a subspace.  Since: cosmos-sdk 0.46
 * @export
 * @interface Subspaces200Response
 */
export interface Subspaces200Response {
    /**
     * 
     * @type {Array<Subspaces200ResponseSubspacesInner>}
     * @memberof Subspaces200Response
     */
    'subspaces'?: Array<Subspaces200ResponseSubspacesInner>;
}
/**
 * Subspace defines a parameter subspace name and all the keys that exist for the subspace.  Since: cosmos-sdk 0.46
 * @export
 * @interface Subspaces200ResponseSubspacesInner
 */
export interface Subspaces200ResponseSubspacesInner {
    /**
     * 
     * @type {string}
     * @memberof Subspaces200ResponseSubspacesInner
     */
    'subspace'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Subspaces200ResponseSubspacesInner
     */
    'keys'?: Array<string>;
}
/**
 * QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.
 * @export
 * @interface SupplyOf200Response
 */
export interface SupplyOf200Response {
    /**
     * 
     * @type {AllBalances200ResponseBalancesInner}
     * @memberof SupplyOf200Response
     */
    'amount'?: AllBalances200ResponseBalancesInner;
}
/**
 * QueryTallyResultResponse is the response type for the Query/Tally RPC method.
 * @export
 * @interface TallyResult200Response
 */
export interface TallyResult200Response {
    /**
     * 
     * @type {TallyResult200ResponseTally}
     * @memberof TallyResult200Response
     */
    'tally'?: TallyResult200ResponseTally;
}
/**
 * tally defines the requested tally.
 * @export
 * @interface TallyResult200ResponseTally
 */
export interface TallyResult200ResponseTally {
    /**
     * 
     * @type {string}
     * @memberof TallyResult200ResponseTally
     */
    'yes'?: string;
    /**
     * 
     * @type {string}
     * @memberof TallyResult200ResponseTally
     */
    'abstain'?: string;
    /**
     * 
     * @type {string}
     * @memberof TallyResult200ResponseTally
     */
    'no'?: string;
    /**
     * 
     * @type {string}
     * @memberof TallyResult200ResponseTally
     */
    'no_with_veto'?: string;
}
/**
 * Event allows application developers to attach additional information to ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx. Later, transactions may be queried using these events.
 * @export
 * @interface TendermintAbciEvent
 */
export interface TendermintAbciEvent {
    /**
     * 
     * @type {string}
     * @memberof TendermintAbciEvent
     */
    'type'?: string;
    /**
     * 
     * @type {Array<Simulate200ResponseResultEventsInnerAttributesInner>}
     * @memberof TendermintAbciEvent
     */
    'attributes'?: Array<Simulate200ResponseResultEventsInnerAttributesInner>;
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 * @export
 * @interface TendermintAbciEventAttribute
 */
export interface TendermintAbciEventAttribute {
    /**
     * 
     * @type {string}
     * @memberof TendermintAbciEventAttribute
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintAbciEventAttribute
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TendermintAbciEventAttribute
     */
    'index'?: boolean;
}
/**
 * 
 * @export
 * @interface TendermintCryptoPublicKey
 */
export interface TendermintCryptoPublicKey {
    /**
     * 
     * @type {string}
     * @memberof TendermintCryptoPublicKey
     */
    'ed25519'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintCryptoPublicKey
     */
    'secp256k1'?: string;
}
/**
 * 
 * @export
 * @interface TendermintP2pDefaultNodeInfo
 */
export interface TendermintP2pDefaultNodeInfo {
    /**
     * 
     * @type {GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'protocol_version'?: GetNodeInfo200ResponseDefaultNodeInfoProtocolVersion;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'default_node_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'listen_addr'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'channels'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'moniker'?: string;
    /**
     * 
     * @type {GetNodeInfo200ResponseDefaultNodeInfoOther}
     * @memberof TendermintP2pDefaultNodeInfo
     */
    'other'?: GetNodeInfo200ResponseDefaultNodeInfoOther;
}
/**
 * 
 * @export
 * @interface TendermintP2pDefaultNodeInfoOther
 */
export interface TendermintP2pDefaultNodeInfoOther {
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfoOther
     */
    'tx_index'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pDefaultNodeInfoOther
     */
    'rpc_address'?: string;
}
/**
 * 
 * @export
 * @interface TendermintP2pProtocolVersion
 */
export interface TendermintP2pProtocolVersion {
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pProtocolVersion
     */
    'p2p'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pProtocolVersion
     */
    'block'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintP2pProtocolVersion
     */
    'app'?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesBlock
 */
export interface TendermintTypesBlock {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadHeader}
     * @memberof TendermintTypesBlock
     */
    'header'?: DeprecatedPleaseUseSdkBlockInsteadHeader;
    /**
     * 
     * @type {DataContainsTheSetOfTransactionsIncludedInTheBlock}
     * @memberof TendermintTypesBlock
     */
    'data'?: DataContainsTheSetOfTransactionsIncludedInTheBlock;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidence}
     * @memberof TendermintTypesBlock
     */
    'evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidence;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof TendermintTypesBlock
     */
    'last_commit'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * 
 * @export
 * @interface TendermintTypesBlockID
 */
export interface TendermintTypesBlockID {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesBlockID
     */
    'hash'?: string;
    /**
     * 
     * @type {PartsetHeader}
     * @memberof TendermintTypesBlockID
     */
    'part_set_header'?: PartsetHeader;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TendermintTypesBlockIDFlag = {
    Unknown: 'BLOCK_ID_FLAG_UNKNOWN',
    Absent: 'BLOCK_ID_FLAG_ABSENT',
    Commit: 'BLOCK_ID_FLAG_COMMIT',
    Nil: 'BLOCK_ID_FLAG_NIL'
} as const;

export type TendermintTypesBlockIDFlag = typeof TendermintTypesBlockIDFlag[keyof typeof TendermintTypesBlockIDFlag];


/**
 * Commit contains the evidence that a block was committed by a set of validators.
 * @export
 * @interface TendermintTypesCommit
 */
export interface TendermintTypesCommit {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommit
     */
    'height'?: string;
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesCommit
     */
    'round'?: number;
    /**
     * 
     * @type {BlockID}
     * @memberof TendermintTypesCommit
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner>}
     * @memberof TendermintTypesCommit
     */
    'signatures'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesInner>;
}
/**
 * CommitSig is a part of the Vote included in a Commit.
 * @export
 * @interface TendermintTypesCommitSig
 */
export interface TendermintTypesCommitSig {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    'block_id_flag'?: TendermintTypesCommitSigBlockIdFlagEnum;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    'validator_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesCommitSig
     */
    'signature'?: string;
}

export const TendermintTypesCommitSigBlockIdFlagEnum = {
    Unknown: 'BLOCK_ID_FLAG_UNKNOWN',
    Absent: 'BLOCK_ID_FLAG_ABSENT',
    Commit: 'BLOCK_ID_FLAG_COMMIT',
    Nil: 'BLOCK_ID_FLAG_NIL'
} as const;

export type TendermintTypesCommitSigBlockIdFlagEnum = typeof TendermintTypesCommitSigBlockIdFlagEnum[keyof typeof TendermintTypesCommitSigBlockIdFlagEnum];

/**
 * 
 * @export
 * @interface TendermintTypesData
 */
export interface TendermintTypesData {
    /**
     * Txs that will be applied by state @ block.Height+1. NOTE: not all txs here are valid.  We\'re just agreeing on the order first. This means that block.AppHash does not include these txs.
     * @type {Array<string>}
     * @memberof TendermintTypesData
     */
    'txs'?: Array<string>;
}
/**
 * DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
 * @export
 * @interface TendermintTypesDuplicateVoteEvidence
 */
export interface TendermintTypesDuplicateVoteEvidence {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    'vote_a'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    'vote_b'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidenceVoteA;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    'total_voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    'validator_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesDuplicateVoteEvidence
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesEvidence
 */
export interface TendermintTypesEvidence {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence}
     * @memberof TendermintTypesEvidence
     */
    'duplicate_vote_evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerDuplicateVoteEvidence;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence}
     * @memberof TendermintTypesEvidence
     */
    'light_client_attack_evidence'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidence;
}
/**
 * 
 * @export
 * @interface TendermintTypesEvidenceList
 */
export interface TendermintTypesEvidenceList {
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner>}
     * @memberof TendermintTypesEvidenceList
     */
    'evidence'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInner>;
}
/**
 * Header defines the structure of a Tendermint block header.
 * @export
 * @interface TendermintTypesHeader
 */
export interface TendermintTypesHeader {
    /**
     * 
     * @type {BasicBlockInfo}
     * @memberof TendermintTypesHeader
     */
    'version'?: BasicBlockInfo;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'chain_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'time'?: string;
    /**
     * 
     * @type {BlockID}
     * @memberof TendermintTypesHeader
     */
    'last_block_id'?: BlockID;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'last_commit_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'data_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'next_validators_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'consensus_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'app_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'last_results_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'evidence_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesHeader
     */
    'proposer_address'?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesLightBlock
 */
export interface TendermintTypesLightBlock {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader}
     * @memberof TendermintTypesLightBlock
     */
    'signed_header'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeader;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet}
     * @memberof TendermintTypesLightBlock
     */
    'validator_set'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSet;
}
/**
 * LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
 * @export
 * @interface TendermintTypesLightClientAttackEvidence
 */
export interface TendermintTypesLightClientAttackEvidence {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    'conflicting_block'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlock;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    'common_height'?: string;
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    'byzantine_validators'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    'total_voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesLightClientAttackEvidence
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesPartSetHeader
 */
export interface TendermintTypesPartSetHeader {
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesPartSetHeader
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesPartSetHeader
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesSignedHeader
 */
export interface TendermintTypesSignedHeader {
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadHeader}
     * @memberof TendermintTypesSignedHeader
     */
    'header'?: DeprecatedPleaseUseSdkBlockInsteadHeader;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit}
     * @memberof TendermintTypesSignedHeader
     */
    'commit'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockSignedHeaderCommit;
}
/**
 * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
 * @export
 * @enum {string}
 */

export const TendermintTypesSignedMsgType = {
    Unknown: 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote: 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit: 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal: 'SIGNED_MSG_TYPE_PROPOSAL'
} as const;

export type TendermintTypesSignedMsgType = typeof TendermintTypesSignedMsgType[keyof typeof TendermintTypesSignedMsgType];


/**
 * 
 * @export
 * @interface TendermintTypesValidator
 */
export interface TendermintTypesValidator {
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidator
     */
    'address'?: string;
    /**
     * 
     * @type {PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators}
     * @memberof TendermintTypesValidator
     */
    'pub_key'?: PublicKeyDefinesTheKeysAvailableForUseWithTendermintValidators;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidator
     */
    'voting_power'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidator
     */
    'proposer_priority'?: string;
}
/**
 * 
 * @export
 * @interface TendermintTypesValidatorSet
 */
export interface TendermintTypesValidatorSet {
    /**
     * 
     * @type {Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>}
     * @memberof TendermintTypesValidatorSet
     */
    'validators'?: Array<DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner>;
    /**
     * 
     * @type {DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner}
     * @memberof TendermintTypesValidatorSet
     */
    'proposer'?: DeprecatedPleaseUseSdkBlockInsteadEvidenceEvidenceInnerLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsInner;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesValidatorSet
     */
    'total_voting_power'?: string;
}
/**
 * Vote represents a prevote, precommit, or commit vote from validators for consensus.
 * @export
 * @interface TendermintTypesVote
 */
export interface TendermintTypesVote {
    /**
     * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @type {string}
     * @memberof TendermintTypesVote
     */
    'type'?: TendermintTypesVoteTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    'height'?: string;
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesVote
     */
    'round'?: number;
    /**
     * 
     * @type {BlockID}
     * @memberof TendermintTypesVote
     */
    'block_id'?: BlockID;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    'validator_address'?: string;
    /**
     * 
     * @type {number}
     * @memberof TendermintTypesVote
     */
    'validator_index'?: number;
    /**
     * 
     * @type {string}
     * @memberof TendermintTypesVote
     */
    'signature'?: string;
}

export const TendermintTypesVoteTypeEnum = {
    Unknown: 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote: 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit: 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal: 'SIGNED_MSG_TYPE_PROPOSAL'
} as const;

export type TendermintTypesVoteTypeEnum = typeof TendermintTypesVoteTypeEnum[keyof typeof TendermintTypesVoteTypeEnum];

/**
 * Consensus captures the consensus rules for processing a block in the blockchain, including all blockchain data structures and the rules of the application\'s state transition machine.
 * @export
 * @interface TendermintVersionConsensus
 */
export interface TendermintVersionConsensus {
    /**
     * 
     * @type {string}
     * @memberof TendermintVersionConsensus
     */
    'block'?: string;
    /**
     * 
     * @type {string}
     * @memberof TendermintVersionConsensus
     */
    'app'?: string;
}
/**
 * QueryDelegationResponse is response type for the Query/UnbondingDelegation RPC method.
 * @export
 * @interface UnbondingDelegation200Response
 */
export interface UnbondingDelegation200Response {
    /**
     * 
     * @type {DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner}
     * @memberof UnbondingDelegation200Response
     */
    'unbond'?: DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner;
}
/**
 * QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState RPC method.
 * @export
 * @interface UpgradedConsensusState200Response
 */
export interface UpgradedConsensusState200Response {
    /**
     * 
     * @type {string}
     * @memberof UpgradedConsensusState200Response
     */
    'upgraded_consensus_state'?: string;
}
/**
 * ValidatorSigningInfo defines a validator\'s signing info for monitoring their liveness activity.
 * @export
 * @interface ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
 */
export interface ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress {
    /**
     * 
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    'start_height'?: string;
    /**
     * Index which is incremented each time the validator was a bonded in a block and may have signed a precommit or not. This in conjunction with the `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    'index_offset'?: string;
    /**
     * Timestamp until which the validator is jailed due to liveness downtime.
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    'jailed_until'?: string;
    /**
     * Whether or not a validator has been tombstoned (killed out of validator set). It is set once the validator commits an equivocation or for any other configured misbehiavor.
     * @type {boolean}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    'tombstoned'?: boolean;
    /**
     * A counter kept to avoid unnecessary array reads. Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.
     * @type {string}
     * @memberof ValSigningInfoIsTheSigningInfoOfRequestedValConsAddress
     */
    'missed_blocks_counter'?: string;
}
/**
 * QueryValidatorOutstandingRewardsResponse is the response type for the Query/ValidatorOutstandingRewards RPC method.
 * @export
 * @interface ValidatorOutstandingRewards200Response
 */
export interface ValidatorOutstandingRewards200Response {
    /**
     * 
     * @type {ValidatorOutstandingRewards200ResponseRewards}
     * @memberof ValidatorOutstandingRewards200Response
     */
    'rewards'?: ValidatorOutstandingRewards200ResponseRewards;
}
/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards for a validator inexpensive to track, allows simple sanity checks.
 * @export
 * @interface ValidatorOutstandingRewards200ResponseRewards
 */
export interface ValidatorOutstandingRewards200ResponseRewards {
    /**
     * 
     * @type {Array<CommunityPool200ResponsePoolInner>}
     * @memberof ValidatorOutstandingRewards200ResponseRewards
     */
    'rewards'?: Array<CommunityPool200ResponsePoolInner>;
}
/**
 * QueryValidatorSlashesResponse is the response type for the Query/ValidatorSlashes RPC method.
 * @export
 * @interface ValidatorSlashes200Response
 */
export interface ValidatorSlashes200Response {
    /**
     * slashes defines the slashes the validator received.
     * @type {Array<ValidatorSlashes200ResponseSlashesInner>}
     * @memberof ValidatorSlashes200Response
     */
    'slashes'?: Array<ValidatorSlashes200ResponseSlashesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof ValidatorSlashes200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * ValidatorSlashEvent represents a validator slash event. Height is implicit within the store key. This is needed to calculate appropriate amount of staking tokens for delegations which are withdrawn after a slash has occurred.
 * @export
 * @interface ValidatorSlashes200ResponseSlashesInner
 */
export interface ValidatorSlashes200ResponseSlashesInner {
    /**
     * 
     * @type {string}
     * @memberof ValidatorSlashes200ResponseSlashesInner
     */
    'validator_period'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatorSlashes200ResponseSlashesInner
     */
    'fraction'?: string;
}
/**
 * QueryValidatorUnbondingDelegationsResponse is response type for the Query/ValidatorUnbondingDelegations RPC method.
 * @export
 * @interface ValidatorUnbondingDelegations200Response
 */
export interface ValidatorUnbondingDelegations200Response {
    /**
     * 
     * @type {Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>}
     * @memberof ValidatorUnbondingDelegations200Response
     */
    'unbonding_responses'?: Array<DelegatorUnbondingDelegations200ResponseUnbondingResponsesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof ValidatorUnbondingDelegations200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * QueryVoteResponse is the response type for the Query/Vote RPC method.
 * @export
 * @interface Vote200Response
 */
export interface Vote200Response {
    /**
     * 
     * @type {Votes200ResponseVotesInner}
     * @memberof Vote200Response
     */
    'vote'?: Votes200ResponseVotesInner;
}
/**
 * QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response type.
 * @export
 * @interface VoteByProposalVoter200Response
 */
export interface VoteByProposalVoter200Response {
    /**
     * 
     * @type {VoteByProposalVoter200ResponseVote}
     * @memberof VoteByProposalVoter200Response
     */
    'vote'?: VoteByProposalVoter200ResponseVote;
}
/**
 * vote is the vote with given proposal_id and voter.
 * @export
 * @interface VoteByProposalVoter200ResponseVote
 */
export interface VoteByProposalVoter200ResponseVote {
    /**
     * proposal is the unique ID of the proposal.
     * @type {string}
     * @memberof VoteByProposalVoter200ResponseVote
     */
    'proposal_id'?: string;
    /**
     * voter is the account address of the voter.
     * @type {string}
     * @memberof VoteByProposalVoter200ResponseVote
     */
    'voter'?: string;
    /**
     * option is the voter\'s choice on the proposal.
     * @type {string}
     * @memberof VoteByProposalVoter200ResponseVote
     */
    'option'?: VoteByProposalVoter200ResponseVoteOptionEnum;
    /**
     * metadata is any arbitrary metadata to attached to the vote.
     * @type {string}
     * @memberof VoteByProposalVoter200ResponseVote
     */
    'metadata'?: string;
    /**
     * submit_time is the timestamp when the vote was submitted.
     * @type {string}
     * @memberof VoteByProposalVoter200ResponseVote
     */
    'submit_time'?: string;
}

export const VoteByProposalVoter200ResponseVoteOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type VoteByProposalVoter200ResponseVoteOptionEnum = typeof VoteByProposalVoter200ResponseVoteOptionEnum[keyof typeof VoteByProposalVoter200ResponseVoteOptionEnum];

/**
 * QueryVotesResponse is the response type for the Query/Votes RPC method.
 * @export
 * @interface Votes200Response
 */
export interface Votes200Response {
    /**
     * votes defined the queried votes.
     * @type {Array<Votes200ResponseVotesInner>}
     * @memberof Votes200Response
     */
    'votes'?: Array<Votes200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof Votes200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Vote defines a vote on a governance proposal. A Vote consists of a proposal ID, the voter, and the vote option.
 * @export
 * @interface Votes200ResponseVotesInner
 */
export interface Votes200ResponseVotesInner {
    /**
     * 
     * @type {string}
     * @memberof Votes200ResponseVotesInner
     */
    'proposal_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Votes200ResponseVotesInner
     */
    'voter'?: string;
    /**
     * Deprecated: Prefer to use `options` instead. This field is set in queries if and only if `len(options) == 1` and that option has weight 1. In all other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
     * @type {string}
     * @memberof Votes200ResponseVotesInner
     */
    'option'?: Votes200ResponseVotesInnerOptionEnum;
    /**
     * 
     * @type {Array<SinceCosmosSdk043Inner>}
     * @memberof Votes200ResponseVotesInner
     */
    'options'?: Array<SinceCosmosSdk043Inner>;
}

export const Votes200ResponseVotesInnerOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type Votes200ResponseVotesInnerOptionEnum = typeof Votes200ResponseVotesInnerOptionEnum[keyof typeof Votes200ResponseVotesInnerOptionEnum];

/**
 * QueryVotesByProposalResponse is the Query/VotesByProposal response type.
 * @export
 * @interface VotesByProposal200Response
 */
export interface VotesByProposal200Response {
    /**
     * votes are the list of votes for given proposal_id.
     * @type {Array<VotesByProposal200ResponseVotesInner>}
     * @memberof VotesByProposal200Response
     */
    'votes'?: Array<VotesByProposal200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof VotesByProposal200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}
/**
 * Vote represents a vote for a proposal.
 * @export
 * @interface VotesByProposal200ResponseVotesInner
 */
export interface VotesByProposal200ResponseVotesInner {
    /**
     * proposal is the unique ID of the proposal.
     * @type {string}
     * @memberof VotesByProposal200ResponseVotesInner
     */
    'proposal_id'?: string;
    /**
     * voter is the account address of the voter.
     * @type {string}
     * @memberof VotesByProposal200ResponseVotesInner
     */
    'voter'?: string;
    /**
     * option is the voter\'s choice on the proposal.
     * @type {string}
     * @memberof VotesByProposal200ResponseVotesInner
     */
    'option'?: VotesByProposal200ResponseVotesInnerOptionEnum;
    /**
     * metadata is any arbitrary metadata to attached to the vote.
     * @type {string}
     * @memberof VotesByProposal200ResponseVotesInner
     */
    'metadata'?: string;
    /**
     * submit_time is the timestamp when the vote was submitted.
     * @type {string}
     * @memberof VotesByProposal200ResponseVotesInner
     */
    'submit_time'?: string;
}

export const VotesByProposal200ResponseVotesInnerOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
} as const;

export type VotesByProposal200ResponseVotesInnerOptionEnum = typeof VotesByProposal200ResponseVotesInnerOptionEnum[keyof typeof VotesByProposal200ResponseVotesInnerOptionEnum];

/**
 * QueryVotesByVoterResponse is the Query/VotesByVoter response type.
 * @export
 * @interface VotesByVoter200Response
 */
export interface VotesByVoter200Response {
    /**
     * votes are the list of votes by given voter.
     * @type {Array<VotesByProposal200ResponseVotesInner>}
     * @memberof VotesByVoter200Response
     */
    'votes'?: Array<VotesByProposal200ResponseVotesInner>;
    /**
     * 
     * @type {Accounts200ResponsePagination}
     * @memberof VotesByVoter200Response
     */
    'pagination'?: Accounts200ResponsePagination;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Class queries an NFT class based on its id
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _class: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('_class', 'classId', classId)
            const localVarPath = `/cosmos/nft/v1beta1/classes/{class_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('account', 'address', address)
            const localVarPath = `/cosmos/auth/v1beta1/accounts/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46.2
         * @summary AccountAddressByID returns account address based on account number.
         * @param {string} id id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAddressByID: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountAddressByID', 'id', id)
            const localVarPath = `/cosmos/auth/v1beta1/address_by_id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.43
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/auth/v1beta1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AddressBytesToString converts Account Address bytes to string
         * @param {string} addressBytes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressBytesToString: async (addressBytes: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressBytes' is not null or undefined
            assertParamExists('addressBytesToString', 'addressBytes', addressBytes)
            const localVarPath = `/cosmos/auth/v1beta1/bech32/{address_bytes}`
                .replace(`{${"address_bytes"}}`, encodeURIComponent(String(addressBytes)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AddressStringToBytes converts Address string to bytes
         * @param {string} addressString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStringToBytes: async (addressString: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressString' is not null or undefined
            assertParamExists('addressStringToBytes', 'addressString', addressString)
            const localVarPath = `/cosmos/auth/v1beta1/bech32/{address_string}`
                .replace(`{${"address_string"}}`, encodeURIComponent(String(addressString)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances: async (address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('allBalances', 'address', address)
            const localVarPath = `/cosmos/bank/v1beta1/balances/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/evidence/v1beta1/evidence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowance: async (granter: string, grantee: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'granter' is not null or undefined
            assertParamExists('allowance', 'granter', granter)
            // verify required parameter 'grantee' is not null or undefined
            assertParamExists('allowance', 'grantee', grantee)
            const localVarPath = `/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}`
                .replace(`{${"granter"}}`, encodeURIComponent(String(granter)))
                .replace(`{${"grantee"}}`, encodeURIComponent(String(grantee)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowances: async (grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantee' is not null or undefined
            assertParamExists('allowances', 'grantee', grantee)
            const localVarPath = `/cosmos/feegrant/v1beta1/allowances/{grantee}`
                .replace(`{${"grantee"}}`, encodeURIComponent(String(grantee)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AllowancesByGranter returns all the grants given by an address
         * @param {string} granter 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesByGranter: async (granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'granter' is not null or undefined
            assertParamExists('allowancesByGranter', 'granter', granter)
            const localVarPath = `/cosmos/feegrant/v1beta1/issued/{granter}`
                .replace(`{${"granter"}}`, encodeURIComponent(String(granter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/mint/v1beta1/annual_provisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('appliedPlan', 'name', name)
            const localVarPath = `/cosmos/upgrade/v1beta1/applied_plan/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/auth/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Returns the account with authority to conduct upgrades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authority: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/upgrade/v1beta1/authority`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [denom] denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: async (address: string, denom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('balance', 'address', address)
            const localVarPath = `/cosmos/bank/v1beta1/balances/{address}/by_denom`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (denom !== undefined) {
                localVarQueryParameter['denom'] = denom;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/bank/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Bech32Prefix queries bech32Prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bech32Prefix: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/auth/v1beta1/bech32`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Classes queries all NFT classes
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classes: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/nft/v1beta1/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/distribution/v1beta1/community_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/upgrade/v1beta1/current_plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation: async (validatorAddr: string, delegatorAddr: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('delegation', 'validatorAddr', validatorAddr)
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegation', 'delegatorAddr', delegatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)))
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards: async (delegatorAddress: string, validatorAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegationRewards', 'delegatorAddress', delegatorAddress)
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('delegationRewards', 'validatorAddress', validatorAddress)
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)))
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards: async (delegatorAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegationTotalRewards', 'delegatorAddress', delegatorAddress)
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations: async (delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegatorDelegations', 'delegatorAddr', delegatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/delegations/{delegator_addr}`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations: async (delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegatorUnbondingDelegations', 'delegatorAddr', delegatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator: async (delegatorAddr: string, validatorAddr: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegatorValidator', 'delegatorAddr', delegatorAddr)
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('delegatorValidator', 'validatorAddr', validatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators: async (delegatorAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegatorValidators', 'delegatorAddress', delegatorAddress)
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress: async (delegatorAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegatorWithdrawAddress', 'delegatorAddress', delegatorAddress)
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomMetadata: async (denom: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('denomMetadata', 'denom', denom)
            const localVarPath = `/cosmos/bank/v1beta1/denoms_metadata/{denom}`
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomOwners: async (denom: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('denomOwners', 'denom', denom)
            const localVarPath = `/cosmos/bank/v1beta1/denom_owners/{denom}`
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomsMetadata: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/bank/v1beta1/denoms_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: async (proposalId: string, depositor: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('deposit', 'proposalId', proposalId)
            // verify required parameter 'depositor' is not null or undefined
            assertParamExists('deposit', 'depositor', depositor)
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"depositor"}}`, encodeURIComponent(String(depositor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits: async (proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('deposits', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/distribution/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence: async (evidenceHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'evidenceHash' is not null or undefined
            assertParamExists('evidence', 'evidenceHash', evidenceHash)
            const localVarPath = `/cosmos/evidence/v1beta1/evidence/{evidence_hash}`
                .replace(`{${"evidence_hash"}}`, encodeURIComponent(String(evidenceHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams: async (paramsType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsType' is not null or undefined
            assertParamExists('govParams', 'paramsType', paramsType)
            const localVarPath = `/cosmos/gov/v1beta1/params/{params_type}`
                .replace(`{${"params_type"}}`, encodeURIComponent(String(paramsType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Deposit: async (proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govV1Deposit', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1/proposals/{proposal_id}/deposits`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Deposit_1: async (proposalId: string, depositor: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govV1Deposit_1', 'proposalId', proposalId)
            // verify required parameter 'depositor' is not null or undefined
            assertParamExists('govV1Deposit_1', 'depositor', depositor)
            const localVarPath = `/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"depositor"}}`, encodeURIComponent(String(depositor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Params: async (paramsType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramsType' is not null or undefined
            assertParamExists('govV1Params', 'paramsType', paramsType)
            const localVarPath = `/cosmos/gov/v1/params/{params_type}`
                .replace(`{${"params_type"}}`, encodeURIComponent(String(paramsType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Proposal: async (proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/gov/v1/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (proposalStatus !== undefined) {
                localVarQueryParameter['proposal_status'] = proposalStatus;
            }

            if (voter !== undefined) {
                localVarQueryParameter['voter'] = voter;
            }

            if (depositor !== undefined) {
                localVarQueryParameter['depositor'] = depositor;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Proposal_2: async (proposalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govV1Proposal_2', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1/proposals/{proposal_id}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1TallyResult: async (proposalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govV1TallyResult', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1/proposals/{proposal_id}/tally`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the voter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Vote: async (proposalId: string, voter: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govV1Vote', 'proposalId', proposalId)
            // verify required parameter 'voter' is not null or undefined
            assertParamExists('govV1Vote', 'voter', voter)
            const localVarPath = `/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Votes: async (proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govV1Votes', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1/proposals/{proposal_id}/votes`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary GranteeGrants returns a list of `GrantAuthorization` by grantee.
         * @param {string} grantee 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        granteeGrants: async (grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantee' is not null or undefined
            assertParamExists('granteeGrants', 'grantee', grantee)
            const localVarPath = `/cosmos/authz/v1beta1/grants/grantee/{grantee}`
                .replace(`{${"grantee"}}`, encodeURIComponent(String(grantee)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary GranterGrants returns list of `GrantAuthorization`, granted by granter.
         * @param {string} granter 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        granterGrants: async (granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'granter' is not null or undefined
            assertParamExists('granterGrants', 'granter', granter)
            const localVarPath = `/cosmos/authz/v1beta1/grants/granter/{granter}`
                .replace(`{${"granter"}}`, encodeURIComponent(String(granter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter] 
         * @param {string} [grantee] 
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grants: async (granter?: string, grantee?: string, msgTypeUrl?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/authz/v1beta1/grants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (granter !== undefined) {
                localVarQueryParameter['granter'] = granter;
            }

            if (grantee !== undefined) {
                localVarQueryParameter['grantee'] = grantee;
            }

            if (msgTypeUrl !== undefined) {
                localVarQueryParameter['msg_type_url'] = msgTypeUrl;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GroupInfo queries group info based on group id.
         * @param {string} groupId group_id is the unique ID of the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInfo: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInfo', 'groupId', groupId)
            const localVarPath = `/cosmos/group/v1/group_info/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GroupMembers queries members of a group
         * @param {string} groupId group_id is the unique ID of the group.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupMembers: async (groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupMembers', 'groupId', groupId)
            const localVarPath = `/cosmos/group/v1/group_members/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GroupsByAdmin queries group policies by admin address.
         * @param {string} admin admin is the admin address of the group policy.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupPoliciesByAdmin: async (admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'admin' is not null or undefined
            assertParamExists('groupPoliciesByAdmin', 'admin', admin)
            const localVarPath = `/cosmos/group/v1/group_policies_by_admin/{admin}`
                .replace(`{${"admin"}}`, encodeURIComponent(String(admin)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GroupPoliciesByGroup queries group policies by group id.
         * @param {string} groupId group_id is the unique ID of the group policy\&#39;s group.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupPoliciesByGroup: async (groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupPoliciesByGroup', 'groupId', groupId)
            const localVarPath = `/cosmos/group/v1/group_policies_by_group/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GroupPolicyInfo queries group policy info based on account address of group policy.
         * @param {string} address address is the account address of the group policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupPolicyInfo: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('groupPolicyInfo', 'address', address)
            const localVarPath = `/cosmos/group/v1/group_policy_info/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proposal queries a proposal based on proposal id.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupProposal: async (proposalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('groupProposal', 'proposalId', proposalId)
            const localVarPath = `/cosmos/group/v1/proposal/{proposal_id}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TallyResult returns the tally result of a proposal. If the proposal is still in voting period, then this query computes the current tally state, which might not be final. On the other hand, if the proposal is final, then it simply returns the `final_tally_result` state stored in the proposal itself.
         * @param {string} proposalId proposal_id is the unique id of a proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupTallyResult: async (proposalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('groupTallyResult', 'proposalId', proposalId)
            const localVarPath = `/cosmos/group/v1/proposals/{proposal_id}/tally`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GroupsByAdmin queries groups by admin address.
         * @param {string} admin admin is the account address of a group\&#39;s admin.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsByAdmin: async (admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'admin' is not null or undefined
            assertParamExists('groupsByAdmin', 'admin', admin)
            const localVarPath = `/cosmos/group/v1/groups_by_admin/{admin}`
                .replace(`{${"admin"}}`, encodeURIComponent(String(admin)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GroupsByMember queries groups by member address.
         * @param {string} address address is the group member address.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsByMember: async (address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('groupsByMember', 'address', address)
            const localVarPath = `/cosmos/group/v1/groups_by_member/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo: async (height: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('historicalInfo', 'height', height)
            const localVarPath = `/cosmos/staking/v1beta1/historical_info/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/mint/v1beta1/inflation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/mint/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ModuleAccountByName returns the module account info by module name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccountByName: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('moduleAccountByName', 'name', name)
            const localVarPath = `/cosmos/auth/v1beta1/module_accounts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary ModuleAccounts returns all the existing module accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/auth/v1beta1/module_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.43
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersions: async (moduleName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/upgrade/v1beta1/module_versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (moduleName !== undefined) {
                localVarQueryParameter['module_name'] = moduleName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NFT queries an NFT based on its class and id.
         * @param {string} classId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFT: async (classId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('nFT', 'classId', classId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('nFT', 'id', id)
            const localVarPath = `/cosmos/nft/v1beta1/nfts/{class_id}/{id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in ERC721Enumerable
         * @param {string} [classId] 
         * @param {string} [owner] 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFTs: async (classId?: string, owner?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/nft/v1beta1/nfts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (classId !== undefined) {
                localVarQueryParameter['class_id'] = classId;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721
         * @param {string} owner 
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftBalance: async (owner: string, classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('nftBalance', 'owner', owner)
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('nftBalance', 'classId', classId)
            const localVarPath = `/cosmos/nft/v1beta1/balance/{owner}/{class_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721
         * @param {string} classId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        owner: async (classId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('owner', 'classId', classId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('owner', 'id', id)
            const localVarPath = `/cosmos/nft/v1beta1/owner/{class_id}/{id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params: async (subspace?: string, key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/params/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subspace !== undefined) {
                localVarQueryParameter['subspace'] = subspace;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/staking/v1beta1/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal: async (proposalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('proposal', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals: async (proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/gov/v1beta1/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (proposalStatus !== undefined) {
                localVarQueryParameter['proposal_status'] = proposalStatus;
            }

            if (voter !== undefined) {
                localVarQueryParameter['voter'] = voter;
            }

            if (depositor !== undefined) {
                localVarQueryParameter['depositor'] = depositor;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ProposalsByGroupPolicy queries proposals based on account address of group policy.
         * @param {string} address address is the account address of the group policy related to proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposalsByGroupPolicy: async (address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('proposalsByGroupPolicy', 'address', address)
            const localVarPath = `/cosmos/group/v1/proposals_by_group_policy/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations: async (delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('redelegations', 'delegatorAddr', delegatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (srcValidatorAddr !== undefined) {
                localVarQueryParameter['src_validator_addr'] = srcValidatorAddr;
            }

            if (dstValidatorAddr !== undefined) {
                localVarQueryParameter['dst_validator_addr'] = dstValidatorAddr;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo: async (consAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consAddress' is not null or undefined
            assertParamExists('signingInfo', 'consAddress', consAddress)
            const localVarPath = `/cosmos/slashing/v1beta1/signing_infos/{cons_address}`
                .replace(`{${"cons_address"}}`, encodeURIComponent(String(consAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/slashing/v1beta1/signing_infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/slashing/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary SpendableBalances queries the spenable balance of all coins for a single account.
         * @param {string} address address is the address to query spendable balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spendableBalances: async (address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('spendableBalances', 'address', address)
            const localVarPath = `/cosmos/bank/v1beta1/spendable_balances/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators: async (delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorValidators', 'delegatorAddr', delegatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/staking/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Subspaces queries for all registered subspaces and all keys for a subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subspaces: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/params/v1beta1/subspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supply: async (classId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classId' is not null or undefined
            assertParamExists('supply', 'classId', classId)
            const localVarPath = `/cosmos/nft/v1beta1/supply/{class_id}`
                .replace(`{${"class_id"}}`, encodeURIComponent(String(classId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} [denom] denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf: async (denom?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/bank/v1beta1/supply/by_denom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (denom !== undefined) {
                localVarQueryParameter['denom'] = denom;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult: async (proposalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('tallyResult', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/tally`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/bank/v1beta1/supply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation: async (validatorAddr: string, delegatorAddr: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('unbondingDelegation', 'validatorAddr', validatorAddr)
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('unbondingDelegation', 'delegatorAddr', delegatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)))
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier This rpc is deprecated now that IBC has its own replacement (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState: async (lastHeight: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lastHeight' is not null or undefined
            assertParamExists('upgradedConsensusState', 'lastHeight', lastHeight)
            const localVarPath = `/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}`
                .replace(`{${"last_height"}}`, encodeURIComponent(String(lastHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator: async (validatorAddr: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('validator', 'validatorAddr', validatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission: async (validatorAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('validatorCommission', 'validatorAddress', validatorAddress)
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/commission`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations: async (validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('validatorDelegations', 'validatorAddr', validatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards: async (validatorAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('validatorOutstandingRewards', 'validatorAddress', validatorAddress)
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes: async (validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('validatorSlashes', 'validatorAddress', validatorAddress)
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/slashes`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startingHeight !== undefined) {
                localVarQueryParameter['starting_height'] = startingHeight;
            }

            if (endingHeight !== undefined) {
                localVarQueryParameter['ending_height'] = endingHeight;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations: async (validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('validatorUnbondingDelegations', 'validatorAddr', validatorAddr)
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators: async (status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/staking/v1beta1/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the voter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote: async (proposalId: string, voter: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('vote', 'proposalId', proposalId)
            // verify required parameter 'voter' is not null or undefined
            assertParamExists('vote', 'voter', voter)
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary VoteByProposalVoter queries a vote by proposal id and voter.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {string} voter voter is a proposal voter account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteByProposalVoter: async (proposalId: string, voter: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('voteByProposalVoter', 'proposalId', proposalId)
            // verify required parameter 'voter' is not null or undefined
            assertParamExists('voteByProposalVoter', 'voter', voter)
            const localVarPath = `/cosmos/group/v1/vote_by_proposal_voter/{proposal_id}/{voter}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes: async (proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('votes', 'proposalId', proposalId)
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/votes`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary VotesByProposal queries a vote by proposal.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesByProposal: async (proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('votesByProposal', 'proposalId', proposalId)
            const localVarPath = `/cosmos/group/v1/votes_by_proposal/{proposal_id}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary VotesByVoter queries a vote by voter.
         * @param {string} voter voter is a proposal voter account address.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesByVoter: async (voter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voter' is not null or undefined
            assertParamExists('votesByVoter', 'voter', voter)
            const localVarPath = `/cosmos/group/v1/votes_by_voter/{voter}`
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Class queries an NFT class based on its id
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _class(classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._class(classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async account(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.account(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46.2
         * @summary AccountAddressByID returns account address based on account number.
         * @param {string} id id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAddressByID(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountAddressByID(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.43
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Accounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AddressBytesToString converts Account Address bytes to string
         * @param {string} addressBytes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressBytesToString(addressBytes: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressBytesToString200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressBytesToString(addressBytes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AddressStringToBytes converts Address string to bytes
         * @param {string} addressString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressStringToBytes(addressString: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressStringToBytes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressStringToBytes(addressString, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllBalances200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allEvidence(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllEvidence200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowance(granter: string, grantee: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allowance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowance(granter, grantee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowances(grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allowances200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AllowancesByGranter returns all the grants given by an address
         * @param {string} granter 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowancesByGranter(granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllowancesByGranter200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowancesByGranter(granter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annualProvisions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnualProvisions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annualProvisions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliedPlan(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppliedPlan200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appliedPlan(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Returns the account with authority to conduct upgrades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authority(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryAuthorityResponseIsTheResponseTypeForQueryAuthority>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authority(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [denom] denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balance(address: string, denom?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Balance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balance(address, denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Bech32Prefix queries bech32Prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bech32Prefix(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bech32Prefix200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bech32Prefix(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Classes queries all NFT classes
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classes(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classes(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityPool(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityPool200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityPool(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentPlan(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentPlan200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentPlan(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegation(validatorAddr: string, delegatorAddr: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Delegation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegation(validatorAddr, delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegationRewards(delegatorAddress: string, validatorAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegationRewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegationRewards(delegatorAddress, validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegationTotalRewards(delegatorAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegationTotalRewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegationTotalRewards(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegatorDelegations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorUnbondingDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegatorUnbondingDelegations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorValidator(delegatorAddr: string, validatorAddr: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegatorValidator200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorValidator(delegatorAddr, validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorValidators(delegatorAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegatorValidators200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorValidators(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorWithdrawAddress(delegatorAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelegatorWithdrawAddress200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorWithdrawAddress(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomMetadata(denom: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DenomMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomMetadata(denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomOwners(denom: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DenomOwners200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomsMetadata(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DenomsMetadata200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposit(proposalId: string, depositor: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposit200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposit(proposalId, depositor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposits(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistributionParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evidence(evidenceHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evidence200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evidence(evidenceHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govParams(paramsType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govParams(paramsType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1Deposit(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1Deposit(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1Deposit_1(proposalId: string, depositor: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Deposit200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1Deposit_1(proposalId, depositor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1Params(paramsType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovV1Params200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1Params(paramsType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1Proposal(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovV1Proposal200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1Proposal(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1Proposal_2(proposalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovV1Proposal200Response1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1Proposal_2(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1TallyResult(proposalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovV1TallyResult200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1TallyResult(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the voter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1Vote(proposalId: string, voter: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovV1Vote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1Vote(proposalId, voter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govV1Votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GovV1Votes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govV1Votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary GranteeGrants returns a list of `GrantAuthorization` by grantee.
         * @param {string} grantee 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async granteeGrants(grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GranteeGrants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.granteeGrants(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary GranterGrants returns list of `GrantAuthorization`, granted by granter.
         * @param {string} granter 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async granterGrants(granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GranterGrants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.granterGrants(granter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter] 
         * @param {string} [grantee] 
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grants(granter?: string, grantee?: string, msgTypeUrl?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grants200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GroupInfo queries group info based on group id.
         * @param {string} groupId group_id is the unique ID of the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInfo(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInfo(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GroupMembers queries members of a group
         * @param {string} groupId group_id is the unique ID of the group.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupMembers(groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupMembers(groupId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GroupsByAdmin queries group policies by admin address.
         * @param {string} admin admin is the admin address of the group policy.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupPoliciesByAdmin(admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPoliciesByAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupPoliciesByAdmin(admin, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GroupPoliciesByGroup queries group policies by group id.
         * @param {string} groupId group_id is the unique ID of the group policy\&#39;s group.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupPoliciesByGroup(groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPoliciesByGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupPoliciesByGroup(groupId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GroupPolicyInfo queries group policy info based on account address of group policy.
         * @param {string} address address is the account address of the group policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupPolicyInfo(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPolicyInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupPolicyInfo(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Proposal queries a proposal based on proposal id.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupProposal(proposalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupProposal200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupProposal(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TallyResult returns the tally result of a proposal. If the proposal is still in voting period, then this query computes the current tally state, which might not be final. On the other hand, if the proposal is final, then it simply returns the `final_tally_result` state stored in the proposal itself.
         * @param {string} proposalId proposal_id is the unique id of a proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupTallyResult(proposalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupTallyResult200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupTallyResult(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GroupsByAdmin queries groups by admin address.
         * @param {string} admin admin is the account address of a group\&#39;s admin.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsByAdmin(admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsByAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsByAdmin(admin, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GroupsByMember queries groups by member address.
         * @param {string} address address is the group member address.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsByMember(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsByMember200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsByMember(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historicalInfo(height: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoricalInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.historicalInfo(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inflation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inflation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inflation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MintParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ModuleAccountByName returns the module account info by module name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleAccountByName(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleAccountByName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleAccountByName(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary ModuleAccounts returns all the existing module accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleAccounts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleAccounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.43
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleVersions(moduleName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleVersions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleVersions(moduleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary NFT queries an NFT based on its class and id.
         * @param {string} classId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nFT(classId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nFT(classId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in ERC721Enumerable
         * @param {string} [classId] 
         * @param {string} [owner] 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nFTs(classId?: string, owner?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nFTs(classId, owner, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721
         * @param {string} owner 
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nftBalance(owner: string, classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nftBalance(owner, classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721
         * @param {string} classId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async owner(classId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.owner(classId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async params(subspace?: string, key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Params200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.params(subspace, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pool(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pool200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pool(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proposal(proposalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proposal200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proposal(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proposals(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proposals200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ProposalsByGroupPolicy queries proposals based on account address of group policy.
         * @param {string} address address is the account address of the group policy related to proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proposalsByGroupPolicy(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProposalsByGroupPolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proposalsByGroupPolicy(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redelegations(delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Redelegations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signingInfo(consAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signingInfo(consAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signingInfos(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slashingParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slashingParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary SpendableBalances queries the spenable balance of all coins for a single account.
         * @param {string} address address is the address to query spendable balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spendableBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SpendableBalances200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spendableBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorValidators(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingDelegatorValidators200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakingParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Subspaces queries for all registered subspaces and all keys for a subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subspaces(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subspaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subspaces(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supply(classId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supply(classId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} [denom] denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplyOf(denom?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplyOf200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplyOf(denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tallyResult(proposalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TallyResult200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tallyResult(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totalSupply(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbondingDelegation(validatorAddr: string, delegatorAddr: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnbondingDelegation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbondingDelegation(validatorAddr, delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier This rpc is deprecated now that IBC has its own replacement (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradedConsensusState(lastHeight: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradedConsensusState200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradedConsensusState(lastHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validator(validatorAddr: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validator(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorCommission(validatorAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorCommission(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorOutstandingRewards(validatorAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorOutstandingRewards200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorOutstandingRewards(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorSlashes(validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorSlashes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorUnbondingDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorUnbondingDelegations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validators(status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the voter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vote(proposalId: string, voter: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vote200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vote(proposalId, voter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary VoteByProposalVoter queries a vote by proposal id and voter.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {string} voter voter is a proposal voter account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voteByProposalVoter(proposalId: string, voter: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoteByProposalVoter200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voteByProposalVoter(proposalId, voter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Votes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary VotesByProposal queries a vote by proposal.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votesByProposal(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VotesByProposal200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votesByProposal(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary VotesByVoter queries a vote by voter.
         * @param {string} voter voter is a proposal voter account address.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votesByVoter(voter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VotesByVoter200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votesByVoter(voter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryApiFp(configuration)
    return {
        /**
         * 
         * @summary Class queries an NFT class based on its id
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _class(classId: string, options?: any): AxiosPromise<QueryClassResponseIsTheResponseTypeForTheQueryClassRPCMethod> {
            return localVarFp._class(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account(address: string, options?: any): AxiosPromise<Account200Response> {
            return localVarFp.account(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46.2
         * @summary AccountAddressByID returns account address based on account number.
         * @param {string} id id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAddressByID(id: string, options?: any): AxiosPromise<QueryAccountAddressByIDResponseIsTheResponseTypeForAccountAddressByIDRpcMethod> {
            return localVarFp.accountAddressByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.43
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Accounts200Response> {
            return localVarFp.accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AddressBytesToString converts Account Address bytes to string
         * @param {string} addressBytes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressBytesToString(addressBytes: string, options?: any): AxiosPromise<AddressBytesToString200Response> {
            return localVarFp.addressBytesToString(addressBytes, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AddressStringToBytes converts Address string to bytes
         * @param {string} addressString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStringToBytes(addressString: string, options?: any): AxiosPromise<AddressStringToBytes200Response> {
            return localVarFp.addressStringToBytes(addressString, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<AllBalances200Response> {
            return localVarFp.allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<AllEvidence200Response> {
            return localVarFp.allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowance(granter: string, grantee: string, options?: any): AxiosPromise<Allowance200Response> {
            return localVarFp.allowance(granter, grantee, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowances(grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Allowances200Response> {
            return localVarFp.allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary AllowancesByGranter returns all the grants given by an address
         * @param {string} granter 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowancesByGranter(granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<AllowancesByGranter200Response> {
            return localVarFp.allowancesByGranter(granter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions(options?: any): AxiosPromise<AnnualProvisions200Response> {
            return localVarFp.annualProvisions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan(name: string, options?: any): AxiosPromise<AppliedPlan200Response> {
            return localVarFp.appliedPlan(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams(options?: any): AxiosPromise<AuthParams200Response> {
            return localVarFp.authParams(options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Returns the account with authority to conduct upgrades
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authority(options?: any): AxiosPromise<QueryAuthorityResponseIsTheResponseTypeForQueryAuthority> {
            return localVarFp.authority(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [denom] denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance(address: string, denom?: string, options?: any): AxiosPromise<Balance200Response> {
            return localVarFp.balance(address, denom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams(options?: any): AxiosPromise<BankParams200Response> {
            return localVarFp.bankParams(options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Bech32Prefix queries bech32Prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bech32Prefix(options?: any): AxiosPromise<Bech32Prefix200Response> {
            return localVarFp.bech32Prefix(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Classes queries all NFT classes
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classes(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryClassesResponseIsTheResponseTypeForTheQueryClassesRPCMethod> {
            return localVarFp.classes(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool(options?: any): AxiosPromise<CommunityPool200Response> {
            return localVarFp.communityPool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan(options?: any): AxiosPromise<CurrentPlan200Response> {
            return localVarFp.currentPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation(validatorAddr: string, delegatorAddr: string, options?: any): AxiosPromise<Delegation200Response> {
            return localVarFp.delegation(validatorAddr, delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards(delegatorAddress: string, validatorAddress: string, options?: any): AxiosPromise<DelegationRewards200Response> {
            return localVarFp.delegationRewards(delegatorAddress, validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards(delegatorAddress: string, options?: any): AxiosPromise<DelegationTotalRewards200Response> {
            return localVarFp.delegationTotalRewards(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<DelegatorDelegations200Response> {
            return localVarFp.delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<DelegatorUnbondingDelegations200Response> {
            return localVarFp.delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator(delegatorAddr: string, validatorAddr: string, options?: any): AxiosPromise<DelegatorValidator200Response> {
            return localVarFp.delegatorValidator(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators(delegatorAddress: string, options?: any): AxiosPromise<DelegatorValidators200Response> {
            return localVarFp.delegatorValidators(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress(delegatorAddress: string, options?: any): AxiosPromise<DelegatorWithdrawAddress200Response> {
            return localVarFp.delegatorWithdrawAddress(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomMetadata(denom: string, options?: any): AxiosPromise<DenomMetadata200Response> {
            return localVarFp.denomMetadata(denom, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomOwners(denom: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<DenomOwners200Response> {
            return localVarFp.denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomsMetadata(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<DenomsMetadata200Response> {
            return localVarFp.denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(proposalId: string, depositor: string, options?: any): AxiosPromise<Deposit200Response> {
            return localVarFp.deposit(proposalId, depositor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Deposits200Response> {
            return localVarFp.deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams(options?: any): AxiosPromise<DistributionParams200Response> {
            return localVarFp.distributionParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence(evidenceHash: string, options?: any): AxiosPromise<Evidence200Response> {
            return localVarFp.evidence(evidenceHash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams(paramsType: string, options?: any): AxiosPromise<GovParams200Response> {
            return localVarFp.govParams(paramsType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Deposit(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Deposits200Response> {
            return localVarFp.govV1Deposit(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Deposit_1(proposalId: string, depositor: string, options?: any): AxiosPromise<Deposit200Response> {
            return localVarFp.govV1Deposit_1(proposalId, depositor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Params(paramsType: string, options?: any): AxiosPromise<GovV1Params200Response> {
            return localVarFp.govV1Params(paramsType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Proposal(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GovV1Proposal200Response> {
            return localVarFp.govV1Proposal(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Proposal_2(proposalId: string, options?: any): AxiosPromise<GovV1Proposal200Response1> {
            return localVarFp.govV1Proposal_2(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1TallyResult(proposalId: string, options?: any): AxiosPromise<GovV1TallyResult200Response> {
            return localVarFp.govV1TallyResult(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the voter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Vote(proposalId: string, voter: string, options?: any): AxiosPromise<GovV1Vote200Response> {
            return localVarFp.govV1Vote(proposalId, voter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govV1Votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GovV1Votes200Response> {
            return localVarFp.govV1Votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary GranteeGrants returns a list of `GrantAuthorization` by grantee.
         * @param {string} grantee 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        granteeGrants(grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GranteeGrants200Response> {
            return localVarFp.granteeGrants(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary GranterGrants returns list of `GrantAuthorization`, granted by granter.
         * @param {string} granter 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        granterGrants(granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GranterGrants200Response> {
            return localVarFp.granterGrants(granter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter] 
         * @param {string} [grantee] 
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grants(granter?: string, grantee?: string, msgTypeUrl?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Grants200Response> {
            return localVarFp.grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GroupInfo queries group info based on group id.
         * @param {string} groupId group_id is the unique ID of the group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInfo(groupId: string, options?: any): AxiosPromise<GroupInfo200Response> {
            return localVarFp.groupInfo(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GroupMembers queries members of a group
         * @param {string} groupId group_id is the unique ID of the group.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupMembers(groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GroupMembers200Response> {
            return localVarFp.groupMembers(groupId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GroupsByAdmin queries group policies by admin address.
         * @param {string} admin admin is the admin address of the group policy.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupPoliciesByAdmin(admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GroupPoliciesByAdmin200Response> {
            return localVarFp.groupPoliciesByAdmin(admin, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GroupPoliciesByGroup queries group policies by group id.
         * @param {string} groupId group_id is the unique ID of the group policy\&#39;s group.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupPoliciesByGroup(groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GroupPoliciesByGroup200Response> {
            return localVarFp.groupPoliciesByGroup(groupId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GroupPolicyInfo queries group policy info based on account address of group policy.
         * @param {string} address address is the account address of the group policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupPolicyInfo(address: string, options?: any): AxiosPromise<GroupPolicyInfo200Response> {
            return localVarFp.groupPolicyInfo(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proposal queries a proposal based on proposal id.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupProposal(proposalId: string, options?: any): AxiosPromise<GroupProposal200Response> {
            return localVarFp.groupProposal(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TallyResult returns the tally result of a proposal. If the proposal is still in voting period, then this query computes the current tally state, which might not be final. On the other hand, if the proposal is final, then it simply returns the `final_tally_result` state stored in the proposal itself.
         * @param {string} proposalId proposal_id is the unique id of a proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupTallyResult(proposalId: string, options?: any): AxiosPromise<GroupTallyResult200Response> {
            return localVarFp.groupTallyResult(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GroupsByAdmin queries groups by admin address.
         * @param {string} admin admin is the account address of a group\&#39;s admin.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsByAdmin(admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GroupsByAdmin200Response> {
            return localVarFp.groupsByAdmin(admin, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GroupsByMember queries groups by member address.
         * @param {string} address address is the group member address.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsByMember(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GroupsByMember200Response> {
            return localVarFp.groupsByMember(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo(height: string, options?: any): AxiosPromise<HistoricalInfo200Response> {
            return localVarFp.historicalInfo(height, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation(options?: any): AxiosPromise<Inflation200Response> {
            return localVarFp.inflation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams(options?: any): AxiosPromise<MintParams200Response> {
            return localVarFp.mintParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ModuleAccountByName returns the module account info by module name
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccountByName(name: string, options?: any): AxiosPromise<ModuleAccountByName200Response> {
            return localVarFp.moduleAccountByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary ModuleAccounts returns all the existing module accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleAccounts(options?: any): AxiosPromise<ModuleAccounts200Response> {
            return localVarFp.moduleAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.43
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersions(moduleName?: string, options?: any): AxiosPromise<ModuleVersions200Response> {
            return localVarFp.moduleVersions(moduleName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary NFT queries an NFT based on its class and id.
         * @param {string} classId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFT(classId: string, id: string, options?: any): AxiosPromise<QueryNFTResponseIsTheResponseTypeForTheQueryNFTRPCMethod> {
            return localVarFp.nFT(classId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in ERC721Enumerable
         * @param {string} [classId] 
         * @param {string} [owner] 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nFTs(classId?: string, owner?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryNFTsResponseIsTheResponseTypeForTheQueryNFTsRPCMethods> {
            return localVarFp.nFTs(classId, owner, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721
         * @param {string} owner 
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nftBalance(owner: string, classId: string, options?: any): AxiosPromise<QueryBalanceResponseIsTheResponseTypeForTheQueryBalanceRPCMethod> {
            return localVarFp.nftBalance(owner, classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721
         * @param {string} classId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        owner(classId: string, id: string, options?: any): AxiosPromise<QueryOwnerResponseIsTheResponseTypeForTheQueryOwnerRPCMethod> {
            return localVarFp.owner(classId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params(subspace?: string, key?: string, options?: any): AxiosPromise<Params200Response> {
            return localVarFp.params(subspace, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(options?: any): AxiosPromise<Pool200Response> {
            return localVarFp.pool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal(proposalId: string, options?: any): AxiosPromise<Proposal200Response> {
            return localVarFp.proposal(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Proposals200Response> {
            return localVarFp.proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ProposalsByGroupPolicy queries proposals based on account address of group policy.
         * @param {string} address address is the account address of the group policy related to proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposalsByGroupPolicy(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<ProposalsByGroupPolicy200Response> {
            return localVarFp.proposalsByGroupPolicy(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations(delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Redelegations200Response> {
            return localVarFp.redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo(consAddress: string, options?: any): AxiosPromise<QuerySigningInfoResponseIsTheResponseTypeForTheQuerySigningInfoRPCMethod> {
            return localVarFp.signingInfo(consAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QuerySigningInfosResponseIsTheResponseTypeForTheQuerySigningInfosRPCMethod> {
            return localVarFp.signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams(options?: any): AxiosPromise<QueryParamsResponseIsTheResponseTypeForTheQueryParamsRPCMethod> {
            return localVarFp.slashingParams(options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary SpendableBalances queries the spenable balance of all coins for a single account.
         * @param {string} address address is the address to query spendable balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spendableBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<SpendableBalances200Response> {
            return localVarFp.spendableBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<StakingDelegatorValidators200Response> {
            return localVarFp.stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams(options?: any): AxiosPromise<StakingParams200Response> {
            return localVarFp.stakingParams(options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.46
         * @summary Subspaces queries for all registered subspaces and all keys for a subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subspaces(options?: any): AxiosPromise<Subspaces200Response> {
            return localVarFp.subspaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.
         * @param {string} classId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supply(classId: string, options?: any): AxiosPromise<QuerySupplyResponseIsTheResponseTypeForTheQuerySupplyRPCMethod> {
            return localVarFp.supply(classId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} [denom] denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf(denom?: string, options?: any): AxiosPromise<SupplyOf200Response> {
            return localVarFp.supplyOf(denom, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult(proposalId: string, options?: any): AxiosPromise<TallyResult200Response> {
            return localVarFp.tallyResult(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryTotalSupplyResponseIsTheResponseTypeForTheQueryTotalSupplyRPCMethod> {
            return localVarFp.totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation(validatorAddr: string, delegatorAddr: string, options?: any): AxiosPromise<UnbondingDelegation200Response> {
            return localVarFp.unbondingDelegation(validatorAddr, delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier This rpc is deprecated now that IBC has its own replacement (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState(lastHeight: string, options?: any): AxiosPromise<UpgradedConsensusState200Response> {
            return localVarFp.upgradedConsensusState(lastHeight, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator(validatorAddr: string, options?: any): AxiosPromise<QueryValidatorResponseIsResponseTypeForTheQueryValidatorRPCMethod> {
            return localVarFp.validator(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission(validatorAddress: string, options?: any): AxiosPromise<QueryValidatorCommissionResponseIsTheResponseTypeForTheQueryValidatorCommissionRPCMethod> {
            return localVarFp.validatorCommission(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryValidatorDelegationsResponseIsResponseTypeForTheQueryValidatorDelegationsRPCMethod> {
            return localVarFp.validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards(validatorAddress: string, options?: any): AxiosPromise<ValidatorOutstandingRewards200Response> {
            return localVarFp.validatorOutstandingRewards(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes(validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<ValidatorSlashes200Response> {
            return localVarFp.validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<ValidatorUnbondingDelegations200Response> {
            return localVarFp.validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators(status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<QueryValidatorsResponseIsResponseTypeForTheQueryValidatorsRPCMethod> {
            return localVarFp.validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the voter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote(proposalId: string, voter: string, options?: any): AxiosPromise<Vote200Response> {
            return localVarFp.vote(proposalId, voter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary VoteByProposalVoter queries a vote by proposal id and voter.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {string} voter voter is a proposal voter account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteByProposalVoter(proposalId: string, voter: string, options?: any): AxiosPromise<VoteByProposalVoter200Response> {
            return localVarFp.voteByProposalVoter(proposalId, voter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<Votes200Response> {
            return localVarFp.votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary VotesByProposal queries a vote by proposal.
         * @param {string} proposalId proposal_id is the unique ID of a proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesByProposal(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<VotesByProposal200Response> {
            return localVarFp.votesByProposal(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary VotesByVoter queries a vote by voter.
         * @param {string} voter voter is a proposal voter account address.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votesByVoter(voter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<VotesByVoter200Response> {
            return localVarFp.votesByVoter(voter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary Class queries an NFT class based on its id
     * @param {string} classId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public _class(classId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration)._class(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Account returns account details based on address.
     * @param {string} address address defines the address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public account(address: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).account(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46.2
     * @summary AccountAddressByID returns account address based on account number.
     * @param {string} id id is the account number of the address to be queried. This field should have been an uint64 (like all account numbers), and will be updated to uint64 in a future version of the auth query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public accountAddressByID(id: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).accountAddressByID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.43
     * @summary Accounts returns all the existing accounts
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public accounts(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary AddressBytesToString converts Account Address bytes to string
     * @param {string} addressBytes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public addressBytesToString(addressBytes: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).addressBytesToString(addressBytes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary AddressStringToBytes converts Address string to bytes
     * @param {string} addressString 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public addressStringToBytes(addressString: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).addressStringToBytes(addressString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AllBalances queries the balance of all coins for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AllEvidence queries all evidence.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allEvidence(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allowance returns fee granted to the grantee by the granter.
     * @param {string} granter granter is the address of the user granting an allowance of their funds.
     * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allowance(granter: string, grantee: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).allowance(granter, grantee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allowances returns all the grants for address.
     * @param {string} grantee 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allowances(grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary AllowancesByGranter returns all the grants given by an address
     * @param {string} granter 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public allowancesByGranter(granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).allowancesByGranter(granter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AnnualProvisions current minting annual provisions value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public annualProvisions(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).annualProvisions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AppliedPlan queries a previously applied upgrade plan by its name.
     * @param {string} name name is the name of the applied plan to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public appliedPlan(name: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).appliedPlan(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public authParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).authParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary Returns the account with authority to conduct upgrades
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public authority(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).authority(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Balance queries the balance of a single coin for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} [denom] denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public balance(address: string, denom?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).balance(address, denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries the parameters of x/bank module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public bankParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).bankParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary Bech32Prefix queries bech32Prefix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public bech32Prefix(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).bech32Prefix(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Classes queries all NFT classes
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public classes(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).classes(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary CommunityPool queries the community pool coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public communityPool(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).communityPool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary CurrentPlan queries the current upgrade plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public currentPlan(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).currentPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delegation queries delegate info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegation(validatorAddr: string, delegatorAddr: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegation(validatorAddr, delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegationRewards queries the total rewards accrued by a delegation.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegationRewards(delegatorAddress: string, validatorAddress: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegationRewards(delegatorAddress, validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegationTotalRewards(delegatorAddress: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegationTotalRewards(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorDelegations queries all delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorUnbondingDelegations(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorValidator queries validator info for given delegator validator pair.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorValidator(delegatorAddr: string, validatorAddr: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegatorValidator(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorValidators queries the validators of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorValidators(delegatorAddress: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegatorValidators(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public delegatorWithdrawAddress(delegatorAddress: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).delegatorWithdrawAddress(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DenomsMetadata queries the client metadata of a given coin denomination.
     * @param {string} denom denom is the coin denom to query the metadata for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomMetadata(denom: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).denomMetadata(denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary DenomOwners queries for all account addresses that own a particular token denomination.
     * @param {string} denom denom defines the coin denomination to query all account holders for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomOwners(denom: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public denomsMetadata(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deposit queries single deposit information based proposalID, depositAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} depositor depositor defines the deposit addresses from the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public deposit(proposalId: string, depositor: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).deposit(proposalId, depositor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deposits queries all deposits of a single proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public deposits(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries params of the distribution module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public distributionParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).distributionParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Evidence queries evidence based on evidence hash.
     * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public evidence(evidenceHash: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).evidence(evidenceHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters of the gov module.
     * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govParams(paramsType: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govParams(paramsType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deposits queries all deposits of a single proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1Deposit(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1Deposit(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deposit queries single deposit information based proposalID, depositAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} depositor depositor defines the deposit addresses from the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1Deposit_1(proposalId: string, depositor: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1Deposit_1(proposalId, depositor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries all parameters of the gov module.
     * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1Params(paramsType: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1Params(paramsType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proposals queries all proposals based on given status.
     * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @param {string} [voter] voter defines the voter address for the proposals.
     * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1Proposal(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1Proposal(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proposal queries proposal details based on ProposalID.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1Proposal_2(proposalId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1Proposal_2(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TallyResult queries the tally of a proposal vote.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1TallyResult(proposalId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1TallyResult(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Vote queries voted information based on proposalID, voterAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} voter voter defines the voter address for the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1Vote(proposalId: string, voter: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1Vote(proposalId, voter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Votes queries votes of a given proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public govV1Votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).govV1Votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary GranteeGrants returns a list of `GrantAuthorization` by grantee.
     * @param {string} grantee 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public granteeGrants(grantee: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).granteeGrants(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary GranterGrants returns list of `GrantAuthorization`, granted by granter.
     * @param {string} granter 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public granterGrants(granter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).granterGrants(granter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of `Authorization`, granted to the grantee by the granter.
     * @param {string} [granter] 
     * @param {string} [grantee] 
     * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public grants(granter?: string, grantee?: string, msgTypeUrl?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GroupInfo queries group info based on group id.
     * @param {string} groupId group_id is the unique ID of the group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupInfo(groupId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupInfo(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GroupMembers queries members of a group
     * @param {string} groupId group_id is the unique ID of the group.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupMembers(groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupMembers(groupId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GroupsByAdmin queries group policies by admin address.
     * @param {string} admin admin is the admin address of the group policy.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupPoliciesByAdmin(admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupPoliciesByAdmin(admin, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GroupPoliciesByGroup queries group policies by group id.
     * @param {string} groupId group_id is the unique ID of the group policy\&#39;s group.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupPoliciesByGroup(groupId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupPoliciesByGroup(groupId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GroupPolicyInfo queries group policy info based on account address of group policy.
     * @param {string} address address is the account address of the group policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupPolicyInfo(address: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupPolicyInfo(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proposal queries a proposal based on proposal id.
     * @param {string} proposalId proposal_id is the unique ID of a proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupProposal(proposalId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupProposal(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TallyResult returns the tally result of a proposal. If the proposal is still in voting period, then this query computes the current tally state, which might not be final. On the other hand, if the proposal is final, then it simply returns the `final_tally_result` state stored in the proposal itself.
     * @param {string} proposalId proposal_id is the unique id of a proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupTallyResult(proposalId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupTallyResult(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GroupsByAdmin queries groups by admin address.
     * @param {string} admin admin is the account address of a group\&#39;s admin.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupsByAdmin(admin: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupsByAdmin(admin, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GroupsByMember queries groups by member address.
     * @param {string} address address is the group member address.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public groupsByMember(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).groupsByMember(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary HistoricalInfo queries the historical info for given height.
     * @param {string} height height defines at which height to query the historical info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public historicalInfo(height: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).historicalInfo(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inflation returns the current minting inflation value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public inflation(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).inflation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params returns the total set of minting parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public mintParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).mintParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ModuleAccountByName returns the module account info by module name
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public moduleAccountByName(name: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).moduleAccountByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary ModuleAccounts returns all the existing module accounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public moduleAccounts(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).moduleAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.43
     * @summary ModuleVersions queries the list of module versions from state.
     * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public moduleVersions(moduleName?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).moduleVersions(moduleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary NFT queries an NFT based on its class and id.
     * @param {string} classId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nFT(classId: string, id: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nFT(classId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary NFTs queries all NFTs of a given class or owner,choose at least one of the two, similar to tokenByIndex in ERC721Enumerable
     * @param {string} [classId] 
     * @param {string} [owner] 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nFTs(classId?: string, owner?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nFTs(classId, owner, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Balance queries the number of NFTs of a given class owned by the owner, same as balanceOf in ERC721
     * @param {string} owner 
     * @param {string} classId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public nftBalance(owner: string, classId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).nftBalance(owner, classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Owner queries the owner of the NFT based on its class and id, same as ownerOf in ERC721
     * @param {string} classId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public owner(classId: string, id: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).owner(classId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries a specific parameter of a module, given its subspace and key.
     * @param {string} [subspace] subspace defines the module to query the parameter for.
     * @param {string} [key] key defines the key of the parameter in the subspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public params(subspace?: string, key?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).params(subspace, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pool queries the pool info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public pool(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).pool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proposal queries proposal details based on ProposalID.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public proposal(proposalId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).proposal(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proposals queries all proposals based on given status.
     * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @param {string} [voter] voter defines the voter address for the proposals.
     * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public proposals(proposalStatus?: 'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED', voter?: string, depositor?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ProposalsByGroupPolicy queries proposals based on account address of group policy.
     * @param {string} address address is the account address of the group policy related to proposals.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public proposalsByGroupPolicy(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).proposalsByGroupPolicy(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Redelegations queries redelegations of given address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
     * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public redelegations(delegatorAddr: string, srcValidatorAddr?: string, dstValidatorAddr?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SigningInfo queries the signing info of given cons address
     * @param {string} consAddress cons_address is the address to query signing info of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public signingInfo(consAddress: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).signingInfo(consAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SigningInfos queries signing info of all validators
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public signingInfos(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Params queries the parameters of slashing module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public slashingParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).slashingParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary SpendableBalances queries the spenable balance of all coins for a single account.
     * @param {string} address address is the address to query spendable balances for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public spendableBalances(address: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).spendableBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DelegatorValidators queries all validators info for given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public stakingDelegatorValidators(delegatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parameters queries the staking parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public stakingParams(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).stakingParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.46
     * @summary Subspaces queries for all registered subspaces and all keys for a subspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public subspaces(options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).subspaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Supply queries the number of NFTs from the given class, same as totalSupply of ERC721.
     * @param {string} classId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public supply(classId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).supply(classId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SupplyOf queries the supply of a single coin.
     * @param {string} [denom] denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public supplyOf(denom?: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).supplyOf(denom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TallyResult queries the tally of a proposal vote.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public tallyResult(proposalId: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).tallyResult(proposalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary TotalSupply queries the total supply of all coins.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public totalSupply(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public unbondingDelegation(validatorAddr: string, delegatorAddr: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).unbondingDelegation(validatorAddr, delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier This rpc is deprecated now that IBC has its own replacement (https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)
     * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public upgradedConsensusState(lastHeight: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).upgradedConsensusState(lastHeight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validator queries validator info for given validator address.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validator(validatorAddr: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).validator(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorCommission queries accumulated commission for a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorCommission(validatorAddress: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).validatorCommission(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorDelegations queries delegate info for given validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorOutstandingRewards queries rewards of a validator address.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorOutstandingRewards(validatorAddress: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).validatorOutstandingRewards(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorSlashes queries slash events of a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
     * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorSlashes(validatorAddress: string, startingHeight?: string, endingHeight?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validatorUnbondingDelegations(validatorAddr: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validators queries all validators that match the given status.
     * @param {string} [status] status enables to query for validators matching a given status.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public validators(status?: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Vote queries voted information based on proposalID, voterAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} voter voter defines the voter address for the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public vote(proposalId: string, voter: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).vote(proposalId, voter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary VoteByProposalVoter queries a vote by proposal id and voter.
     * @param {string} proposalId proposal_id is the unique ID of a proposal.
     * @param {string} voter voter is a proposal voter account address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public voteByProposalVoter(proposalId: string, voter: string, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).voteByProposalVoter(proposalId, voter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Votes queries votes of a given proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public votes(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary VotesByProposal queries a vote by proposal.
     * @param {string} proposalId proposal_id is the unique ID of a proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public votesByProposal(proposalId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).votesByProposal(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary VotesByVoter queries a vote by voter.
     * @param {string} voter voter is a proposal voter account address.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public votesByVoter(voter: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return QueryApiFp(this.configuration).votesByVoter(voter, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Since: cosmos-sdk 0.46
         * @summary ABCIQuery defines a query handler that supports ABCI queries directly to the application, bypassing Tendermint completely. The ABCI query must contain a valid and supported path, including app, custom, p2p, and store.
         * @param {string} [data] 
         * @param {string} [path] 
         * @param {string} [height] 
         * @param {boolean} [prove] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aBCIQuery: async (data?: string, path?: string, height?: string, prove?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/abci_query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (prove !== undefined) {
                localVarQueryParameter['prove'] = prove;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary BroadcastTx broadcast transaction.
         * @param {BroadcastTxRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx: async (body: BroadcastTxRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('broadcastTx', 'body', body)
            const localVarPath = `/cosmos/tx/v1beta1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: async (height: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getBlockByHeight', 'height', height)
            const localVarPath = `/cosmos/base/tendermint/v1beta1/blocks/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Since: cosmos-sdk 0.45.2
         * @summary GetBlockWithTxs fetches a block with decoded txs.
         * @param {string} height height is the height of the block to query.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockWithTxs: async (height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getBlockWithTxs', 'height', height)
            const localVarPath = `/cosmos/tx/v1beta1/txs/block/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/blocks/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/validatorsets/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/node_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/syncing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getTx', 'hash', hash)
            const localVarPath = `/cosmos/tx/v1beta1/txs/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {string} [page] page is the page number to query, starts at 1. If not provided, will default to first page.
         * @param {string} [limit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent: async (events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', page?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cosmos/tx/v1beta1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (events) {
                localVarQueryParameter['events'] = events;
            }

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight: async (height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getValidatorSetByHeight', 'height', height)
            const localVarPath = `/cosmos/base/tendermint/v1beta1/validatorsets/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }

            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate: async (body: CosmosTxV1beta1SimulateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('simulate', 'body', body)
            const localVarPath = `/cosmos/tx/v1beta1/simulate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Since: cosmos-sdk 0.46
         * @summary ABCIQuery defines a query handler that supports ABCI queries directly to the application, bypassing Tendermint completely. The ABCI query must contain a valid and supported path, including app, custom, p2p, and store.
         * @param {string} [data] 
         * @param {string} [path] 
         * @param {string} [height] 
         * @param {boolean} [prove] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aBCIQuery(data?: string, path?: string, height?: string, prove?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABCIQuery200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aBCIQuery(data, path, height, prove, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary BroadcastTx broadcast transaction.
         * @param {BroadcastTxRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTx(body: BroadcastTxRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BroadcastTx200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeight(height: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBlockByHeight200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockByHeight(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Since: cosmos-sdk 0.45.2
         * @summary GetBlockWithTxs fetches a block with decoded txs.
         * @param {string} height height is the height of the block to query.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockWithTxs(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CosmosTxV1beta1GetBlockWithTxsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockWithTxs(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestBlock(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLatestBlock200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestBlock(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestValidatorSet(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLatestValidatorSet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNodeInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncing(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSyncing200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSyncing(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTx(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CosmosTxV1beta1GetTxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTx(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {string} [page] page is the page number to query, starts at 1. If not provided, will default to first page.
         * @param {string} [limit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxsEvent(events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', page?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CosmosTxV1beta1GetTxsEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidatorSetByHeight(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetValidatorSetByHeight200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulate(body: CosmosTxV1beta1SimulateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Simulate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceApiFp(configuration)
    return {
        /**
         * Since: cosmos-sdk 0.46
         * @summary ABCIQuery defines a query handler that supports ABCI queries directly to the application, bypassing Tendermint completely. The ABCI query must contain a valid and supported path, including app, custom, p2p, and store.
         * @param {string} [data] 
         * @param {string} [path] 
         * @param {string} [height] 
         * @param {boolean} [prove] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aBCIQuery(data?: string, path?: string, height?: string, prove?: boolean, options?: any): AxiosPromise<ABCIQuery200Response> {
            return localVarFp.aBCIQuery(data, path, height, prove, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary BroadcastTx broadcast transaction.
         * @param {BroadcastTxRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx(body: BroadcastTxRequest, options?: any): AxiosPromise<BroadcastTx200Response> {
            return localVarFp.broadcastTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight(height: string, options?: any): AxiosPromise<GetBlockByHeight200Response> {
            return localVarFp.getBlockByHeight(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Since: cosmos-sdk 0.45.2
         * @summary GetBlockWithTxs fetches a block with decoded txs.
         * @param {string} height height is the height of the block to query.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockWithTxs(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<CosmosTxV1beta1GetBlockWithTxsResponse> {
            return localVarFp.getBlockWithTxs(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock(options?: any): AxiosPromise<GetLatestBlock200Response> {
            return localVarFp.getLatestBlock(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GetLatestValidatorSet200Response> {
            return localVarFp.getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo(options?: any): AxiosPromise<GetNodeInfo200Response> {
            return localVarFp.getNodeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing(options?: any): AxiosPromise<GetSyncing200Response> {
            return localVarFp.getSyncing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(hash: string, options?: any): AxiosPromise<CosmosTxV1beta1GetTxResponse> {
            return localVarFp.getTx(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {string} [page] page is the page number to query, starts at 1. If not provided, will default to first page.
         * @param {string} [limit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent(events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', page?: string, limit?: string, options?: any): AxiosPromise<CosmosTxV1beta1GetTxsEventResponse> {
            return localVarFp.getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: any): AxiosPromise<GetValidatorSetByHeight200Response> {
            return localVarFp.getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate(body: CosmosTxV1beta1SimulateRequest, options?: any): AxiosPromise<Simulate200Response> {
            return localVarFp.simulate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     * Since: cosmos-sdk 0.46
     * @summary ABCIQuery defines a query handler that supports ABCI queries directly to the application, bypassing Tendermint completely. The ABCI query must contain a valid and supported path, including app, custom, p2p, and store.
     * @param {string} [data] 
     * @param {string} [path] 
     * @param {string} [height] 
     * @param {boolean} [prove] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public aBCIQuery(data?: string, path?: string, height?: string, prove?: boolean, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).aBCIQuery(data, path, height, prove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary BroadcastTx broadcast transaction.
     * @param {BroadcastTxRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public broadcastTx(body: BroadcastTxRequest, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).broadcastTx(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetBlockByHeight queries block for given height.
     * @param {string} height 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getBlockByHeight(height: string, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getBlockByHeight(height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Since: cosmos-sdk 0.45.2
     * @summary GetBlockWithTxs fetches a block with decoded txs.
     * @param {string} height height is the height of the block to query.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getBlockWithTxs(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getBlockWithTxs(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetLatestBlock returns the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getLatestBlock(options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getLatestBlock(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetLatestValidatorSet queries latest validator-set.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getLatestValidatorSet(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetNodeInfo queries the current node info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getNodeInfo(options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getNodeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetSyncing queries node syncing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getSyncing(options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getSyncing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetTx fetches a tx by hash.
     * @param {string} hash hash is the tx hash to query, encoded as a hex string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getTx(hash: string, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getTx(hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetTxsEvent fetches txs by event.
     * @param {Array<string>} [events] events is the list of transaction event type.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
     * @param {string} [page] page is the page number to query, starts at 1. If not provided, will default to first page.
     * @param {string} [limit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getTxsEvent(events?: Array<string>, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, orderBy?: 'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC', page?: string, limit?: string, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetValidatorSetByHeight queries validator-set at a given height.
     * @param {string} height 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.  Since: cosmos-sdk 0.43
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public getValidatorSetByHeight(height: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, paginationReverse?: boolean, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulate simulates executing a transaction for estimating gas usage.
     * @param {CosmosTxV1beta1SimulateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    public simulate(body: CosmosTxV1beta1SimulateRequest, options?: AxiosRequestConfig) {
        return ServiceApiFp(this.configuration).simulate(body, options).then((request) => request(this.axios, this.basePath));
    }
}


